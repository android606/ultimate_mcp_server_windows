<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate UMS Explorer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z'/><path d='M5 10a7 7 0 1 0 14 0'/><path d='M15 13a3 3 0 0 0-6 0 v6a3 3 0 0 0 6 0 v-6Z'/></svg>">
    
    <!-- TailwindCSS (CDN for development - warning is expected) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            900: '#1e3a8a'
                        },
                        secondary: {
                            500: '#8b5cf6',
                            600: '#7c3aed'
                        }
                    },
                    animation: {
                        'slide-in': 'slideIn 0.5s ease-out',
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'scale-in': 'scaleIn 0.2s ease-out',
                        'pulse-ring': 'pulseRing 2s infinite',
                        'shimmer': 'shimmer 2s infinite',
                        'bounce-subtle': 'bounceSubtle 1s ease-in-out infinite'
                    },
                    backdropBlur: {
                        xs: '2px'
                    }
                }
            }
        }
    </script>
    
    <!-- DaisyUI -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.1/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.8/dist/cdn.min.js"></script>
    
    <!-- SQL.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    
    <!-- D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Mermaid.js for flowcharts -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    
    <!-- Toastify -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    
    <!-- Tippy.js for beautiful tooltips -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css">
    
    <!-- Sortable.js for drag & drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <!-- Virtual Scroll for performance -->
    <script src="https://unpkg.com/@tanstack/virtual-core@3.0.0/build/lib/index.umd.js"></script>
    
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    
    <!-- Highlight.js for syntax highlighting -->
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --color-primary: #3b82f6;
            --color-secondary: #8b5cf6;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-error: #ef4444;
        }
        
        /* Light theme variables */
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-tertiary: #64748b;
            --border-color: #e2e8f0;
            --glass-bg: rgba(255, 255, 255, 0.8);
            --card-bg: rgba(255, 255, 255, 0.9);
        }
        
        /* Dark theme variables */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-color: rgba(255, 255, 255, 0.1);
            --glass-bg: rgba(15, 23, 42, 0.8);
            --card-bg: rgba(15, 23, 42, 0.9);
        }
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        [x-cloak] { display: none !important; }
        
        /* Custom Animations */
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes scaleIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        @keyframes pulseRing {
            0% { transform: scale(0.8); opacity: 1; }
            80%, 100% { transform: scale(1.2); opacity: 0; }
        }
        
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }
        
        @keyframes bounceSubtle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        
        /* Glass morphism effects */
        [data-theme="dark"] .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        [data-theme="light"] .glass {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        [data-theme="dark"] .glass-dark {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        [data-theme="light"] .glass-dark {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* Enhanced cards */
        [data-theme="dark"] .enhanced-card {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        [data-theme="light"] .enhanced-card {
            background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        [data-theme="dark"] .enhanced-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        [data-theme="light"] .enhanced-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* Memory level colors */
        .memory-working { border-left: 4px solid #f59e0b; background: linear-gradient(90deg, rgba(245, 158, 11, 0.1), transparent); }
        .memory-episodic { border-left: 4px solid #3b82f6; background: linear-gradient(90deg, rgba(59, 130, 246, 0.1), transparent); }
        .memory-semantic { border-left: 4px solid #10b981; background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), transparent); }
        .memory-procedural { border-left: 4px solid #8b5cf6; background: linear-gradient(90deg, rgba(139, 92, 246, 0.1), transparent); }
        
        /* Advanced search */
        .search-container {
            position: relative;
        }
        
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            z-index: 50;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Loading skeletons */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200px 100%;
            animation: shimmer 1.5s infinite;
        }
        
        /* Dark mode adjustments */
        [data-theme="dark"] .skeleton {
            background: linear-gradient(90deg, #2a2a2a 25%, #1a1a1a 50%, #2a2a2a 75%);
        }
        
        /* Enhanced scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.5);
        }
        
        /* Status indicators */
        .status-indicator {
            position: relative;
            display: inline-block;
        }
        
        .status-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            animation: pulse-ring 2s infinite;
        }
        
        .status-active::before { background: var(--color-success); }
        .status-completed::before { background: var(--color-primary); }
        .status-failed::before { background: var(--color-error); }
        .status-paused::before { background: var(--color-warning); }
        
        /* Data table enhancements */
        .data-table {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            overflow: hidden;
        }
        
        .data-table th {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .data-table tr:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        /* Floating action button */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
            color: white;
            border: none;
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }
        
        /* Command palette */
        .command-palette {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            backdrop-filter: blur(20px);
            border-radius: 16px;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        [data-theme="dark"] .command-palette {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb;
        }
        
        [data-theme="light"] .command-palette {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1e293b;
        }
        
        [data-theme="dark"] .command-palette input {
            color: #e5e7eb;
        }
        
        [data-theme="light"] .command-palette input {
            color: #1e293b;
        }
        
        [data-theme="dark"] .command-palette input::placeholder {
            color: #9ca3af;
        }
        
        [data-theme="light"] .command-palette input::placeholder {
            color: #64748b;
        }
        
        /* Toast customization */
        .toastify {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 12px !important;
            color: #1f2937 !important;
        }
        
        .toastify.success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9)) !important;
            color: white !important;
        }
        
        .toastify.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9)) !important;
            color: white !important;
        }
        
        /* Charts enhancements */
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
            .fab {
                bottom: 1rem;
                right: 1rem;
                width: 48px;
                height: 48px;
            }
            
            .command-palette {
                width: 95%;
            }
        }
        
        /* Performance optimizations */
        .will-change-transform {
            will-change: transform;
        }
        
        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
        }

        /* Markdown content styling */
        .markdown-content {
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            line-height: 1.25;
        }
        
        .markdown-content h1 {
            font-size: 2em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.3em;
        }
        
        .markdown-content h2 {
            font-size: 1.5em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.3em;
        }
        
        .markdown-content h3 {
            font-size: 1.25em;
        }
        
        .markdown-content p {
            margin-top: 0;
            margin-bottom: 1em;
        }
        
        .markdown-content blockquote {
            margin: 0;
            padding: 0 1em;
            color: #8b949e;
            border-left: 0.25em solid #30363d;
        }
        
        .markdown-content ul,
        .markdown-content ol {
            margin-top: 0;
            margin-bottom: 1em;
            padding-left: 2em;
        }
        
        .markdown-content li {
            margin-bottom: 0.25em;
        }
        
        .markdown-content pre {
            padding: 1em;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.375rem;
            margin: 1em 0;
        }
        
        .markdown-content code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 0.25rem;
        }
        
        .markdown-content pre code {
            padding: 0;
            background-color: transparent;
            border-radius: 0;
        }
        
        .markdown-content table {
            border-spacing: 0;
            border-collapse: collapse;
            display: block;
            width: max-content;
            max-width: 100%;
            overflow: auto;
            margin: 1em 0;
        }
        
        .markdown-content table th,
        .markdown-content table td {
            padding: 6px 13px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .markdown-content table th {
            font-weight: 600;
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .markdown-content img {
            max-width: 100%;
            height: auto;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .markdown-content a {
            color: #58a6ff;
            text-decoration: none;
        }
        
        .markdown-content a:hover {
            text-decoration: underline;
        }
        
        .markdown-content hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: rgba(255, 255, 255, 0.1);
            border: 0;
        }

        /* Artifact Gallery Masonry Grid */
        .masonry-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1.5rem;
            align-items: start;
        }
        
        .masonry-item {
            break-inside: avoid;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }
        
        .masonry-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-width: 768px) {
            .masonry-grid {
                grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
                gap: 1rem;
            }
        }
        
        @media (max-width: 640px) {
            .masonry-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }
        
        /* Artifact type colors */
        .type-image { background-color: #10b981; }
        .type-document { background-color: #3b82f6; }
        .type-code { background-color: #10b981; }
        .type-data { background-color: #8b5cf6; }
        .type-model { background-color: #f59e0b; }
        .type-default { background-color: #6b7280; }
        
        /* Line clamp utilities */
        .line-clamp-1 {
            display: -webkit-box;
            -webkit-line-clamp: 1;
            line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .line-clamp-3 {
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Artifact preview animations */
        .artifact-preview {
            position: relative;
            overflow: hidden;
        }
        
        .artifact-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .artifact-preview:hover::before {
            left: 100%;
        }
        
        /* Image loading states */
        .image-loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        [data-theme="dark"] .image-loading {
            background: linear-gradient(90deg, #2a2a2a 25%, #1a1a1a 50%, #2a2a2a 75%);
            background-size: 200% 100%;
        }
        
        /* Artifact relationship indicators */
        .relationship-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                var(--color-primary) 20%, 
                var(--color-secondary) 50%, 
                var(--color-primary) 80%, 
                transparent 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .masonry-item:hover .relationship-indicator {
            opacity: 1;
        }
        
        /* Thought Chain Flow Diagram Styles */
        .thought-chain-container {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            min-height: 70vh;
        }
        
        .mermaid-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 2rem;
        }
        
        .timeline-scrubber {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .timeline-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #374151, #6b7280);
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            cursor: pointer;
        }
        
        .timeline-slider:hover {
            opacity: 1;
        }
        
        .timeline-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
            transition: all 0.2s ease;
        }
        
        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.6);
        }
        
        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }
        
        .playback-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .playback-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .playback-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }
        
        .playback-btn:active {
            transform: scale(0.95);
        }
        
        .playback-btn.secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.3);
        }
        
        .timeline-markers {
            position: relative;
            height: 20px;
            margin: 0.5rem 0;
        }
        
        .timeline-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            top: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .timeline-marker:hover {
            background: rgba(59, 130, 246, 0.8);
            width: 4px;
            margin-left: -1px;
        }
        
        .timeline-marker.major {
            background: rgba(255, 255, 255, 0.5);
            height: 100%;
        }
        
        .timeline-marker.current {
            background: #3b82f6;
            width: 4px;
            margin-left: -1px;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
        }
        
        .thought-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .thought-node.active {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
            transform: scale(1.02);
        }
        
        .thought-node.dimmed {
            opacity: 0.3;
        }
        
        .thought-node.highlighted {
            filter: drop-shadow(0 0 12px rgba(34, 197, 94, 0.8));
        }
        
        .chain-sidebar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 16rem);
            overflow-y: auto;
        }
        
        .chain-metadata {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 1rem;
        }
        
        .thought-details {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            border-left: 4px solid #3b82f6;
        }
        
        .branch-indicator {
            position: relative;
            margin: 0.5rem 0;
        }
        
        .branch-indicator::before {
            content: '';
            position: absolute;
            left: -1rem;
            top: 50%;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #8b5cf6;
            transform: translateY(-50%);
        }
        
        .chain-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .chain-stat {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .chain-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3b82f6;
        }
        
        .chain-stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Mermaid diagram customization */
        .mermaid .node rect {
            stroke: rgba(59, 130, 246, 0.5) !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .mermaid .node.active rect {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 4px 8px rgba(59,130,246,0.5));
        }
        
        .mermaid .edgePath path {
            stroke: rgba(255, 255, 255, 0.4) !important;
            stroke-width: 2px !important;
        }
        
        .mermaid .edgePath.active path {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 2px 4px rgba(59,130,246,0.5));
        }
        
        .mermaid .nodeLabel {
            color: #e5e7eb !important;
            font-family: 'Inter', sans-serif !important;
            font-size: 12px !important;
            font-weight: 500 !important;
        }
        
        /* Speed control styling */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        
        .speed-btn {
            padding: 0.25rem 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e5e7eb;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .speed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .speed-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        /* Graph visualization styles */
        .graph-container {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        .graph-svg:active {
            cursor: grabbing;
        }
        
        .graph-node {
            cursor: pointer;
            stroke-width: 2px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.2s ease;
        }
        
        .graph-node:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }
        
        .graph-node.selected {
            stroke-width: 4px;
            filter: drop-shadow(0 6px 12px rgba(59,130,246,0.5));
        }
        
        .graph-link {
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s ease;
        }
        
        .graph-link.highlighted {
            stroke-opacity: 1;
            stroke-width: 3px;
        }
        
        .graph-text {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 500;
            fill: #e5e7eb;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .graph-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .graph-sidebar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 12rem);
            overflow-y: auto;
        }
        
        .graph-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 0.5rem;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .cluster-outline {
            fill: none;
            stroke: rgba(255,255,255,0.2);
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.7;
        }
        
        .graph-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Advanced micro-interactions */
        .interactive {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .interactive:active {
            transform: scale(0.98);
        }
        
        /* Loading states */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.3);
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Tippy.js styles */
        .tippy-box[data-theme~='custom'] {
            background: linear-gradient(135deg, rgba(30, 30, 46, 0.95) 0%, rgba(49, 46, 129, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            max-width: 350px;
        }
        
        .tippy-box[data-theme~='custom'] .tippy-content {
            padding: 20px;
            color: #ffffff;
            line-height: 1.5;
        }
        
        .tippy-box[data-theme~='custom'] .tippy-arrow {
            color: rgba(30, 30, 46, 0.95);
        }
        
        .tooltip-content h4 {
            font-size: 16px;
            margin-bottom: 8px;
        }
        
        .tooltip-content p {
            margin-bottom: 8px;
            font-size: 13px;
            opacity: 0.9;
        }
        
        .tooltip-content strong {
            color: #e2e8f0;
        }
    </style>
</head>
<body class="min-h-screen transition-colors duration-300" x-data="umsExplorer()" x-cloak 
      :class="theme === 'light' ? 'bg-gradient-to-br from-slate-50 via-blue-50 to-slate-50 text-slate-900' : 'bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 text-white'"
      :style="`background: ${theme === 'light' ? 'linear-gradient(135deg, #f8fafc, #eff6ff, #f8fafc)' : 'linear-gradient(135deg, #0f172a, #1e3a8a, #0f172a)'}`">

    <!-- Command Palette -->
    <div x-show="showCommandPalette" 
         x-transition:enter="transition ease-out duration-200" 
         x-transition:enter-start="opacity-0" 
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-150" 
         x-transition:leave-start="opacity-100" 
         x-transition:leave-end="opacity-0"
         class="fixed inset-0 bg-black/50 z-[1000]" 
         @click="showCommandPalette = false">
        <div class="command-palette" @click.stop="">
            <div class="p-4">
                <input type="text" 
                       x-model="commandQuery" 
                       @input="updateCommands"
                       @keydown.enter="executeCommand"
                       @keydown.escape="showCommandPalette = false"
                       placeholder="Type a command or search..."
                       class="w-full p-3 rounded-lg bg-transparent border border-white/20 text-lg focus:outline-none focus:border-blue-400">
                <div class="mt-4 max-h-80 overflow-y-auto">
                    <template x-for="cmd in filteredCommands" :key="cmd.id">
                        <div class="p-3 rounded-lg hover:bg-white/10 cursor-pointer transition-colors" 
                             @click="executeCommand(cmd)">
                            <div class="flex items-center">
                                <i :data-lucide="cmd.icon" class="w-5 h-5 mr-3"></i>
                                <div>
                                    <div class="font-medium" x-text="cmd.title"></div>
                                    <div class="text-sm text-gray-400" x-text="cmd.description"></div>
                                </div>
                                <div class="ml-auto text-sm text-gray-500" x-text="cmd.shortcut"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </div>

    <!-- Header with enhanced navigation -->
    <header class="glass-dark border-b border-white/10 sticky top-0 z-40">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <!-- Logo and breadcrumbs -->
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-3 cursor-pointer group" @click="navigateTo('dashboard')">
                        <div class="relative">
                            <div class="w-10 h-10 rounded-xl bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center group-hover:scale-105 transition-transform">
                                <i data-lucide="brain-circuit" class="w-6 h-6"></i>
                            </div>
                            <div x-show="isProcessing" class="absolute inset-0 rounded-xl border-2 border-blue-400 animate-pulse-ring"></div>
                        </div>
                        <div>
                            <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent group-hover:from-blue-300 group-hover:to-purple-300 transition-colors">
                                UMS Explorer
                            </h1>
                            <p class="text-xs text-gray-400 group-hover:text-gray-300 transition-colors">Unified Memory System</p>
                        </div>
                    </div>
                    
                    <!-- Breadcrumbs -->
                    <nav x-show="dbLoaded" class="hidden md:flex">
                        <ol class="flex items-center space-x-2 text-sm">
                            <li><a href="#" @click="currentView = 'dashboard'" 
                                   class="text-gray-400 hover:text-white transition-colors"
                                   :class="{'text-blue-400': currentView === 'dashboard'}">Dashboard</a></li>
                            <template x-if="currentView !== 'dashboard'">
                                <li class="text-gray-600">/</li>
                                <li class="text-blue-400 capitalize" x-text="currentView"></li>
                            </template>
                        </ol>
                    </nav>
                </div>
                
                <!-- Right side controls -->
                <div class="flex items-center space-x-4">
                    <!-- Advanced search -->
                    <div x-show="dbLoaded" class="relative search-container">
                        <div class="relative">
                            <input type="text" 
                                   x-model="globalSearch" 
                                   @input.debounce.300ms="performGlobalSearch"
                                   @focus="showSearchSuggestions = true"
                                   @blur.delay.150ms="showSearchSuggestions = false"
                                   placeholder="Search everything..." 
                                   class="w-64 pl-10 pr-4 py-2 bg-white/10 backdrop-blur-md border border-white/20 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:border-blue-400 focus:bg-white/20 transition-all">
                            <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400"></i>
                        </div>
                        
                        <!-- Search suggestions -->
                        <div x-show="showSearchSuggestions && searchSuggestions.length > 0" 
                             class="search-suggestions mt-2 p-2">
                            <template x-for="suggestion in searchSuggestions.slice(0, 5)" :key="suggestion.id">
                                <div class="p-2 hover:bg-white/10 rounded-lg cursor-pointer transition-colors" 
                                     @click="selectSearchSuggestion(suggestion)">
                                    <div class="flex items-center">
                                        <i :data-lucide="suggestion.icon" class="w-4 h-4 mr-2 text-gray-400"></i>
                                        <div>
                                            <div class="text-sm font-medium" x-text="suggestion.title"></div>
                                            <div class="text-xs text-gray-500" x-text="suggestion.type"></div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    
                    <!-- Database status -->
                    <div x-show="dbLoaded" class="hidden md:flex items-center space-x-2">
                        <div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-300">Connected</span>
                    </div>
                    
                    <!-- Theme toggle -->
                    <button @click="toggleTheme()" 
                            class="p-2 rounded-lg bg-white/10 backdrop-blur-md border border-white/20 hover:bg-white/20 transition-all interactive">
                        <i :data-lucide="theme === 'dark' ? 'sun' : 'moon'" class="w-4 h-4"></i>
                    </button>
                    
                    <!-- Command palette trigger -->
                    <button @click="showCommandPalette = true" 
                            class="p-2 rounded-lg bg-white/10 backdrop-blur-md border border-white/20 hover:bg-white/20 transition-all interactive">
                        <i data-lucide="command" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main content area -->
    <main class="container mx-auto px-4 py-6">
        <!-- Database loading state -->
        <div x-show="!dbLoaded && !isLoading" class="min-h-[70vh] flex items-center justify-center">
            <div class="enhanced-card rounded-2xl p-8 max-w-md w-full text-center animate-scale-in">
                <div class="mb-6">
                    <div class="w-20 h-20 bg-gradient-to-r from-blue-500 to-purple-600 rounded-2xl flex items-center justify-center mx-auto mb-4 animate-bounce-subtle">
                        <i data-lucide="database" class="w-10 h-10"></i>
                    </div>
                    <h2 class="text-2xl font-bold mb-2">Load Your UMS Database</h2>
                    <p class="text-gray-400">Drag and drop your database file or click to browse</p>
                </div>
                
                <div class="drop-zone relative rounded-xl border-2 border-dashed border-gray-600 hover:border-blue-400 transition-colors p-8 cursor-pointer group"
                     @drop.prevent="handleFileDrop($event)"
                     @dragover.prevent="$event.currentTarget.classList.add('border-blue-400', 'bg-blue-400/10')"
                     @dragleave.prevent="$event.currentTarget.classList.remove('border-blue-400', 'bg-blue-400/10')"
                     @click="$refs.fileInput.click()">
                    <div class="text-center">
                        <i data-lucide="upload-cloud" class="w-12 h-12 mx-auto mb-4 text-gray-400 group-hover:text-blue-400 transition-colors"></i>
                        <p class="font-medium mb-2">Drop your database file here</p>
                        <p class="text-sm text-gray-500">Supports .db, .sqlite, .sqlite3 files</p>
                    </div>
                    <input type="file" 
                           x-ref="fileInput" 
                           @change="loadDatabase($event)" 
                           accept=".db,.sqlite,.sqlite3" 
                           class="hidden" />
                </div>
                
                <div class="mt-6 p-4 bg-blue-500/10 rounded-lg border border-blue-500/20">
                    <div class="flex items-center text-sm text-blue-300">
                        <i data-lucide="info" class="w-4 h-4 mr-2"></i>
                        <span>Default location: <code class="bg-black/20 px-2 py-1 rounded">./storage/unified_agent_memory.db</code></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading state -->
        <div x-show="isLoading" class="min-h-[70vh] flex items-center justify-center">
            <div class="text-center animate-fade-in">
                <div class="spinner mb-4 mx-auto"></div>
                <p class="text-xl font-medium mb-2" x-text="loadingMessage"></p>
                <p class="text-gray-400">Please wait while we process your data...</p>
            </div>
        </div>

        <!-- Dashboard -->
        <div x-show="dbLoaded && currentView === 'dashboard'" class="space-y-6 animate-slide-in">
            <!-- Quick stats -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-blue-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="brain" class="w-6 h-6 text-blue-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalMemories || 0"></div>
                            <div class="text-sm text-gray-400">Memories</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalMemories / 1000) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-purple-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="git-branch" class="w-6 h-6 text-purple-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalWorkflows || 0"></div>
                            <div class="text-sm text-gray-400">Workflows</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-purple-500 to-purple-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalWorkflows / 50) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="zap" class="w-6 h-6 text-green-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalActions || 0"></div>
                            <div class="text-sm text-gray-400">Actions</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-green-500 to-green-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalActions / 500) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-yellow-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="target" class="w-6 h-6 text-yellow-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalGoals || 0"></div>
                            <div class="text-sm text-gray-400">Goals</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-yellow-500 to-yellow-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalGoals / 100) * 100)}%`"></div>
                    </div>
                </div>
            </div>

                         <!-- Navigation cards -->
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('workflows')" 
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-purple-400 mb-2'> Workflows</h4><p>Explore and analyze AI agent execution workflows - complete journeys from start to finish.</p><p><strong>What it does:</strong> Shows step-by-step progression of AI tasks, including planning, execution, and completion phases.</p><p><strong>Why it's useful:</strong> Understand how your AI agents solve problems, identify bottlenecks, and optimize processes.</p><p><strong>Best used for:</strong> Debugging agent behavior, performance analysis, and workflow optimization.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-purple-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="git-branch" class="w-6 h-6 text-purple-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Workflows</h3>
                             <p class="text-sm text-gray-400">Explore AI agent workflows</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">View all workflows</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-purple-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('memories')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-blue-400 mb-2'> Memory System</h4><p>Dive deep into the hierarchical memory structure that powers AI cognition and learning.</p><p><strong>What it does:</strong> Displays episodic, semantic, and working memory with relationships and retrieval patterns.</p><p><strong>Why it's useful:</strong> Understand memory formation, recall mechanisms, and knowledge organization.</p><p><strong>Best used for:</strong> Memory debugging, knowledge base analysis, and cognitive architecture understanding.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-blue-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="brain" class="w-6 h-6 text-blue-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Memory System</h3>
                             <p class="text-sm text-gray-400">Dive into memory hierarchy</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Explore memories</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-blue-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('actions')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-orange-400 mb-2'> Actions</h4><p>Review and analyze all executed actions with detailed execution metrics and outcomes.</p><p><strong>What it does:</strong> Provides comprehensive logs of tool usage, execution times, success rates, and error analysis.</p><p><strong>Why it's useful:</strong> Track performance, identify slow operations, and debug failed actions.</p><p><strong>Best used for:</strong> Performance optimization, error investigation, and tool usage analysis.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-orange-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="zap" class="w-6 h-6 text-orange-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Actions</h3>
                             <p class="text-sm text-gray-400">Review executed actions</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Browse actions</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-orange-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('goals')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-yellow-400 mb-2'> Goal Hierarchy</h4><p>Interactive tree visualization of goals, sub-goals, and their dependencies with progress tracking.</p><p><strong>What it does:</strong> Shows goal decomposition, priority levels, completion status, and blocking relationships.</p><p><strong>Why it's useful:</strong> Understand goal planning, track progress, and identify bottlenecks in task completion.</p><p><strong>Best used for:</strong> Project management, goal alignment, and progress monitoring.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-yellow-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="target" class="w-6 h-6 text-yellow-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Goal Hierarchy</h3>
                             <p class="text-sm text-gray-400">Interactive goal tree & dependencies</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Manage goals</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-yellow-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('analytics')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-green-400 mb-2'> Analytics</h4><p>Visualize patterns, insights, and trends across all system components with interactive charts.</p><p><strong>What it does:</strong> Generates comprehensive reports on performance, usage patterns, and behavioral trends.</p><p><strong>Why it's useful:</strong> Data-driven decision making, pattern recognition, and system optimization.</p><p><strong>Best used for:</strong> Performance analysis, trend identification, and strategic planning.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="bar-chart-3" class="w-6 h-6 text-green-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Analytics</h3>
                             <p class="text-sm text-gray-400">Visualize patterns & insights</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">View analytics</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-green-400 transition-colors"></i>
                     </div>
                 </div>
             </div>

             <!-- Second row of navigation cards -->
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('graph')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-cyan-400 mb-2'> Memory Graph</h4><p>Interactive network visualization showing relationships between memories, concepts, and entities.</p><p><strong>What it does:</strong> Creates force-directed graphs with clustering, filtering, and path-finding capabilities.</p><p><strong>Why it's useful:</strong> Discover hidden connections, understand knowledge structure, and explore semantic relationships.</p><p><strong>Best used for:</strong> Knowledge exploration, relationship discovery, and semantic analysis.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-cyan-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="network" class="w-6 h-6 text-cyan-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Memory Graph</h3>
                             <p class="text-sm text-gray-400">Interactive network visualization</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Explore connections</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-cyan-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('thought-chains')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-indigo-400 mb-2'> Thought Chains</h4><p>Visualize reasoning flow diagrams showing how thoughts connect and evolve over time.</p><p><strong>What it does:</strong> Maps logical progression of ideas, decision points, and reasoning branches.</p><p><strong>Why it's useful:</strong> Understand AI reasoning processes, identify logical gaps, and trace decision paths.</p><p><strong>Best used for:</strong> Reasoning analysis, logic debugging, and cognitive process understanding.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-indigo-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="git-branch-plus" class="w-6 h-6 text-indigo-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Thought Chains</h3>
                             <p class="text-sm text-gray-400">Reasoning flow diagrams</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Trace reasoning paths</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-indigo-400 transition-colors"></i>
                     </div>
                 </div>
                 
                                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('semantic-search')"
                         data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-rose-400 mb-2'> Semantic Search</h4><p>Vector similarity search with intelligent clustering and contextual understanding.</p><p><strong>What it does:</strong> Uses AI embeddings to find conceptually similar content, not just keyword matches.</p><p><strong>Why it's useful:</strong> Discover related information, find implicit connections, and search by meaning rather than exact terms.</p><p><strong>Best used for:</strong> Research, content discovery, and exploring thematic relationships.</p></div>"
                         data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-rose-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="search" class="w-6 h-6 text-rose-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Semantic Search</h3>
                                <p class="text-sm text-gray-400">Vector similarity with clustering</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Advanced search intelligence</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-rose-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('working-memory')"
                         data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-amber-400 mb-2'> Working Memory</h4><p>Real-time memory management with live optimization and interactive controls.</p><p><strong>What it does:</strong> Monitors active memory usage, provides manual memory management, and shows memory loading/unloading in real-time.</p><p><strong>Why it's useful:</strong> Optimize memory usage, prevent memory overload, and fine-tune cognitive performance.</p><p><strong>Best used for:</strong> Performance tuning, memory debugging, and real-time system optimization.</p></div>"
                         data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-amber-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="cpu" class="w-6 h-6 text-amber-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Working Memory</h3>
                                <p class="text-sm text-gray-400">Real-time memory management</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Live optimization & controls</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-amber-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('cognitive-timeline')"
                         data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-emerald-400 mb-2'> Cognitive Timeline</h4><p>State snapshots with diff views, pattern analysis, and cognitive state restoration capabilities.</p><p><strong>What it does:</strong> Captures cognitive states over time, analyzes patterns in AI behavior, and enables rollback to previous states.</p><p><strong>Why it's useful:</strong> Debug cognitive drift, understand learning patterns, and recover from suboptimal states.</p><p><strong>Best used for:</strong> Cognitive debugging, pattern analysis, and state management.</p></div>"
                         data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-emerald-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="activity" class="w-6 h-6 text-emerald-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Cognitive Timeline</h3>
                                <p class="text-sm text-gray-400">State snapshots with diff views</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Pattern analysis & restoration</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-emerald-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('workflow-dependencies')"
                         data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-violet-400 mb-2'> Workflow Dependencies</h4><p>Gantt chart and network scheduling with critical path analysis and resource optimization.</p><p><strong>What it does:</strong> Maps workflow dependencies, identifies critical paths, and optimizes resource allocation across parallel tasks.</p><p><strong>Why it's useful:</strong> Optimize workflow scheduling, reduce bottlenecks, and improve overall system efficiency.</p><p><strong>Best used for:</strong> Project planning, resource optimization, and workflow scheduling.</p></div>"
                         data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-violet-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="git-merge" class="w-6 h-6 text-violet-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Workflow Dependencies</h3>
                                <p class="text-sm text-gray-400">Gantt chart + network scheduling</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Critical path & resource optimization</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-violet-400 transition-colors"></i>
                        </div>
                    </div>
             </div>

             <!-- Third row of navigation cards -->
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('action-monitor')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-orange-400 mb-2'> Action Monitor</h4><p>Real-time execution tracking and performance metrics with live monitoring capabilities.</p><p><strong>What it does:</strong> Shows currently running actions, queue status, performance metrics, and real-time system health.</p><p><strong>Why it's useful:</strong> Monitor system performance, identify bottlenecks, and track execution efficiency in real-time.</p><p><strong>Best used for:</strong> Live system monitoring, performance optimization, and operational oversight.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-orange-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="activity" class="w-6 h-6 text-orange-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Action Monitor</h3>
                             <p class="text-sm text-gray-400">Real-time execution tracking & metrics</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Live performance monitoring</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-orange-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('artifact-gallery')"
                      data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-pink-400 mb-2'> Artifact Gallery</h4><p>Pinterest-style visual artifact browsing with rich metadata and relationship mapping.</p><p><strong>What it does:</strong> Displays files, images, documents, and generated content in an intuitive visual gallery with search and filtering.</p><p><strong>Why it's useful:</strong> Quickly browse and manage generated artifacts, track creation workflows, and visualize artifact relationships.</p><p><strong>Best used for:</strong> Content management, artifact discovery, and visual workflow tracking.</p></div>"
                      data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-pink-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="image" class="w-6 h-6 text-pink-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Artifact Gallery</h3>
                             <p class="text-sm text-gray-400">Pinterest-style artifact browsing</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Visual artifact management</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-pink-400 transition-colors"></i>
                     </div>
                 </div>
                 
                                  <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('memory-quality')"
                     data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-red-400 mb-2'> Memory Quality Inspector</h4><p>Advanced memory analysis tool for identifying quality issues, duplicates, and optimization opportunities.</p><p><strong>What it does:</strong> Scans memories for duplicates, orphaned entries, quality issues, and provides automated cleanup suggestions with bulk operations.</p><p><strong>Why it's useful:</strong> Maintain high-quality memory systems, reduce redundancy, and optimize storage and retrieval performance.</p><p><strong>Best used for:</strong> Memory maintenance, quality assurance, duplicate cleanup, and system optimization.</p></div>"
                     data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-red-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="scan-line" class="w-6 h-6 text-red-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Memory Quality Inspector</h3>
                             <p class="text-sm text-gray-400">Quality analysis & cleanup automation</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Duplicate detection & bulk operations</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-red-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group dashboard-tooltip" @click="navigateTo('performance-profiler')"
                     data-tippy-content="<div class='tooltip-content'><h4 class='font-bold text-orange-400 mb-2'> Performance Profiler</h4><p>Comprehensive workflow performance analysis with bottleneck identification, flame graphs, and optimization recommendations.</p><p><strong>What it does:</strong> Analyzes execution timing, identifies bottlenecks, visualizes resource usage, tracks performance trends, and generates actionable optimization recommendations.</p><p><strong>Why it's useful:</strong> Optimize system performance, reduce execution times, identify parallelization opportunities, and improve overall efficiency.</p><p><strong>Best used for:</strong> Performance tuning, bottleneck analysis, resource optimization, and workflow improvement.</p></div>"
                     data-tippy-allowHTML="true" data-tippy-theme="custom" data-tippy-placement="top" data-tippy-delay="[500, 0]">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-orange-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="gauge" class="w-6 h-6 text-orange-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Performance Profiler</h3>
                             <p class="text-sm text-gray-400">Bottleneck analysis & optimization</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Flame graphs & smart recommendations</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-orange-400 transition-colors"></i>
                     </div>
                 </div>
             </div>

            <!-- Recent activity timeline -->
            <div class="enhanced-card rounded-2xl p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-xl font-semibold">Recent Activity</h3>
                    <button class="text-sm text-blue-400 hover:text-blue-300 transition-colors">View All</button>
                </div>
                <div class="space-y-4">
                    <template x-for="(item, index) in recentActivity.slice(0, 5)" :key="item.id">
                        <div class="flex items-center space-x-4 p-3 rounded-xl bg-white/5 hover:bg-white/10 transition-colors animate-fade-in"
                             :style="`animation-delay: ${index * 100}ms`">
                            <div class="w-10 h-10 rounded-xl bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center flex-shrink-0">
                                <i :data-lucide="item.icon" class="w-5 h-5"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="font-medium truncate" x-text="item.title"></p>
                                <p class="text-sm text-gray-400 truncate" x-text="item.description"></p>
                            </div>
                            <div class="text-sm text-gray-500" x-text="formatRelativeTime(item.timestamp)"></div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Workflows View -->
        <div x-show="dbLoaded && currentView === 'workflows'" class="animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Workflows</h2>
                    <p class="text-gray-400" x-text="`${filteredWorkflows.length} workflows found`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="workflowFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Status</option>
                        <option value="active">Active</option>
                        <option value="completed">Completed</option>
                        <option value="paused">Paused</option>
                        <option value="failed">Failed</option>
                    </select>
                    <button class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                        New Workflow
                    </button>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <template x-for="workflow in filteredWorkflows" :key="workflow.workflow_id">
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="selectWorkflow(workflow)">
                        <div class="flex items-start justify-between mb-4">
                            <h3 class="font-semibold text-lg group-hover:text-blue-400 transition-colors" x-text="workflow.title"></h3>
                            <div class="status-indicator">
                                <span class="px-2 py-1 text-xs rounded-full" 
                                      :class="getWorkflowStatusClass(workflow.status)" 
                                      x-text="workflow.status"></span>
                            </div>
                        </div>
                        <p class="text-gray-400 text-sm mb-4 line-clamp-2" x-text="workflow.description || workflow.goal"></p>
                        <div class="flex items-center justify-between text-sm text-gray-500">
                            <span x-text="formatRelativeTime(workflow.updated_at)"></span>
                            <div class="flex items-center space-x-4">
                                <span x-text="`${workflow.action_count || 0} actions`"></span>
                                <span x-text="`${workflow.memory_count || 0} memories`"></span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Memories View -->
        <div x-show="dbLoaded && currentView === 'memories'" class="animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Memory System</h2>
                    <p class="text-gray-400" x-text="`${filteredMemories.length} memories found`"></p>
                </div>
                                 <div class="flex items-center space-x-3">
                     <select x-model="memoryLevelFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Levels</option>
                         <option value="working">Working</option>
                         <option value="episodic">Episodic</option>
                         <option value="semantic">Semantic</option>
                         <option value="procedural">Procedural</option>
                     </select>
                     <select x-model="memorySortBy" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="created_at">Created Date</option>
                         <option value="importance">Importance</option>
                         <option value="confidence">Confidence</option>
                         <option value="access_count">Access Count</option>
                         <option value="memory_type">Type</option>
                     </select>
                     <button @click="memorySortOrder = memorySortOrder === 'desc' ? 'asc' : 'desc'" 
                             class="p-2 bg-white/10 border border-white/20 rounded-lg hover:bg-white/20 transition-colors">
                         <i :data-lucide="memorySortOrder === 'desc' ? 'arrow-down' : 'arrow-up'" class="w-4 h-4"></i>
                     </button>
                     <input type="text" 
                            x-model="memorySearch" 
                            placeholder="Search memories..." 
                            class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-64">
                 </div>
            </div>
            
                         <!-- Group memories by workflow -->
             <template x-for="group in groupedMemories" :key="group.workflowId">
                 <div class="mb-8">
                     <div class="flex items-center justify-between mb-4">
                         <h3 class="text-lg font-semibold flex items-center">
                             <i data-lucide="folder" class="w-5 h-5 mr-2 text-purple-400"></i>
                             <span x-text="group.workflowTitle || 'Standalone Memories'"></span>
                             <span class="ml-2 px-2 py-1 text-xs bg-purple-500/20 text-purple-400 rounded-full" x-text="`${group.memories.length} memories`"></span>
                         </h3>
                         <button @click="group.collapsed = !group.collapsed" 
                                 class="p-1 hover:bg-white/10 rounded transition-colors">
                             <i :data-lucide="group.collapsed ? 'chevron-right' : 'chevron-down'" class="w-4 h-4"></i>
                         </button>
                     </div>
                     
                     <div x-show="!group.collapsed" 
                          x-transition:enter="transition ease-out duration-200" 
                          x-transition:enter-start="opacity-0 transform scale-95" 
                          x-transition:enter-end="opacity-100 transform scale-100">
                         <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                             <template x-for="memory in group.memories" :key="memory.memory_id">
                                 <div class="enhanced-card rounded-xl p-4 cursor-pointer group memory-card transition-all duration-300" 
                                      :class="`memory-${memory.memory_level}`"
                                      @click="selectMemory(memory)"
                                      style="transform: translateY(0); transition: transform 0.3s ease;">
                                     <div class="flex items-start justify-between mb-3">
                                         <div class="flex items-center space-x-2">
                                             <span class="px-2 py-1 text-xs rounded-full" 
                                                   :class="getMemoryLevelClass(memory.memory_level)" 
                                                   x-text="memory.memory_level"></span>
                                             <span class="text-xs text-gray-500" x-text="memory.memory_type"></span>
                                         </div>
                                         <div class="flex items-center space-x-2 text-xs text-gray-500">
                                             <span x-text="`I: ${memory.importance}/10`"></span>
                                             <span x-text="`C: ${Math.round((memory.confidence || 0) * 100)}%`"></span>
                                         </div>
                                     </div>
                                     <p class="text-gray-300 text-sm mb-3 line-clamp-3" x-text="memory.content"></p>
                                     <div class="flex items-center justify-between text-sm text-gray-500">
                                         <span x-text="formatRelativeTime(memory.created_at)"></span>
                                         <div class="flex items-center space-x-2">
                                             <i data-lucide="eye" class="w-4 h-4"></i>
                                             <span x-text="memory.access_count || 0"></span>
                                         </div>
                                     </div>
                                 </div>
                             </template>
                         </div>
                     </div>
                 </div>
             </template>
             
             <!-- Show ungrouped view if no grouping -->
             <div x-show="!groupedMemories.length" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                 <template x-for="memory in filteredMemories.slice(0, currentPage * pageSize)" :key="memory.memory_id">
                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group memory-card" 
                          :class="`memory-${memory.memory_level}`"
                          @click="selectMemory(memory)">
                         <div class="flex items-start justify-between mb-4">
                             <div class="flex items-center space-x-2">
                                 <span class="px-2 py-1 text-xs rounded-full" 
                                       :class="getMemoryLevelClass(memory.memory_level)" 
                                       x-text="memory.memory_level"></span>
                                 <span class="text-xs text-gray-500" x-text="memory.memory_type"></span>
                             </div>
                             <div class="flex items-center space-x-2 text-xs text-gray-500">
                                 <span x-text="`I: ${memory.importance}/10`"></span>
                                 <span x-text="`C: ${Math.round((memory.confidence || 0) * 100)}%`"></span>
                             </div>
                         </div>
                         <p class="text-gray-300 text-sm mb-4 line-clamp-3" x-text="memory.content"></p>
                         <div class="flex items-center justify-between text-sm text-gray-500">
                             <span x-text="formatRelativeTime(memory.created_at)"></span>
                             <div class="flex items-center space-x-2">
                                 <i data-lucide="eye" class="w-4 h-4"></i>
                                 <span x-text="memory.access_count || 0"></span>
                             </div>
                         </div>
                     </div>
                 </template>
             </div>
            
            <!-- Load more button -->
            <div x-show="filteredMemories.length > currentPage * pageSize" class="text-center mt-8">
                <button @click="loadMore()" 
                        class="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition-colors interactive">
                    Load More Memories
                </button>
            </div>
                 </div>

         <!-- Actions View -->
         <div x-show="dbLoaded && currentView === 'actions'" class="animate-slide-in">
             <div class="flex items-center justify-between mb-6">
                 <div>
                     <h2 class="text-2xl font-bold">Actions</h2>
                     <p class="text-gray-400" x-text="`${filteredActions.length} actions found`"></p>
                 </div>
                 <div class="flex items-center space-x-3">
                     <select x-model="actionStatusFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Status</option>
                         <option value="completed">Completed</option>
                         <option value="in_progress">In Progress</option>
                         <option value="failed">Failed</option>
                         <option value="planned">Planned</option>
                     </select>
                     <select x-model="actionTypeFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Types</option>
                         <option value="tool_use">Tool Use</option>
                         <option value="reasoning">Reasoning</option>
                         <option value="planning">Planning</option>
                         <option value="analysis">Analysis</option>
                         <option value="research">Research</option>
                     </select>
                     <input type="text" 
                            x-model="actionSearch" 
                            placeholder="Search actions..." 
                            class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-64">
                 </div>
             </div>
             
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                 <template x-for="action in filteredActions.slice(0, currentPage * pageSize)" :key="action.action_id">
                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="selectAction(action)">
                         <div class="flex items-start justify-between mb-4">
                             <div class="flex items-center space-x-2">
                                 <span class="px-2 py-1 text-xs rounded-full" 
                                       :class="getActionStatusClass(action.status)" 
                                       x-text="action.status"></span>
                                 <span class="text-xs text-gray-500" x-text="action.action_type"></span>
                             </div>
                             <div class="text-xs text-gray-500" x-text="formatDuration(action.started_at, action.completed_at)"></div>
                         </div>
                         <h3 class="font-medium mb-2 group-hover:text-orange-400 transition-colors" x-text="action.title || action.tool_name || action.action_type"></h3>
                         <p class="text-gray-400 text-sm mb-4 line-clamp-2" x-text="action.reasoning || action.summary || 'No description available'"></p>
                         <div class="flex items-center justify-between text-sm text-gray-500">
                             <span x-text="formatRelativeTime(action.started_at)"></span>
                             <div class="flex items-center space-x-2">
                                 <i :data-lucide="getActionIcon(action.action_type)" class="w-4 h-4"></i>
                                 <span x-text="action.workflow_id ? 'Workflow' : 'Standalone'"></span>
                             </div>
                         </div>
                     </div>
                 </template>
             </div>
             
             <!-- Load more button -->
             <div x-show="filteredActions.length > currentPage * pageSize" class="text-center mt-8">
                 <button @click="loadMore()" 
                         class="px-6 py-3 bg-orange-600 hover:bg-orange-700 rounded-lg font-medium transition-colors interactive">
                     Load More Actions
                 </button>
             </div>
         </div>

         <!-- Analytics View -->
        <div x-show="dbLoaded && currentView === 'analytics'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Analytics Dashboard</h2>
                    <p class="text-gray-400">Visualize your UMS data patterns</p>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="chart-container" style="min-height: 320px; max-height: 400px; overflow: hidden;">
                    <h3 class="text-lg font-semibold mb-4">Memory Level Distribution</h3>
                    <div style="position: relative; height: 256px; width: 100%;">
                        <canvas x-ref="memoryLevelChart" class="w-full h-64" style="max-height: 256px !important;"></canvas>
                    </div>
                </div>
                
                <div class="chart-container" style="min-height: 320px; max-height: 400px; overflow: hidden;">
                    <h3 class="text-lg font-semibold mb-4">Memory Type Breakdown</h3>
                    <div style="position: relative; height: 256px; width: 100%;">
                        <canvas x-ref="memoryTypeChart" class="w-full h-64" style="max-height: 256px !important;"></canvas>
                    </div>
                </div>
                
                <div class="chart-container" style="min-height: 320px; max-height: 400px; overflow: hidden;">
                    <h3 class="text-lg font-semibold mb-4">Workflow Status</h3>
                    <div style="position: relative; height: 256px; width: 100%;">
                        <canvas x-ref="workflowStatusChart" class="w-full h-64" style="max-height: 256px !important;"></canvas>
                    </div>
                </div>
                
                <div class="chart-container" style="min-height: 320px; max-height: 400px; overflow: hidden;">
                    <h3 class="text-lg font-semibold mb-4">Activity Timeline</h3>
                    <div style="position: relative; height: 256px; width: 100%;">
                        <canvas x-ref="activityChart" class="w-full h-64" style="max-height: 256px !important;"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Graph View -->
        <div x-show="dbLoaded && currentView === 'graph'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Memory Network Graph</h2>
                    <p class="text-gray-400" x-text="`${graphData.nodes?.length || 0} memories  ${graphData.links?.length || 0} connections`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="graphSettings.layout" @change="updateGraphLayout()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="force">Force Layout</option>
                        <option value="hierarchical">Hierarchical</option>
                        <option value="circular">Circular</option>
                        <option value="cluster">Clustered</option>
                    </select>
                    <select x-model="graphSettings.colorBy" @change="updateGraphColors()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="memory_level">Memory Level</option>
                        <option value="memory_type">Memory Type</option>
                        <option value="workflow">Workflow</option>
                        <option value="importance">Importance</option>
                    </select>
                    <button @click="resetGraphView()" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline"></i>
                        Reset View
                    </button>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Graph Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="graph-container" style="height: 70vh;">
                        <!-- Graph Controls -->
                        <div class="graph-controls">
                            <div class="enhanced-card p-3 space-y-2">
                                <div class="text-xs text-gray-400 mb-2">Physics</div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-gray-300">Strength:</label>
                                    <input type="range" x-model.number="graphSettings.forceStrength" @input="updatePhysics()" 
                                           min="-100" max="100" step="10" class="w-16 h-1 bg-gray-600 rounded-lg appearance-none slider">
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-gray-300">Distance:</label>
                                    <input type="range" x-model.number="graphSettings.linkDistance" @input="updatePhysics()" 
                                           min="10" max="200" step="10" class="w-16 h-1 bg-gray-600 rounded-lg appearance-none slider">
                                </div>
                                <button @click="togglePhysics()" class="w-full px-2 py-1 text-xs rounded bg-blue-600 hover:bg-blue-700 transition-colors"
                                        :class="{'bg-red-600 hover:bg-red-700': !graphSettings.physicsEnabled}">
                                    <span x-text="graphSettings.physicsEnabled ? 'Pause' : 'Resume'"></span>
                                </button>
                            </div>
                            
                            <div class="enhanced-card p-3 space-y-2">
                                <div class="text-xs text-gray-400 mb-2">Filters</div>
                                <div class="space-y-1">
                                    <template x-for="level in ['working', 'episodic', 'semantic', 'procedural']" :key="level">
                                        <label class="flex items-center text-xs">
                                            <input type="checkbox" :checked="graphSettings.visibleLevels.includes(level)" 
                                                   @change="toggleMemoryLevel(level)" class="mr-1 rounded">
                                            <span class="capitalize" x-text="level"></span>
                                        </label>
                                    </template>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Graph Legend -->
                        <div x-show="graphSettings.showLegend" class="graph-legend">
                            <div class="text-sm font-semibold mb-3">Legend</div>
                            <template x-for="item in currentLegend" :key="item.key">
                                <div class="legend-item">
                                    <div class="legend-color" :style="`background-color: ${item.color}`"></div>
                                    <span x-text="item.label"></span>
                                </div>
                            </template>
                            <div class="mt-3 pt-3 border-t border-white/20">
                                <div class="text-xs text-gray-400 mb-2">Link Types</div>
                                <div class="text-xs space-y-1">
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-blue-400 mr-2"></div>
                                        <span>References</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-green-400 mr-2"></div>
                                        <span>Causal</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-purple-400 mr-2"></div>
                                        <span>Similarity</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-cyan-400 mr-2"></div>
                                        <span>Workflow</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-violet-400 mr-2"></div>
                                        <span>Type Similar</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Main Graph SVG -->
                        <svg x-ref="graphSvg" class="graph-svg"></svg>
                        
                        <!-- Graph Tooltip -->
                        <div x-show="graphTooltip.visible" 
                             x-transition:enter="transition ease-out duration-200" 
                             x-transition:enter-start="opacity-0 scale-95" 
                             x-transition:enter-end="opacity-100 scale-100"
                             class="graph-tooltip"
                             :style="`left: ${graphTooltip.x}px; top: ${graphTooltip.y}px;`">
                            <div class="font-semibold mb-1" x-text="graphTooltip.title"></div>
                            <div class="text-xs text-gray-300 mb-2" x-text="graphTooltip.subtitle"></div>
                            <div class="text-sm" x-text="graphTooltip.content"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="graph-sidebar">
                        <div x-show="!selectedGraphNode" class="text-center text-gray-400">
                            <i data-lucide="mouse-pointer-click" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <p class="text-sm">Click on a memory node to view details and explore connections</p>
                            
                            <div class="mt-6 p-4 bg-white/5 rounded-lg">
                                <h4 class="font-semibold mb-3">Graph Stats</h4>
                                <div class="space-y-2 text-sm">
                                    <div class="flex justify-between">
                                        <span>Nodes:</span>
                                        <span x-text="graphData.nodes?.length || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Links:</span>
                                        <span x-text="graphData.links?.length || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Clusters:</span>
                                        <span x-text="graphClusters.length"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Density:</span>
                                        <span x-text="calculateGraphDensity()"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div x-show="selectedGraphNode" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Memory Details</h4>
                                <button @click="selectedGraphNode = null" class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="selectedGraphNode" class="space-y-3">
                                <div>
                                    <div class="text-xs text-gray-400 mb-1">Type & Level</div>
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getMemoryLevelClass(selectedGraphNode?.memory_level)" 
                                              x-text="selectedGraphNode?.memory_level"></span>
                                        <span class="text-sm text-gray-300" x-text="selectedGraphNode?.memory_type"></span>
                                    </div>
                                </div>
                                
                                <div>
                                    <div class="text-xs text-gray-400 mb-1">Content</div>
                                    <div class="text-sm bg-white/5 p-3 rounded-lg max-h-32 overflow-y-auto">
                                        <p x-text="selectedGraphNode?.content"></p>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <div class="text-xs text-gray-400">Importance</div>
                                        <div class="text-lg font-semibold" x-text="selectedGraphNode?.importance + '/10'"></div>
                                    </div>
                                    <div>
                                        <div class="text-xs text-gray-400">Confidence</div>
                                        <div class="text-lg font-semibold" x-text="Math.round((selectedGraphNode?.confidence || 0) * 100) + '%'"></div>
                                    </div>
                                </div>
                                
                                <div>
                                    <div class="text-xs text-gray-400 mb-2">Connections</div>
                                    <div class="space-y-2 max-h-40 overflow-y-auto">
                                        <template x-for="connection in getNodeConnections(selectedGraphNode)" :key="connection.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg hover:bg-white/10 transition-colors cursor-pointer"
                                                 @click="focusOnNode(connection.target)">
                                                <div class="flex-1 min-w-0">
                                                    <div class="text-sm font-medium truncate" x-text="connection.target.memory_type"></div>
                                                    <div class="text-xs text-gray-400 truncate" x-text="connection.target.content.substring(0, 30) + '...'"></div>
                                                </div>
                                                <div class="text-xs text-gray-500" x-text="connection.link_type"></div>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div class="flex space-x-2">
                                    <button @click="selectMemory(selectedGraphNode); showMemoryModal = true" 
                                            class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                                        View Details
                                    </button>
                                    <button @click="expandNeighborhood(selectedGraphNode)" 
                                            class="flex-1 px-3 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-sm font-medium transition-colors">
                                        Expand
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Goals View -->
        <div x-show="dbLoaded && currentView === 'goals'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Goal Hierarchy</h2>
                    <p class="text-gray-400" x-text="`${goalStats.total} goals  ${goalStats.completionRate}% completion rate`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="goalFilter" @change="filterGoals()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Goals</option>
                        <option value="active">Active</option>
                        <option value="completed">Completed</option>
                        <option value="pending">Pending</option>
                        <option value="overdue">Overdue</option>
                    </select>
                    <select x-model="goalTreeSettings.groupBy" @change="rebuildGoalTree()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="none">No Grouping</option>
                        <option value="priority">By Priority</option>
                        <option value="status">By Status</option>
                        <option value="owner">By Owner</option>
                    </select>
                    <button @click="expandAllGoals()" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="expand" class="w-4 h-4 mr-2 inline"></i>
                        Expand All
                    </button>
                    <button @click="showNewGoalModal()" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                        New Goal
                    </button>
                </div>
            </div>
            
            <!-- Goal Statistics -->
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-yellow-400" x-text="goalStats.total"></div>
                    <div class="text-xs text-gray-400">Total Goals</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-green-400" x-text="goalStats.completed"></div>
                    <div class="text-xs text-gray-400">Completed</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="goalStats.inProgress"></div>
                    <div class="text-xs text-gray-400">In Progress</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-gray-400" x-text="goalStats.pending"></div>
                    <div class="text-xs text-gray-400">Pending</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="goalStats.overdue"></div>
                    <div class="text-xs text-gray-400">Overdue</div>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Goal Tree Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <!-- Tree Controls -->
                        <div class="flex items-center justify-between mb-6">
                            <div class="flex items-center space-x-4">
                                <div class="flex items-center space-x-2">
                                    <label class="text-sm text-gray-400">Show:</label>
                                    <label class="flex items-center text-sm">
                                        <input type="checkbox" x-model="goalTreeSettings.showCompleted" @change="rebuildGoalTree()" class="mr-1 rounded">
                                        <span>Completed</span>
                                    </label>
                                    <label class="flex items-center text-sm">
                                        <input type="checkbox" x-model="goalTreeSettings.showProgress" @change="rebuildGoalTree()" class="mr-1 rounded">
                                        <span>Progress</span>
                                    </label>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-sm text-gray-400">Sort:</label>
                                    <select x-model="goalTreeSettings.sortBy" @change="rebuildGoalTree()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                                        <option value="created">Created Date</option>
                                        <option value="priority">Priority</option>
                                        <option value="progress">Progress</option>
                                        <option value="title">Title</option>
                                    </select>
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="text" 
                                       x-model="goalSearch" 
                                       @input="filterGoals()"
                                       placeholder="Search goals..." 
                                       class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-48">
                                <button @click="collapseAllGoals()" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="minimize-2" class="w-4 h-4"></i>
                                </button>
                                <button @click="resetGoalTreeView()" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Goal Tree SVG Container -->
                        <div class="relative" style="height: calc(70vh - 8rem);">
                            <svg x-ref="goalTreeSvg" class="w-full h-full cursor-grab" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            
                            <!-- Tree Legend -->
                            <div class="absolute top-4 right-4 bg-black/80 backdrop-blur-lg rounded-lg p-3 min-w-[200px]">
                                <div class="text-sm font-semibold mb-3 text-white">Goal Status</div>
                                <div class="space-y-2 text-xs">
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-green-400 mr-2"></div>
                                        <span class="text-white">Completed</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-blue-400 mr-2"></div>
                                        <span class="text-white">In Progress</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                                        <span class="text-white">Pending</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-red-400 mr-2"></div>
                                        <span class="text-white">Overdue</span>
                                    </div>
                                </div>
                                <div class="mt-3 pt-3 border-t border-white/20">
                                    <div class="text-sm font-semibold mb-2 text-white">Priority</div>
                                    <div class="space-y-1 text-xs">
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                                            <span class="text-white">High</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                                            <span class="text-white">Medium</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                                            <span class="text-white">Low</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Drop Zones for Drag & Drop -->
                            <div x-show="isDragging" class="absolute inset-0 pointer-events-none">
                                <div class="absolute top-4 left-4 w-48 h-16 border-2 border-dashed border-yellow-400 rounded-lg bg-yellow-400/10 flex items-center justify-center pointer-events-auto"
                                     @drop.prevent="handleGoalDrop($event, 'root')"
                                     @dragover.prevent="highlightDropZone($event, 'root')"
                                     @dragleave.prevent="unhighlightDropZone($event)">
                                    <span class="text-yellow-400 text-sm font-medium">Make Root Goal</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Goal Details Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="enhanced-card rounded-2xl p-6 sticky top-24" style="max-height: calc(100vh - 8rem); overflow-y: auto;">
                        <div x-show="!selectedGoal" class="text-center text-gray-400">
                            <i data-lucide="target" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <h4 class="font-semibold mb-2">No Goal Selected</h4>
                            <p class="text-sm">Click on a goal in the tree to view details and manage dependencies</p>
                            
                            <div class="mt-6 space-y-3">
                                <button @click="showNewGoalModal()" class="w-full px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                                    Create New Goal
                                </button>
                                <button @click="importGoalsFromMemories()" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                                    Import from Memories
                                </button>
                            </div>
                        </div>
                        
                        <div x-show="selectedGoal" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Goal Details</h4>
                                <div class="flex items-center space-x-2">
                                    <button @click="editGoal(selectedGoal)" class="p-1 hover:bg-white/10 rounded transition-colors">
                                        <i data-lucide="edit-2" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="selectedGoal = null" class="p-1 hover:bg-white/10 rounded transition-colors">
                                        <i data-lucide="x" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <div x-show="selectedGoal" class="space-y-4">
                                <div>
                                    <h5 class="font-medium mb-2" x-text="selectedGoal?.title"></h5>
                                    <p class="text-sm text-gray-300 mb-3" x-text="selectedGoal?.description"></p>
                                    
                                    <div class="grid grid-cols-2 gap-3 text-sm">
                                        <div>
                                            <span class="text-gray-400">Status:</span>
                                            <div class="mt-1">
                                                <span class="px-2 py-1 text-xs rounded-full" 
                                                      :class="getGoalStatusClass(selectedGoal?.status)" 
                                                      x-text="selectedGoal?.status"></span>
                                            </div>
                                        </div>
                                        <div>
                                            <span class="text-gray-400">Priority:</span>
                                            <div class="mt-1">
                                                <span class="px-2 py-1 text-xs rounded-full" 
                                                      :class="getGoalPriorityClass(selectedGoal?.priority)" 
                                                      x-text="selectedGoal?.priority"></span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div x-show="selectedGoal?.progress !== undefined" class="mt-3">
                                        <div class="flex items-center justify-between text-sm mb-1">
                                            <span class="text-gray-400">Progress</span>
                                            <span x-text="`${selectedGoal?.progress || 0}%`"></span>
                                        </div>
                                        <div class="w-full bg-gray-700 rounded-full h-2">
                                            <div class="bg-yellow-400 h-2 rounded-full transition-all duration-300" 
                                                 :style="`width: ${selectedGoal?.progress || 0}%`"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div x-show="selectedGoal?.due_date">
                                    <span class="text-gray-400 text-sm">Due Date:</span>
                                    <div class="text-sm" x-text="formatDate(selectedGoal?.due_date)"></div>
                                </div>
                                
                                <div x-show="selectedGoal?.dependencies?.length > 0">
                                    <h6 class="font-medium mb-2">Dependencies</h6>
                                    <div class="space-y-2 max-h-24 overflow-y-auto">
                                        <template x-for="dep in selectedGoal?.dependencies" :key="dep.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg text-sm">
                                                <span x-text="dep.title"></span>
                                                <span class="text-xs" :class="getGoalStatusClass(dep.status)" x-text="dep.status"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div x-show="selectedGoal?.subgoals?.length > 0">
                                    <h6 class="font-medium mb-2">Subgoals</h6>
                                    <div class="space-y-2 max-h-32 overflow-y-auto">
                                        <template x-for="subgoal in selectedGoal?.subgoals" :key="subgoal.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg text-sm cursor-pointer hover:bg-white/10 transition-colors"
                                                 @click="selectGoal(subgoal)">
                                                <span x-text="subgoal.title"></span>
                                                <span class="text-xs" :class="getGoalStatusClass(subgoal.status)" x-text="subgoal.status"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div class="space-y-2 pt-4 border-t border-white/10">
                                    <button @click="addSubgoal(selectedGoal)" class="w-full px-3 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                                        Add Subgoal
                                    </button>
                                    <button @click="markGoalComplete(selectedGoal)" 
                                            x-show="selectedGoal?.status !== 'completed'"
                                            class="w-full px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="check" class="w-4 h-4 mr-2 inline"></i>
                                        Mark Complete
                                    </button>
                                    <button @click="deleteGoal(selectedGoal)" class="w-full px-3 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="trash-2" class="w-4 h-4 mr-2 inline"></i>
                                        Delete Goal
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Thought Chains View -->
        <div x-show="dbLoaded && currentView === 'thought-chains'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Thought Chain Flow Diagrams</h2>
                    <p class="text-gray-400" x-text="`${thoughtChainStats.totalChains} chains  ${thoughtChainStats.totalThoughts} thoughts  ${thoughtChainStats.branchingPoints} branches`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="chainFilter" @change="filterThoughtChains()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Chains</option>
                        <option value="workflow">By Workflow</option>
                        <option value="recent">Recent Only</option>
                        <option value="complex">Complex (5+ thoughts)</option>
                        <option value="branching">With Branches</option>
                    </select>
                    <button @click="resetThoughtChainView()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline"></i>
                        Reset View
                    </button>
                    <button @click="exportThoughtChain()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                        Export
                    </button>
                </div>
            </div>
            
            <!-- Chain Statistics -->
            <div class="chain-stats">
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.totalChains"></div>
                    <div class="chain-stat-label">Total Chains</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.totalThoughts"></div>
                    <div class="chain-stat-label">Total Thoughts</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.avgChainLength.toFixed(1)"></div>
                    <div class="chain-stat-label">Avg Chain Length</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.branchingPoints"></div>
                    <div class="chain-stat-label">Branching Points</div>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Main Diagram Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="thought-chain-container">
                        <!-- Diagram Area -->
                        <div x-show="currentChain" class="mermaid-container">
                            <div x-ref="mermaidContainer" class="w-full h-full"></div>
                        </div>
                        
                        <!-- Empty State -->
                        <div x-show="!currentChain" class="flex items-center justify-center h-full">
                            <div class="text-center text-gray-400">
                                <i data-lucide="git-branch-plus" class="w-16 h-16 mx-auto mb-4 opacity-50"></i>
                                <h3 class="text-xl font-semibold mb-2">No Thought Chain Selected</h3>
                                <p class="text-sm">Select a thought chain from the sidebar to view its flow diagram</p>
                            </div>
                        </div>
                        
                        <!-- Timeline Scrubber -->
                        <div x-show="currentChain" class="timeline-scrubber">
                            <!-- Playback Controls -->
                            <div class="playback-controls">
                                <button @click="stepBackward()" class="playback-btn secondary" title="Previous Step">
                                    <i data-lucide="skip-back" class="w-5 h-5"></i>
                                </button>
                                <button @click="togglePlayback()" class="playback-btn" :title="isPlaybackActive ? 'Pause' : 'Play'">
                                    <i :data-lucide="isPlaybackActive ? 'pause' : 'play'" class="w-6 h-6"></i>
                                </button>
                                <button @click="stepForward()" class="playback-btn secondary" title="Next Step">
                                    <i data-lucide="skip-forward" class="w-5 h-5"></i>
                                </button>
                                
                                <!-- Speed Control -->
                                <div class="speed-control">
                                    <span class="text-xs text-gray-400">Speed:</span>
                                    <button @click="setPlaybackSpeed(0.5)" 
                                            :class="{'active': playbackSpeed === 0.5}" 
                                            class="speed-btn">0.5x</button>
                                    <button @click="setPlaybackSpeed(1)" 
                                            :class="{'active': playbackSpeed === 1}" 
                                            class="speed-btn">1x</button>
                                    <button @click="setPlaybackSpeed(2)" 
                                            :class="{'active': playbackSpeed === 2}" 
                                            class="speed-btn">2x</button>
                                    <button @click="setPlaybackSpeed(3)" 
                                            :class="{'active': playbackSpeed === 3}" 
                                            class="speed-btn">3x</button>
                                </div>
                            </div>
                            
                            <!-- Timeline Markers -->
                            <div class="timeline-markers">
                                <template x-for="(thought, index) in thoughtsInCurrentChain" :key="thought.memory_id">
                                    <div class="timeline-marker" 
                                         :class="{
                                             'current': index === currentThoughtIndex,
                                             'major': thought.hasChildren || thought.isBranch
                                         }"
                                         :style="`left: ${(index / (thoughtsInCurrentChain.length - 1)) * 100}%`"
                                         @click="jumpToThought(index)"
                                         :title="`${thought.memory_type} - ${thought.content.substring(0, 50)}...`">
                                    </div>
                                </template>
                            </div>
                            
                            <!-- Timeline Slider -->
                            <input type="range" 
                                   x-model.number="thoughtTimelinePosition" 
                                   @input="seekToPosition($event.target.value)"
                                   :min="0" 
                                   :max="thoughtTimelineLength - 1" 
                                   :step="1"
                                   class="timeline-slider">
                            
                            <!-- Timeline Info -->
                            <div class="flex items-center justify-between mt-3 text-sm text-gray-400">
                                <div>
                                    <span x-text="`Step ${currentThoughtIndex + 1} of ${thoughtsInCurrentChain.length}`"></span>
                                    <span x-show="thoughtsInCurrentChain[currentThoughtIndex]" 
                                          class="ml-2" 
                                          x-text="`${thoughtsInCurrentChain[currentThoughtIndex]?.memory_type}`"></span>
                                </div>
                                <div x-show="thoughtsInCurrentChain[currentThoughtIndex]">
                                    <span x-text="formatDate(thoughtsInCurrentChain[currentThoughtIndex]?.created_at)"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="chain-sidebar">
                        <!-- Chain List -->
                        <div x-show="!currentChain" class="space-y-4">
                            <h4 class="font-semibold flex items-center">
                                <i data-lucide="list" class="w-4 h-4 mr-2"></i>
                                Available Chains
                            </h4>
                            
                            <div class="space-y-2 max-h-80 overflow-y-auto">
                                <template x-for="chain in thoughtChains" :key="chain.id">
                                    <div class="p-3 bg-white/5 rounded-lg hover:bg-white/10 transition-colors cursor-pointer group"
                                         @click="selectThoughtChain(chain)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-sm font-medium text-indigo-400" x-text="chain.title"></span>
                                            <span class="text-xs text-gray-500" x-text="`${chain.thoughts.length} thoughts`"></span>
                                        </div>
                                        <p class="text-xs text-gray-400 line-clamp-2" x-text="chain.description"></p>
                                        <div class="flex items-center justify-between mt-2 text-xs text-gray-500">
                                            <span x-text="formatRelativeTime(chain.created_at)"></span>
                                            <div class="flex items-center space-x-2">
                                                <span x-show="chain.hasBranches" title="Has branches">
                                                    <i data-lucide="git-branch" class="w-3 h-3"></i>
                                                </span>
                                                <span x-text="chain.complexity" :class="{
                                                    'text-green-400': chain.complexity === 'Simple',
                                                    'text-yellow-400': chain.complexity === 'Medium',
                                                    'text-red-400': chain.complexity === 'Complex'
                                                }"></span>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                        
                        <!-- Current Chain Details -->
                        <div x-show="currentChain" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Chain Details</h4>
                                <button @click="currentChain = null; stopPlayback()" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div class="chain-metadata">
                                <h5 class="font-medium mb-2" x-text="currentChain?.title"></h5>
                                <p class="text-sm text-gray-300 mb-3" x-text="currentChain?.description"></p>
                                
                                <div class="grid grid-cols-2 gap-2 text-xs">
                                    <div>
                                        <span class="text-gray-400">Thoughts:</span>
                                        <span x-text="currentChain?.thoughts.length"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Duration:</span>
                                        <span x-text="calculateChainDuration(currentChain)"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Branches:</span>
                                        <span x-text="currentChain?.branchCount || 0"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Complexity:</span>
                                        <span x-text="currentChain?.complexity" :class="{
                                            'text-green-400': currentChain?.complexity === 'Simple',
                                            'text-yellow-400': currentChain?.complexity === 'Medium',
                                            'text-red-400': currentChain?.complexity === 'Complex'
                                        }"></span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Current Thought Details -->
                            <div x-show="thoughtsInCurrentChain[currentThoughtIndex]" class="thought-details">
                                <h6 class="font-medium mb-2">Current Thought</h6>
                                <div class="space-y-2">
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full bg-indigo-500/20 text-indigo-400">
                                            <span x-text="thoughtsInCurrentChain[currentThoughtIndex]?.memory_type"></span>
                                        </span>
                                        <span class="text-xs text-gray-500" 
                                              x-text="`${currentThoughtIndex + 1}/${thoughtsInCurrentChain.length}`"></span>
                                    </div>
                                    <p class="text-sm" x-text="thoughtsInCurrentChain[currentThoughtIndex]?.content"></p>
                                    
                                    <div x-show="thoughtsInCurrentChain[currentThoughtIndex]?.hasChildren" 
                                         class="branch-indicator">
                                        <span class="text-xs text-purple-400">Branching Point</span>
                                    </div>
                                </div>
                                
                                <button @click="selectThought(thoughtsInCurrentChain[currentThoughtIndex]); showThoughtModal = true" 
                                        class="w-full mt-3 px-3 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium transition-colors">
                                    View Full Details
                                </button>
                            </div>
                            
                            <!-- Chain Navigation -->
                            <div class="space-y-2">
                                <h6 class="font-medium text-sm">Quick Navigation</h6>
                                <div class="grid grid-cols-2 gap-2">
                                    <button @click="jumpToFirstBranch()" 
                                            class="px-2 py-1 text-xs bg-purple-600/20 text-purple-400 rounded hover:bg-purple-600/30 transition-colors">
                                        First Branch
                                    </button>
                                    <button @click="jumpToLastThought()" 
                                            class="px-2 py-1 text-xs bg-blue-600/20 text-blue-400 rounded hover:bg-blue-600/30 transition-colors">
                                        Last Thought
                                    </button>
                                    <button @click="jumpToKeyDecision()" 
                                            class="px-2 py-1 text-xs bg-green-600/20 text-green-400 rounded hover:bg-green-600/30 transition-colors">
                                        Key Decision
                                    </button>
                                    <button @click="jumpToConclusion()" 
                                            class="px-2 py-1 text-xs bg-orange-600/20 text-orange-400 rounded hover:bg-orange-600/30 transition-colors">
                                        Conclusion
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Semantic Search View -->
        <div x-show="dbLoaded && currentView === 'semantic-search'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Semantic Search</h2>
                    <p class="text-gray-400">Advanced UMS-powered search with vector similarity and intelligent clustering</p>
                </div>
                <div class="flex items-center space-x-3">
                    <button @click="clearSemanticSearch()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="x" class="w-4 h-4 mr-2 inline"></i>
                        Clear
                    </button>
                    <button @click="saveCurrentSearch()" class="px-4 py-2 bg-rose-600 hover:bg-rose-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="bookmark" class="w-4 h-4 mr-2 inline"></i>
                        Save Search
                    </button>
                </div>
            </div>
            
            <!-- Search Interface -->
            <div class="enhanced-card rounded-2xl p-6">
                <div class="space-y-4">
                    <!-- Main Search Bar -->
                    <div class="relative">
                        <input type="text" 
                               x-model="semanticQuery" 
                               @input="debounceSemanticSearch()"
                               @keydown.enter="performSemanticSearch()"
                               placeholder="Ask a question or describe what you're looking for..." 
                               class="w-full pl-12 pr-20 py-4 bg-white/10 border border-white/20 rounded-xl text-lg focus:outline-none focus:border-rose-400 transition-colors">
                        <i data-lucide="search" class="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400"></i>
                        <button @click="performSemanticSearch()" 
                                :disabled="!semanticQuery || isSearching"
                                class="absolute right-2 top-1/2 transform -translate-y-1/2 px-4 py-2 bg-rose-600 hover:bg-rose-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                            <span x-show="!isSearching">Search</span>
                            <span x-show="isSearching" class="flex items-center">
                                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
                                Searching...
                            </span>
                        </button>
                    </div>
                    
                    <!-- Search Mode Tabs -->
                    <div class="flex space-x-2">
                        <button @click="searchMode = 'hybrid'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'hybrid', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'hybrid'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="brain" class="w-4 h-4 mr-2 inline"></i>
                            Hybrid Search
                        </button>
                        <button @click="searchMode = 'semantic'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'semantic', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'semantic'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                            Pure Semantic
                        </button>
                        <button @click="searchMode = 'structured'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'structured', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'structured'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="filter" class="w-4 h-4 mr-2 inline"></i>
                            Structured Query
                        </button>
                    </div>
                    
                    <!-- Advanced Options -->
                    <div x-show="showAdvancedOptions" 
                         x-transition:enter="transition ease-out duration-200" 
                         x-transition:enter-start="opacity-0 max-h-0" 
                         x-transition:enter-end="opacity-100 max-h-96"
                         class="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-white/5 rounded-xl overflow-hidden">
                        <div>
                            <label class="block text-sm font-medium mb-2">Memory Level</label>
                            <select x-model="searchFilters.memoryLevel" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                <option value="">All Levels</option>
                                <option value="working">Working</option>
                                <option value="episodic">Episodic</option>
                                <option value="semantic">Semantic</option>
                                <option value="procedural">Procedural</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Memory Type</label>
                            <select x-model="searchFilters.memoryType" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                <option value="">All Types</option>
                                <option value="thought">Thought</option>
                                <option value="plan">Plan</option>
                                <option value="goal">Goal</option>
                                <option value="insight">Insight</option>
                                <option value="observation">Observation</option>
                            </select>
                        </div>
                        <div x-show="searchMode === 'hybrid'">
                            <label class="block text-sm font-medium mb-2">Search Balance</label>
                            <div class="space-y-2">
                                <div class="flex items-center justify-between text-sm">
                                    <span>Semantic: <span x-text="Math.round(searchFilters.semanticWeight * 100)">60</span>%</span>
                                    <span>Keyword: <span x-text="Math.round(searchFilters.keywordWeight * 100)">40</span>%</span>
                                </div>
                                <input type="range" 
                                       x-model.number="searchFilters.semanticWeight" 
                                       @input="searchFilters.keywordWeight = 1 - searchFilters.semanticWeight"
                                       min="0" max="1" step="0.1" 
                                       class="w-full">
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <button @click="showAdvancedOptions = !showAdvancedOptions" 
                                class="text-sm text-rose-400 hover:text-rose-300 transition-colors">
                            <i :data-lucide="showAdvancedOptions ? 'chevron-up' : 'chevron-down'" class="w-4 h-4 mr-1 inline"></i>
                            Advanced Options
                        </button>
                        
                        <div class="flex items-center space-x-4 text-sm text-gray-400">
                            <span>Results: <span x-text="searchResults.length">0</span></span>
                            <span x-show="searchStats.totalTime">Time: <span x-text="searchStats.totalTime">0</span>ms</span>
                            <span x-show="searchStats.semanticMatches">Semantic: <span x-text="searchStats.semanticMatches">0</span></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Search Results -->
            <div class="space-y-6">
                <!-- Results Header -->
                <div class="flex items-center justify-between">
                    <div class="flex space-x-2">
                        <button @click="resultsView = 'list'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'list', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'list'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="list" class="w-4 h-4 mr-1 inline"></i>
                            List
                        </button>
                        <button @click="resultsView = 'clusters'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'clusters', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'clusters'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="git-branch" class="w-4 h-4 mr-1 inline"></i>
                            Clusters
                        </button>
                        <button @click="resultsView = 'context'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'context', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'context'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="layers" class="w-4 h-4 mr-1 inline"></i>
                            Rich Context
                        </button>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <label class="text-sm text-gray-400">Sort:</label>
                        <select x-model="sortBy" @change="sortSearchResults()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                            <option value="similarity">Similarity</option>
                            <option value="importance">Importance</option>
                            <option value="created_at">Date</option>
                            <option value="hybrid">Hybrid Score</option>
                        </select>
                    </div>
                </div>
                
                <!-- Empty State -->
                <div x-show="!isSearching && !searchResults.length" class="text-center py-12 text-gray-400">
                    <i data-lucide="search" class="w-16 h-16 mx-auto mb-4 opacity-50"></i>
                    <h3 class="text-lg font-semibold mb-2">No Search Results</h3>
                    <p class="text-sm">
                        <span x-show="!semanticQuery">Enter a search query to explore your memory system</span>
                        <span x-show="semanticQuery">Try adjusting your search terms or filters</span>
                    </p>
                    <div class="mt-4 space-y-2 text-sm text-gray-500">
                        <p><strong>Tips:</strong></p>
                        <p> Use natural language questions: "What did I learn about..."</p>
                        <p> Try concept-based searches: "machine learning insights"</p>
                        <p> Use hybrid mode for best results combining semantic + keyword</p>
                    </div>
                </div>
                
                <!-- Loading State -->
                <div x-show="isSearching" class="text-center py-12">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="text-gray-400">Searching through <span x-text="stats.totalMemories || 'your'"></span> memories...</p>
                    <p class="text-sm text-gray-500 mt-2" x-text="searchStatusMessage"></p>
                </div>
                
                <!-- List View -->
                <div x-show="resultsView === 'list' && searchResults.length" class="space-y-4">
                    <template x-for="(result, index) in sortedSearchResults" :key="result.memory_id">
                        <div class="enhanced-card rounded-xl p-6 cursor-pointer group" 
                             @click="selectSearchResult(result)"
                             :class="`memory-${result.memory_level}`">
                            <div class="flex items-start justify-between mb-4">
                                <div class="flex items-center space-x-3">
                                    <div class="text-lg font-bold text-rose-400" x-text="`#${index + 1}`"></div>
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getMemoryLevelClass(result.memory_level)" 
                                              x-text="result.memory_level"></span>
                                        <span class="text-xs text-gray-500" x-text="result.memory_type"></span>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-4 text-sm">
                                    <div class="text-right" x-show="result.similarity">
                                        <div class="text-rose-400 font-semibold" x-text="`${Math.round(result.similarity * 100)}%`"></div>
                                        <div class="text-xs text-gray-500">similarity</div>
                                    </div>
                                    <div class="text-right" x-show="result.hybrid_score">
                                        <div class="text-purple-400 font-semibold" x-text="`${Math.round(result.hybrid_score * 100)}%`"></div>
                                        <div class="text-xs text-gray-500">hybrid</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-blue-400 font-semibold" x-text="`${result.importance}/10`"></div>
                                        <div class="text-xs text-gray-500">importance</div>
                                    </div>
                                </div>
                            </div>
                            
                            <p class="text-gray-300 mb-4 line-clamp-3" x-text="result.content"></p>
                            
                            <div class="flex items-center justify-between text-sm text-gray-500">
                                <span x-text="formatRelativeTime(result.created_at)"></span>
                                <div class="flex items-center space-x-4">
                                    <span x-show="result.access_count" x-text="`${result.access_count} accesses`"></span>
                                    <span x-show="result.confidence" x-text="`${Math.round(result.confidence * 100)}% confidence`"></span>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Cluster View -->
                <div x-show="resultsView === 'clusters' && searchClusters.length" class="space-y-6">
                    <template x-for="cluster in searchClusters" :key="cluster.id">
                        <div class="enhanced-card rounded-xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold flex items-center">
                                    <i data-lucide="git-branch" class="w-5 h-5 mr-2 text-rose-400"></i>
                                    <span x-text="cluster.label"></span>
                                    <span class="ml-2 px-2 py-1 text-xs bg-rose-500/20 text-rose-400 rounded-full" x-text="`${cluster.results.length} memories`"></span>
                                </h3>
                                <button @click="cluster.expanded = !cluster.expanded" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i :data-lucide="cluster.expanded ? 'chevron-up' : 'chevron-down'" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="cluster.expanded" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <template x-for="result in cluster.results" :key="result.memory_id">
                                    <div class="p-4 bg-white/5 rounded-lg cursor-pointer hover:bg-white/10 transition-colors" 
                                         @click="selectSearchResult(result)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="px-2 py-1 text-xs rounded-full" 
                                                  :class="getMemoryLevelClass(result.memory_level)" 
                                                  x-text="result.memory_level"></span>
                                            <span class="text-sm text-rose-400 font-semibold" x-text="`${Math.round((result.similarity || result.hybrid_score || 0) * 100)}%`"></span>
                                        </div>
                                        <p class="text-sm text-gray-300 line-clamp-2" x-text="result.content"></p>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Rich Context View -->
                <div x-show="resultsView === 'context' && searchResults.length" class="enhanced-card rounded-xl p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i data-lucide="layers" class="w-5 h-5 mr-2 text-rose-400"></i>
                        Contextual Analysis
                    </h3>
                    
                    <div class="space-y-6">
                        <!-- Memory Distribution -->
                        <div>
                            <h4 class="font-medium mb-3">Memory Distribution</h4>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <template x-for="(count, level) in getMemoryDistribution()" :key="level">
                                    <div class="text-center p-3 bg-white/5 rounded-lg">
                                        <div class="text-lg font-bold" :class="getMemoryLevelClass(level)" x-text="count"></div>
                                        <div class="text-xs text-gray-400 capitalize" x-text="level"></div>
                                    </div>
                                </template>
                            </div>
                        </div>
                        
                        <!-- Key Insights -->
                        <div>
                            <h4 class="font-medium mb-3">Search Insights</h4>
                            <div class="space-y-2">
                                <template x-for="insight in getSearchInsights()" :key="insight.type">
                                    <div class="flex items-center space-x-2 text-sm">
                                        <i :data-lucide="insight.icon" class="w-4 h-4 text-blue-400"></i>
                                        <span x-text="insight.message"></span>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow Dependencies View -->
        <div x-show="dbLoaded && currentView === 'workflow-dependencies'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="git-merge" class="w-8 h-8 mr-3 text-violet-400"></i>
                        Workflow Dependencies
                    </h2>
                    <p class="text-gray-400" x-text="`${dependencyWorkflows.length} workflows  ${criticalPathStats.totalWorkflows} critical  ${resourceConflicts.length} conflicts`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <label class="text-sm text-gray-400">Mode:</label>
                        <div class="flex bg-white/10 rounded-lg p-1">
                            <button @click="dependencyViewMode = 'combined'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'combined', 'text-gray-400 hover:text-white': dependencyViewMode !== 'combined'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Combined</button>
                            <button @click="dependencyViewMode = 'network'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'network', 'text-gray-400 hover:text-white': dependencyViewMode !== 'network'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Network</button>
                            <button @click="dependencyViewMode = 'gantt'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'gantt', 'text-gray-400 hover:text-white': dependencyViewMode !== 'gantt'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Gantt</button>
                        </div>
                    </div>
                    <button @click="toggleSimulationMode()" 
                            :class="{'bg-blue-600 text-white': simulationMode, 'bg-white/10 text-gray-300 hover:bg-white/20': !simulationMode}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                        <i data-lucide="play-circle" class="w-4 h-4 mr-2"></i>
                        <span x-text="simulationMode ? 'Exit Simulation' : 'Enter Simulation'"></span>
                    </button>
                    <button @click="optimizeSchedule()" 
                            :disabled="isOptimizingSchedule"
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isOptimizingSchedule}"></i>
                        <span x-text="isOptimizingSchedule ? 'Optimizing...' : 'Auto-Optimize'"></span>
                    </button>
                    <button @click="exportSchedule()" 
                            class="px-4 py-2 bg-violet-600 hover:bg-violet-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                        Export
                    </button>
                </div>
            </div>

            <!-- Critical Path & Resource Stats -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-violet-400" x-text="dependencyWorkflows.length"></div>
                    <div class="text-xs text-gray-400">Total Workflows</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-violet-400 rounded-full transition-all duration-500" style="width: 100%"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="criticalPathStats.totalWorkflows"></div>
                    <div class="text-xs text-gray-400">Critical Path</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-red-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (criticalPathStats.totalWorkflows / Math.max(1, dependencyWorkflows.length)) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-yellow-400" x-text="resourceConflicts.length"></div>
                    <div class="text-xs text-gray-400">Resource Conflicts</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-yellow-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, resourceConflicts.length * 10)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="Math.round(criticalPathStats.totalDuration / 3600) + 'h'"></div>
                    <div class="text-xs text-gray-400">Total Duration</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (criticalPathStats.totalDuration / 86400) * 100)}%`"></div>
                    </div>
                </div>
            </div>

            <!-- Simulation Banner -->
            <div x-show="simulationMode" 
                 x-transition:enter="transition ease-out duration-300" 
                 x-transition:enter-start="opacity-0 transform -translate-y-2" 
                 x-transition:enter-end="opacity-100 transform translate-y-0"
                 class="enhanced-card rounded-xl p-4 bg-blue-500/10 border border-blue-500/30">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <i data-lucide="play-circle" class="w-5 h-5 text-blue-400 mr-3"></i>
                        <div>
                            <div class="font-semibold text-blue-400">Simulation Mode Active</div>
                            <div class="text-sm text-gray-400">Changes are temporary and can be reverted</div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button @click="restoreFromSnapshot()" 
                                :disabled="!simulationSnapshot"
                                class="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-sm font-medium transition-colors">
                            Restore
                        </button>
                        <button @click="toggleSimulationMode()" 
                                class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-sm font-medium transition-colors">
                            Exit
                        </button>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Visualization Area -->
                <div class="col-span-12 lg:col-span-9">
                    <!-- Combined View -->
                    <div x-show="dependencyViewMode === 'combined'" class="space-y-6">
                        <!-- Network View -->
                        <div class="enhanced-card rounded-2xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">Workflow Network</h3>
                                <div class="flex items-center space-x-2">
                                    <button @click="resetDependencyView()" 
                                            class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="relative" style="height: 400px;">
                                <svg x-ref="dependencyNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            </div>
                        </div>

                        <!-- Gantt Chart View -->
                        <div class="enhanced-card rounded-2xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">Schedule Timeline</h3>
                                <div class="flex items-center space-x-2 text-sm text-gray-400">
                                    <i data-lucide="info" class="w-4 h-4"></i>
                                    <span>Drag workflow bars to reschedule</span>
                                </div>
                            </div>
                            <div x-ref="ganttContainer" class="relative overflow-auto" style="max-height: 500px;"></div>
                        </div>
                    </div>

                    <!-- Network Only View -->
                    <div x-show="dependencyViewMode === 'network'" class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Workflow Network</h3>
                            <div class="flex items-center space-x-2">
                                <button @click="resetDependencyView()" 
                                        class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <div class="relative" style="height: calc(70vh - 6rem);">
                            <svg x-ref="dependencyNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                        </div>
                    </div>

                    <!-- Gantt Only View -->
                    <div x-show="dependencyViewMode === 'gantt'" class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Schedule Timeline</h3>
                            <div class="flex items-center space-x-2 text-sm text-gray-400">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                <span>Drag workflow bars to reschedule</span>
                            </div>
                        </div>
                        <div x-ref="ganttContainer" class="relative overflow-auto" style="height: calc(70vh - 8rem);"></div>
                    </div>
                </div>

                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3 space-y-6">
                    <!-- Selected Workflow Details -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div x-show="!selectedDependencyWorkflow" class="text-center text-gray-400 py-8">
                            <i data-lucide="git-merge" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <h4 class="font-semibold mb-2">No Workflow Selected</h4>
                            <p class="text-sm">Click on a workflow in the visualization to view details and dependencies</p>
                        </div>
                        
                        <div x-show="selectedDependencyWorkflow" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Workflow Details</h4>
                                <button @click="selectedDependencyWorkflow = null" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="selectedDependencyWorkflow" class="space-y-3">
                                <div>
                                    <h5 class="font-medium mb-2" x-text="selectedDependencyWorkflow?.title || selectedDependencyWorkflow?.workflow_id"></h5>
                                    <div class="flex items-center space-x-2 mb-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getWorkflowStatusClass(selectedDependencyWorkflow?.status)" 
                                              x-text="selectedDependencyWorkflow?.status"></span>
                                        <span x-show="selectedDependencyWorkflow?.critical_path" 
                                              class="px-2 py-1 text-xs rounded-full bg-red-500/20 text-red-400">
                                            Critical Path
                                        </span>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-3 text-sm">
                                    <div>
                                        <span class="text-gray-400">Progress:</span>
                                        <div class="text-green-400 font-semibold" x-text="selectedDependencyWorkflow?.progress + '%'"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Actions:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.actions?.length || 0"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Dependencies:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.dependencies?.length || 0"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Resources:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.resources?.length || 0"></div>
                                    </div>
                                </div>
                                
                                <div>
                                    <span class="text-gray-400 text-sm">Timeline:</span>
                                    <div class="text-sm mt-1">
                                        <div x-text="`Start: ${new Date(selectedDependencyWorkflow?.start_time * 1000).toLocaleString()}`"></div>
                                        <div x-text="`End: ${new Date(selectedDependencyWorkflow?.end_time * 1000).toLocaleString()}`"></div>
                                        <div x-text="`Duration: ${formatDuration(selectedDependencyWorkflow?.start_time, selectedDependencyWorkflow?.end_time)}`"></div>
                                    </div>
                                </div>
                                
                                <div x-show="selectedDependencyWorkflow?.resource_conflicts?.length > 0">
                                    <span class="text-gray-400 text-sm">Resource Conflicts:</span>
                                    <div class="text-sm mt-1 text-yellow-400" x-text="`${selectedDependencyWorkflow?.resource_conflicts?.length} conflicts detected`"></div>
                                </div>
                                
                                <div x-show="selectedDependencyWorkflow?.dependencies?.length > 0">
                                    <span class="text-gray-400 text-sm">Dependencies:</span>
                                    <div class="space-y-1 mt-1 max-h-24 overflow-y-auto">
                                        <template x-for="dep in selectedDependencyWorkflow?.dependencies" :key="dep.workflow_id">
                                            <div class="text-xs p-2 bg-white/5 rounded">
                                                <span class="font-medium" x-text="dep.workflow_id.substring(0, 8) + '...'"></span>
                                                <span class="text-gray-500" x-text="`(${dep.type})`"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Critical Path Analysis -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="route" class="w-5 h-5 mr-2 text-red-400"></i>
                            Critical Path
                        </h4>
                        
                        <div x-show="criticalPathStats.totalWorkflows === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">No critical path detected</div>
                        </div>
                        
                        <div x-show="criticalPathStats.totalWorkflows > 0" class="space-y-3">
                            <div class="text-sm">
                                <div class="text-gray-400">Critical Workflows:</div>
                                <div class="font-semibold text-red-400" x-text="criticalPathStats.totalWorkflows"></div>
                            </div>
                            
                            <div class="text-sm">
                                <div class="text-gray-400">Project Duration:</div>
                                <div class="font-semibold" x-text="Math.round(criticalPathStats.totalDuration / 3600) + ' hours'"></div>
                            </div>
                            
                            <div x-show="criticalPathStats.bottlenecks?.length > 0">
                                <div class="text-gray-400 text-sm mb-2">Bottlenecks:</div>
                                <div class="space-y-1 max-h-24 overflow-y-auto">
                                    <template x-for="bottleneck in criticalPathStats.bottlenecks" :key="bottleneck">
                                        <div class="text-xs p-2 bg-red-500/10 rounded border border-red-500/20">
                                            <span x-text="bottleneck"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Resource Conflicts -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="alert-triangle" class="w-5 h-5 mr-2 text-yellow-400"></i>
                            Resource Conflicts
                        </h4>
                        
                        <div x-show="resourceConflicts.length === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">No resource conflicts</div>
                        </div>
                        
                        <div x-show="resourceConflicts.length > 0" class="space-y-3 max-h-48 overflow-y-auto">
                            <template x-for="conflict in resourceConflicts" :key="conflict.id">
                                <div class="p-3 rounded-lg border-l-4" :class="`border-l-${getConflictSeverityColor(conflict.severity).replace('#', '')} bg-${getConflictSeverityColor(conflict.severity).replace('#', '')}/10`">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-sm font-medium" x-text="conflict.resource"></span>
                                        <span class="text-xs px-2 py-1 rounded-full" 
                                              :style="`background: ${getConflictSeverityColor(conflict.severity)}20; color: ${getConflictSeverityColor(conflict.severity)}`"
                                              x-text="conflict.severity"></span>
                                    </div>
                                    <div class="text-xs text-gray-400 mb-2">
                                        <div x-text="`${conflict.workflows[0].title} vs ${conflict.workflows[1].title}`"></div>
                                        <div x-text="`Overlap: ${new Date(conflict.overlap_start * 1000).toLocaleTimeString()} - ${new Date(conflict.overlap_end * 1000).toLocaleTimeString()}`"></div>
                                    </div>
                                    <div x-show="conflict.suggestions?.length > 0" class="text-xs">
                                        <div class="text-gray-400 mb-1">Suggestion:</div>
                                        <div x-text="conflict.suggestions[0]?.description"></div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cognitive State Timeline -->
        <div x-show="dbLoaded && currentView === 'cognitive-timeline'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="activity" class="w-8 h-8 mr-3 text-emerald-400"></i>
                        Cognitive State Timeline
                    </h2>
                    <p class="text-gray-400" x-text="`${cognitiveTimelineData.length} states  ${patternAnalysis.summary?.pattern_count || 0} patterns detected`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="cognitiveTimelineSettings.timeRange" @change="loadCognitiveTimeline()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="1">Last Hour</option>
                        <option value="6">Last 6 Hours</option>
                        <option value="24">Last 24 Hours</option>
                        <option value="72">Last 3 Days</option>
                        <option value="168">Last Week</option>
                    </select>
                    <select x-model="cognitiveTimelineSettings.granularity" @change="loadCognitiveTimeline()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="minute">By Minute</option>
                        <option value="hour">By Hour</option>
                        <option value="second">By Second</option>
                    </select>
                    <button @click="refreshCognitiveTimeline()" 
                            :disabled="isLoadingTimeline"
                            class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isLoadingTimeline}"></i>
                        Refresh
                    </button>
                    <button @click="analyzePatterns()" 
                            :disabled="isAnalyzingPatterns"
                            class="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="search" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isAnalyzingPatterns ? 'Analyzing...' : 'Analyze Patterns'"></span>
                    </button>
                </div>
            </div>

            <!-- Timeline Statistics -->
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-emerald-400" x-text="timelineStats.total_states || 0"></div>
                    <div class="text-xs text-gray-400">Total States</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-emerald-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (timelineStats.total_states || 0) / 50 * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="(timelineStats.avg_complexity || 0).toFixed(1)"></div>
                    <div class="text-xs text-gray-400">Avg Complexity</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${(timelineStats.avg_complexity || 0)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-orange-400" x-text="(timelineStats.max_change_magnitude || 0).toFixed(1) + '%'"></div>
                    <div class="text-xs text-gray-400">Max Change</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-orange-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, timelineStats.max_change_magnitude || 0)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="patternAnalysis.summary?.pattern_count || 0"></div>
                    <div class="text-xs text-gray-400">Patterns</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-purple-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (patternAnalysis.summary?.pattern_count || 0) * 20)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="patternAnalysis.summary?.anomaly_count || 0"></div>
                    <div class="text-xs text-gray-400">Anomalies</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-red-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (patternAnalysis.summary?.anomaly_count || 0) * 33)}%`"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Timeline Visualization -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="enhanced-card rounded-2xl p-6" style="min-height: 60vh;">
                        <!-- Timeline Controls -->
                        <div class="flex items-center justify-between mb-6">
                            <div class="flex items-center space-x-4">
                                <h3 class="text-lg font-semibold">State Timeline</h3>
                                <div class="flex items-center space-x-2">
                                    <button @click="playTimelineAnimation()" 
                                            :disabled="!cognitiveTimelineData.length"
                                            class="p-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg transition-colors">
                                        <i :data-lucide="isTimelineAnimating ? 'pause' : 'play'" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="resetTimelineView()" 
                                            class="p-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition-colors">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="flex items-center space-x-3">
                                <label class="text-sm text-gray-400">View:</label>
                                <div class="flex bg-white/10 rounded-lg p-1">
                                    <button @click="timelineViewMode = 'timeline'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'timeline', 'text-gray-400 hover:text-white': timelineViewMode !== 'timeline'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Timeline</button>
                                    <button @click="timelineViewMode = 'heatmap'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'heatmap', 'text-gray-400 hover:text-white': timelineViewMode !== 'heatmap'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Heatmap</button>
                                    <button @click="timelineViewMode = 'network'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'network', 'text-gray-400 hover:text-white': timelineViewMode !== 'network'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Network</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Timeline SVG Container -->
                        <div x-show="timelineViewMode === 'timeline'" class="relative" style="height: calc(60vh - 8rem);">
                            <svg x-ref="cognitiveTimelineSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            
                            <!-- Timeline Scrubber -->
                            <div class="absolute bottom-0 left-0 right-0 bg-black/80 backdrop-blur-lg rounded-lg p-4">
                                <div class="flex items-center space-x-4 mb-3">
                                    <button @click="stepTimelineBackward()" 
                                            :disabled="currentTimelineIndex <= 0"
                                            class="p-2 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-800 rounded-lg transition-colors">
                                        <i data-lucide="skip-back" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="toggleTimelinePlayback()" 
                                            :disabled="!cognitiveTimelineData.length"
                                            class="p-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg transition-colors">
                                        <i :data-lucide="isTimelineAnimating ? 'pause' : 'play'" class="w-5 h-5"></i>
                                    </button>
                                    <button @click="stepTimelineForward()" 
                                            :disabled="currentTimelineIndex >= cognitiveTimelineData.length - 1"
                                            class="p-2 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-800 rounded-lg transition-colors">
                                        <i data-lucide="skip-forward" class="w-4 h-4"></i>
                                    </button>
                                    
                                    <div class="flex items-center space-x-2 ml-4">
                                        <span class="text-xs text-gray-400">Speed:</span>
                                        <select x-model.number="timelineAnimationSpeed" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                                            <option value="0.5">0.5x</option>
                                            <option value="1">1x</option>
                                            <option value="2">2x</option>
                                            <option value="4">4x</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Timeline Slider -->
                                <div class="relative">
                                    <input type="range" 
                                           x-model.number="currentTimelineIndex" 
                                           @input="seekToTimelinePosition($event.target.value)"
                                           :min="0" 
                                           :max="Math.max(0, cognitiveTimelineData.length - 1)" 
                                           :step="1"
                                           class="w-full h-2 bg-gray-700 rounded-lg appearance-none slider cursor-pointer">
                                    
                                    <!-- Timeline markers for significant events -->
                                    <div class="absolute top-0 left-0 w-full h-2 pointer-events-none">
                                        <template x-for="(state, index) in cognitiveTimelineData" :key="state.state_id">
                                            <div x-show="state.change_magnitude > 30" 
                                                 class="absolute w-1 h-2 bg-red-400 rounded-full"
                                                 :style="`left: ${(index / (cognitiveTimelineData.length - 1)) * 100}%`"
                                                 :title="`Major change: ${state.change_magnitude.toFixed(1)}%`"></div>
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- Current state info -->
                                <div x-show="cognitiveTimelineData[currentTimelineIndex]" class="flex items-center justify-between mt-3 text-sm">
                                    <div>
                                        <span class="text-gray-400" x-text="`State ${currentTimelineIndex + 1} of ${cognitiveTimelineData.length}`"></span>
                                        <span class="ml-3" x-text="cognitiveTimelineData[currentTimelineIndex]?.state_type"></span>
                                    </div>
                                    <div x-text="formatDate(cognitiveTimelineData[currentTimelineIndex]?.timestamp)"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Heatmap View -->
                        <div x-show="timelineViewMode === 'heatmap'" class="relative" style="height: calc(60vh - 8rem);">
                            <div x-ref="cognitiveHeatmap" class="w-full h-full bg-black/10 rounded-lg"></div>
                        </div>
                        
                        <!-- Network View -->
                        <div x-show="timelineViewMode === 'network'" class="relative" style="height: calc(60vh - 8rem);">
                            <svg x-ref="cognitiveNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Sidebar -->
                <div class="col-span-12 lg:col-span-3 space-y-6">
                    <!-- Current State Details -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h4 class="font-semibold">Current State</h4>
                            <button x-show="selectedTimelineState" 
                                    @click="showTimelineStateModal = true" 
                                    class="p-1 hover:bg-white/10 rounded transition-colors">
                                <i data-lucide="external-link" class="w-4 h-4"></i>
                            </button>
                        </div>
                        
                        <div x-show="!selectedTimelineState" class="text-center text-gray-400 py-8">
                            <i data-lucide="mouse-pointer-click" class="w-8 h-8 mx-auto mb-3 opacity-50"></i>
                            <p class="text-sm">Click on a state in the timeline to view details</p>
                        </div>
                        
                        <div x-show="selectedTimelineState" class="space-y-4">
                            <div>
                                <div class="text-xs text-gray-400 mb-1">State Type</div>
                                <div class="flex items-center space-x-2">
                                    <span class="px-2 py-1 text-xs rounded-full bg-emerald-500/20 text-emerald-400" 
                                          x-text="selectedTimelineState?.state_type"></span>
                                    <span class="text-sm text-gray-400" x-text="`#${selectedTimelineState?.sequence_number}`"></span>
                                </div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Complexity Score</div>
                                <div class="text-lg font-semibold" x-text="selectedTimelineState?.complexity_score?.toFixed(1) + '/100'"></div>
                                <div class="w-full bg-gray-700 rounded-full h-1 mt-1">
                                    <div class="bg-emerald-400 h-1 rounded-full transition-all duration-300" 
                                         :style="`width: ${selectedTimelineState?.complexity_score || 0}%`"></div>
                                </div>
                            </div>
                            
                            <div x-show="selectedTimelineState?.change_magnitude > 0">
                                <div class="text-xs text-gray-400 mb-1">Change Magnitude</div>
                                <div class="text-lg font-semibold" 
                                     :class="selectedTimelineState?.change_magnitude > 50 ? 'text-red-400' : selectedTimelineState?.change_magnitude > 25 ? 'text-yellow-400' : 'text-green-400'"
                                     x-text="selectedTimelineState?.change_magnitude?.toFixed(1) + '%'"></div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Key Components</div>
                                <div class="space-y-1 max-h-24 overflow-y-auto">
                                    <template x-for="component in selectedTimelineState?.key_components?.slice(0, 3)" :key="component.name">
                                        <div class="text-xs p-2 bg-white/5 rounded">
                                            <span class="font-medium" x-text="component.name"></span>
                                            <span class="text-gray-500" x-text="`(${component.type})`"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Tags</div>
                                <div class="flex flex-wrap gap-1">
                                    <template x-for="tag in selectedTimelineState?.tags?.slice(0, 4)" :key="tag">
                                        <span class="px-2 py-1 text-xs bg-gray-600/50 text-gray-300 rounded-full" x-text="tag"></span>
                                    </template>
                                </div>
                            </div>
                            
                            <div class="pt-3 border-t border-white/10">
                                <button @click="compareWithPreviousState()" 
                                        :disabled="!canCompareWithPrevious()"
                                        class="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors mb-2">
                                    <i data-lucide="git-compare" class="w-4 h-4 mr-2 inline"></i>
                                    Compare with Previous
                                </button>
                                <button @click="restoreToState(selectedTimelineState)" 
                                        :disabled="!selectedTimelineState"
                                        class="w-full px-3 py-2 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="undo" class="w-4 h-4 mr-2 inline"></i>
                                    Restore to State
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Pattern Analysis -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="search" class="w-5 h-5 mr-2 text-purple-400"></i>
                            Pattern Analysis
                        </h4>
                        
                        <div x-show="!patternAnalysis.patterns?.length" class="text-center text-gray-400 py-4">
                            <i data-lucide="search" class="w-8 h-8 mx-auto mb-3 opacity-50"></i>
                            <p class="text-sm">No patterns detected</p>
                            <button @click="analyzePatterns()" 
                                    class="mt-2 px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded text-xs transition-colors">
                                Analyze
                            </button>
                        </div>
                        
                        <div x-show="patternAnalysis.patterns?.length" class="space-y-3">
                            <template x-for="pattern in patternAnalysis.patterns?.slice(0, 3)" :key="pattern.type">
                                <div class="p-3 bg-white/5 rounded-lg border-l-4 border-purple-400">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-sm font-medium" x-text="pattern.pattern_description"></span>
                                        <span class="text-xs text-purple-400" x-text="`${(pattern.similarity * 100).toFixed(0)}%`"></span>
                                    </div>
                                    <div class="text-xs text-gray-400">
                                        <span x-text="`Length: ${pattern.length}`"></span>
                                        <span class="ml-2" x-text="`Occurrences: ${pattern.occurrences}`"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <button @click="showPatternsModal = true" 
                                    class="w-full px-3 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors">
                                View All Patterns
                            </button>
                        </div>
                    </div>
                    
                    <!-- State Transitions -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="shuffle" class="w-5 h-5 mr-2 text-blue-400"></i>
                            Common Transitions
                        </h4>
                        
                        <div class="space-y-2 max-h-48 overflow-y-auto">
                            <template x-for="transition in patternAnalysis.transitions?.slice(0, 5)" :key="transition.transition">
                                <div class="flex items-center justify-between p-2 bg-white/5 rounded">
                                    <span class="text-sm" x-text="transition.transition"></span>
                                    <div class="text-right">
                                        <div class="text-xs text-blue-400" x-text="`${transition.percentage.toFixed(1)}%`"></div>
                                        <div class="text-xs text-gray-500" x-text="`${transition.count}x`"></div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    
                    <!-- Anomalies -->
                    <div x-show="patternAnalysis.anomalies?.length" class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="alert-triangle" class="w-5 h-5 mr-2 text-red-400"></i>
                            Anomalies Detected
                        </h4>
                        
                        <div class="space-y-2 max-h-32 overflow-y-auto">
                            <template x-for="anomaly in patternAnalysis.anomalies?.slice(0, 3)" :key="anomaly.state_id">
                                <div class="p-2 bg-red-500/10 rounded-lg border border-red-500/20 cursor-pointer hover:bg-red-500/20 transition-colors"
                                     @click="jumpToTimelineState(anomaly.state_id)">
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-sm font-medium text-red-400" x-text="anomaly.anomaly_type"></span>
                                        <span class="text-xs" :class="anomaly.severity === 'high' ? 'text-red-400' : 'text-yellow-400'" x-text="anomaly.severity"></span>
                                    </div>
                                    <div class="text-xs text-gray-400" x-text="anomaly.description"></div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Execution Monitor -->
        <div x-show="dbLoaded && currentView === 'action-monitor'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="activity" class="w-8 h-8 mr-3 text-orange-400"></i>
                        Action Execution Monitor
                    </h2>
                    <p class="text-gray-400">Real-time monitoring of action execution with performance metrics and error tracking</p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <div :class="{'bg-green-400': actionMonitorStatus.connected, 'bg-red-400': !actionMonitorStatus.connected}" 
                             class="w-2 h-2 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-400" x-text="actionMonitorStatus.connected ? 'Live Monitoring' : 'Disconnected'"></span>
                    </div>
                    <button @click="toggleActionMonitoring()" 
                            :class="{'bg-green-600 hover:bg-green-700': !isMonitoringActions, 'bg-red-600 hover:bg-red-700': isMonitoringActions}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i :data-lucide="isMonitoringActions ? 'stop-circle' : 'play-circle'" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isMonitoringActions ? 'Stop Monitoring' : 'Start Monitoring'"></span>
                    </button>
                    <button @click="refreshActionMonitor()" 
                            class="px-4 py-2 bg-orange-600 hover:bg-orange-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline"></i>
                        Refresh
                    </button>
                    <button @click="exportActionReport()" 
                            class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                        Export Report
                    </button>
                </div>
            </div>

            <!-- Real-time Metrics Dashboard -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-orange-400" x-text="realtimeMetrics.actionsPerSecond.toFixed(2)"></div>
                    <div class="text-xs text-gray-400">Actions/sec</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-orange-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, realtimeMetrics.actionsPerSecond * 10)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="realtimeMetrics.avgResponseTime + 'ms'"></div>
                    <div class="text-xs text-gray-400">Avg Response</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.max(0, 100 - (realtimeMetrics.avgResponseTime / 1000) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-green-400" x-text="actionMonitorStatus.successRate + '%'"></div>
                    <div class="text-xs text-gray-400">Success Rate</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-green-400 rounded-full transition-all duration-500" 
                             :style="`width: ${actionMonitorStatus.successRate}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="realtimeMetrics.errorCount"></div>
                    <div class="text-xs text-gray-400">Errors (24h)</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-red-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, realtimeMetrics.errorCount * 5)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="actionMonitorData.queuedActions.length"></div>
                    <div class="text-xs text-gray-400">Queued Actions</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-purple-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, actionMonitorData.queuedActions.length * 10)}%`"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Monitoring Dashboard -->
                <div class="col-span-12 lg:col-span-8 space-y-6">
                    <!-- Action Status Cards -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-6">
                            <h3 class="text-lg font-semibold">Running Actions</h3>
                            <div class="flex items-center space-x-3">
                                <div class="flex items-center space-x-2">
                                    <input type="text" 
                                           x-model="actionSearchQuery" 
                                           @input="filterActionMonitor()"
                                           placeholder="Search actions..." 
                                           class="w-48 px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-sm">
                                </div>
                                <select x-model="actionFilterType" @change="filterActionMonitor()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                    <option value="all">All Actions</option>
                                    <option value="running">Running</option>
                                    <option value="queued">Queued</option>
                                    <option value="completed">Completed</option>
                                    <option value="failed">Failed</option>
                                </select>
                                <select x-model="actionFilterTool" @change="filterActionMonitor()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                    <option value="">All Tools</option>
                                    <template x-for="tool in getUniqueTools()" :key="tool">
                                        <option :value="tool" x-text="tool"></option>
                                    </template>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Action Cards Grid -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-96 overflow-y-auto">
                            <!-- Running Actions -->
                            <template x-for="action in getFilteredActions('running')" :key="action.action_id">
                                <div class="p-4 bg-blue-500/10 border border-blue-500/30 rounded-lg hover:bg-blue-500/20 transition-colors cursor-pointer"
                                     @click="selectActionForDetails(action)">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 bg-blue-400 rounded-full animate-pulse"></div>
                                            <span class="text-sm font-medium text-blue-400">Running</span>
                                        </div>
                                        <div class="text-xs text-gray-400" x-text="formatElapsedTime(action.started_at)"></div>
                                    </div>
                                    <h4 class="font-semibold mb-2" x-text="action.title || action.tool_name || action.action_type"></h4>
                                    <p class="text-sm text-gray-300 mb-3 line-clamp-2" x-text="action.description || action.reasoning || 'No description'"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-500" x-text="action.tool_name || action.action_type"></span>
                                        <div class="flex items-center space-x-2">
                                            <div class="w-2 h-2 rounded-full" :class="getActionPriorityColor(action.priority)"></div>
                                            <span class="text-xs" x-text="action.priority || 'normal'"></span>
                                        </div>
                                    </div>
                                    <!-- Progress bar for running actions -->
                                    <div class="mt-3 w-full bg-gray-700 rounded-full h-1">
                                        <div class="bg-blue-400 h-1 rounded-full transition-all duration-300" 
                                             :style="`width: ${action.progress || 0}%`"></div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Queued Actions -->
                            <template x-for="action in getFilteredActions('queued')" :key="action.action_id">
                                <div class="p-4 bg-purple-500/10 border border-purple-500/30 rounded-lg hover:bg-purple-500/20 transition-colors cursor-pointer"
                                     @click="selectActionForDetails(action)">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 bg-purple-400 rounded-full"></div>
                                            <span class="text-sm font-medium text-purple-400">Queued</span>
                                        </div>
                                        <div class="text-xs text-gray-400" x-text="`Position: ${action.queue_position || '?'}`"></div>
                                    </div>
                                    <h4 class="font-semibold mb-2" x-text="action.title || action.tool_name || action.action_type"></h4>
                                    <p class="text-sm text-gray-300 mb-3 line-clamp-2" x-text="action.description || action.reasoning || 'No description'"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-500" x-text="action.tool_name || action.action_type"></span>
                                        <span class="text-xs text-gray-400" x-text="`ETA: ${action.estimated_start || 'Unknown'}`"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Recently Completed Actions -->
                            <template x-for="action in getFilteredActions('completed').slice(0, 4)" :key="action.action_id">
                                <div class="p-4 bg-green-500/10 border border-green-500/30 rounded-lg hover:bg-green-500/20 transition-colors cursor-pointer"
                                     @click="selectActionForDetails(action)">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 bg-green-400 rounded-full"></div>
                                            <span class="text-sm font-medium text-green-400">Completed</span>
                                        </div>
                                        <div class="text-xs text-gray-400" x-text="formatElapsedTime(action.completed_at)"></div>
                                    </div>
                                    <h4 class="font-semibold mb-2" x-text="action.title || action.tool_name || action.action_type"></h4>
                                    <p class="text-sm text-gray-300 mb-3 line-clamp-2" x-text="action.description || action.reasoning || 'No description'"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-500" x-text="action.tool_name || action.action_type"></span>
                                        <span class="text-xs text-green-400" x-text="`${action.execution_time || 0}ms`"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Failed Actions -->
                            <template x-for="action in getFilteredActions('failed')" :key="action.action_id">
                                <div class="p-4 bg-red-500/10 border border-red-500/30 rounded-lg hover:bg-red-500/20 transition-colors cursor-pointer"
                                     @click="selectActionForDetails(action)">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 bg-red-400 rounded-full"></div>
                                            <span class="text-sm font-medium text-red-400">Failed</span>
                                        </div>
                                        <div class="text-xs text-gray-400" x-text="formatElapsedTime(action.failed_at)"></div>
                                    </div>
                                    <h4 class="font-semibold mb-2" x-text="action.title || action.tool_name || action.action_type"></h4>
                                    <p class="text-sm text-red-300 mb-3 line-clamp-2" x-text="action.error_message || action.error || 'Unknown error'"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-500" x-text="action.tool_name || action.action_type"></span>
                                        <button @click.stop="retryAction(action)" 
                                                class="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs transition-colors">
                                            Retry
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Performance Charts -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Performance Metrics</h3>
                            <div class="flex items-center space-x-2">
                                <select x-model="performanceChartTimeRange" @change="updatePerformanceCharts()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                                    <option value="1h">Last Hour</option>
                                    <option value="6h">Last 6 Hours</option>
                                    <option value="24h">Last 24 Hours</option>
                                    <option value="7d">Last 7 Days</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <!-- Execution Time Chart -->
                            <div class="chart-container">
                                <h4 class="text-sm font-medium mb-3">Execution Time Trend</h4>
                                <canvas x-ref="executionTimeChart" class="w-full h-48" style="max-height: 192px !important; height: 192px !important;"></canvas>
                            </div>
                            
                            <!-- Throughput Chart -->
                            <div class="chart-container">
                                <h4 class="text-sm font-medium mb-3">Action Throughput</h4>
                                <canvas x-ref="throughputChart" class="w-full h-48" style="max-height: 192px !important; height: 192px !important;"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Batch Operations -->
                    <div class="enhanced-card rounded-2xl p-6" x-show="actionMonitorData.batchOperations.length > 0">
                        <h3 class="text-lg font-semibold mb-4">Batch Operations</h3>
                        <div class="space-y-4">
                            <template x-for="batch in actionMonitorData.batchOperations" :key="batch.batch_id">
                                <div class="p-4 bg-white/5 rounded-lg border border-white/10">
                                    <div class="flex items-center justify-between mb-3">
                                        <h4 class="font-semibold" x-text="batch.name"></h4>
                                        <div class="flex items-center space-x-2">
                                            <span class="text-sm" x-text="`${batch.completed}/${batch.total}`"></span>
                                            <span class="text-xs text-gray-400" x-text="`${Math.round((batch.completed / batch.total) * 100)}%`"></span>
                                        </div>
                                    </div>
                                    <div class="w-full bg-gray-700 rounded-full h-2 mb-3">
                                        <div class="bg-orange-400 h-2 rounded-full transition-all duration-300" 
                                             :style="`width: ${(batch.completed / batch.total) * 100}%`"></div>
                                    </div>
                                    <div class="flex items-center justify-between text-sm text-gray-400">
                                        <span x-text="`Started: ${formatRelativeTime(batch.started_at)}`"></span>
                                        <span x-text="`ETA: ${batch.estimated_completion || 'Unknown'}`"></span>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-4 space-y-6">
                    <!-- Tool Usage Statistics -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="wrench" class="w-5 h-5 mr-2 text-blue-400"></i>
                            Tool Usage
                        </h3>
                        
                        <div class="space-y-3 max-h-64 overflow-y-auto">
                            <template x-for="(stats, tool) in actionMonitorData.toolUsageStats" :key="tool">
                                <div class="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                                    <div class="flex-1">
                                        <div class="font-medium text-sm" x-text="tool"></div>
                                        <div class="text-xs text-gray-400" x-text="`Avg: ${stats.avg_time}ms | Success: ${stats.success_rate}%`"></div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-lg font-bold text-blue-400" x-text="stats.count"></div>
                                        <div class="text-xs text-gray-500">uses</div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Error Log -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold flex items-center">
                                <i data-lucide="alert-triangle" class="w-5 h-5 mr-2 text-red-400"></i>
                                Recent Errors
                            </h3>
                            <button @click="clearErrorLog()" 
                                    class="px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs transition-colors">
                                Clear
                            </button>
                        </div>
                        
                        <div x-show="actionMonitorData.errorLog.length === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">No recent errors</div>
                        </div>
                        
                        <div class="space-y-3 max-h-64 overflow-y-auto">
                            <template x-for="error in actionMonitorData.errorLog.slice(0, 10)" :key="error.id">
                                <div class="p-3 bg-red-500/10 border border-red-500/20 rounded-lg">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-sm font-medium text-red-400" x-text="error.type"></span>
                                        <span class="text-xs text-gray-400" x-text="formatRelativeTime(error.timestamp)"></span>
                                    </div>
                                    <p class="text-xs text-gray-300 mb-2 line-clamp-2" x-text="error.message"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-500" x-text="error.action_type || 'Unknown'"></span>
                                        <button @click="showErrorDetails(error)" 
                                                class="text-xs text-red-400 hover:text-red-300">
                                            Details
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Action Queue -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold flex items-center">
                                <i data-lucide="clock" class="w-5 h-5 mr-2 text-purple-400"></i>
                                Action Queue
                            </h3>
                            <div class="text-sm text-gray-400" x-text="`${actionMonitorData.queuedActions.length} queued`"></div>
                        </div>
                        
                        <div x-show="actionMonitorData.queuedActions.length === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">Queue is empty</div>
                        </div>
                        
                        <div class="space-y-3 max-h-48 overflow-y-auto">
                            <template x-for="(action, index) in actionMonitorData.queuedActions.slice(0, 5)" :key="action.action_id">
                                <div class="flex items-center space-x-3 p-3 bg-white/5 rounded-lg">
                                    <div class="w-6 h-6 rounded-full bg-purple-500/20 flex items-center justify-center text-xs font-bold text-purple-400" 
                                         x-text="index + 1"></div>
                                    <div class="flex-1 min-w-0">
                                        <div class="text-sm font-medium truncate" x-text="action.title || action.tool_name"></div>
                                        <div class="text-xs text-gray-400" x-text="`ETA: ${action.estimated_start || 'Soon'}`"></div>
                                    </div>
                                    <button @click="cancelQueuedAction(action)" 
                                            class="p-1 text-gray-400 hover:text-red-400 transition-colors">
                                        <i data-lucide="x" class="w-3 h-3"></i>
                                    </button>
                                </div>
                            </template>
                        </div>
                    </div>

                    <!-- Monitor Settings -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="settings" class="w-5 h-5 mr-2 text-gray-400"></i>
                            Monitor Settings
                        </h3>
                        
                        <div class="space-y-4">
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Auto Refresh</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" x-model="actionMonitorSettings.autoRefresh" @change="updateMonitorSettings()" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-orange-600"></div>
                                </label>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Refresh Interval (ms)</label>
                                <input type="range" 
                                       x-model.number="actionMonitorSettings.refreshInterval" 
                                       @input="updateMonitorSettings()"
                                       min="500" max="10000" step="500" 
                                       class="w-full">
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>500ms</span>
                                    <span x-text="actionMonitorSettings.refreshInterval + 'ms'"></span>
                                    <span>10s</span>
                                </div>
                            </div>
                            
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Show Completed</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" x-model="actionMonitorSettings.showCompleted" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-orange-600"></div>
                                </label>
                            </div>
                            
                            <div class="flex items-center justify-between">
                                <span class="text-sm">Sound Alerts</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" x-model="actionMonitorSettings.soundAlerts" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-orange-600"></div>
                                </label>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Max History Items</label>
                                <input type="number" 
                                       x-model.number="actionMonitorSettings.maxHistoryItems" 
                                       min="10" max="1000" step="10"
                                       class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg text-sm">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Working Memory Dashboard -->
        <div x-show="dbLoaded && currentView === 'working-memory'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="cpu" class="w-8 h-8 mr-3 text-amber-400"></i>
                        Working Memory Dashboard
                    </h2>
                    <p class="text-gray-400">Real-time memory management and optimization controls</p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <div :class="{'bg-green-400': workingMemoryStatus.connected, 'bg-red-400': !workingMemoryStatus.connected}" 
                             class="w-2 h-2 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-400" x-text="workingMemoryStatus.connected ? 'Live' : 'Disconnected'"></span>
                    </div>
                    <button @click="refreshWorkingMemory()" 
                            :disabled="isRefreshingWorkingMemory"
                            class="px-4 py-2 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isRefreshingWorkingMemory}"></i>
                        Refresh
                    </button>
                    <button @click="optimizeWorkingMemory()" 
                            :disabled="isOptimizing"
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isOptimizing ? 'Optimizing...' : 'Auto-Optimize'"></span>
                    </button>
                </div>
            </div>

            <!-- Memory Pressure & Temperature Overview -->
            <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-amber-400" x-text="workingMemoryStats.activeCount"></div>
                    <div class="text-xs text-gray-400">Active Memories</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-amber-400 rounded-full transition-all duration-500" 
                             :style="`width: ${(workingMemoryStats.activeCount / workingMemoryStats.capacity) * 100}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold" :class="getPressureColor(workingMemoryStats.pressure)" x-text="workingMemoryStats.pressure + '%'"></div>
                    <div class="text-xs text-gray-400">Memory Pressure</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-500" 
                             :class="getPressureGradient(workingMemoryStats.pressure)"
                             :style="`width: ${workingMemoryStats.pressure}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold" :class="getTemperatureColor(workingMemoryStats.temperature)" x-text="workingMemoryStats.temperature + ''"></div>
                    <div class="text-xs text-gray-400">Temperature</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-500" 
                             :class="getTemperatureGradient(workingMemoryStats.temperature)"
                             :style="`width: ${Math.min(workingMemoryStats.temperature, 100)}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="workingMemoryStats.focusScore.toFixed(1)"></div>
                    <div class="text-xs text-gray-400">Focus Score</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${workingMemoryStats.focusScore}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="workingMemoryStats.efficiency + '%'"></div>
                    <div class="text-xs text-gray-400">Efficiency</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-purple-400 rounded-full transition-all duration-500" 
                             :style="`width: ${workingMemoryStats.efficiency}%`"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Memory Dashboard -->
                <div class="col-span-12 lg:col-span-8 space-y-6">
                    <!-- Memory Pressure Gauge -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Memory Pressure Monitor</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-sm text-gray-400">Auto-refresh:</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" x-model="workingMemorySettings.autoRefresh" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-600"></div>
                                </label>
                            </div>
                        </div>
                        <div class="h-64">
                            <canvas x-ref="memoryPressureGauge" class="w-full h-full"></canvas>
                        </div>
                    </div>

                    <!-- Memory Temperature Heatmap -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Memory Activity Heatmap</h3>
                            <div class="flex items-center space-x-2">
                                <select x-model="heatmapSettings.timeframe" @change="updateHeatmap()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                                    <option value="1h">Last Hour</option>
                                    <option value="6h">Last 6 Hours</option>
                                    <option value="24h">Last 24 Hours</option>
                                    <option value="7d">Last 7 Days</option>
                                </select>
                            </div>
                        </div>
                        <div class="h-48 relative" x-ref="memoryHeatmap">
                            <!-- Heatmap will be rendered here -->
                        </div>
                    </div>

                    <!-- Active Working Memory -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Active Working Memory</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-sm text-gray-400" x-text="`${activeWorkingMemories.length} / ${workingMemoryStats.capacity} slots`"></span>
                                <button @click="clearWorkingMemory()" 
                                        class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-xs font-medium transition-colors">
                                    Clear All
                                </button>
                            </div>
                        </div>
                        
                        <!-- Memory Slots -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" 
                             x-ref="workingMemoryContainer"
                             @drop.prevent="handleMemoryDrop($event)"
                             @dragover.prevent="handleMemoryDragOver($event)">
                            <template x-for="(memory, index) in activeWorkingMemories" :key="memory.memory_id">
                                <div class="working-memory-item p-4 bg-white/5 rounded-lg border-2 border-dashed border-transparent hover:border-amber-400/50 transition-all duration-300 cursor-move"
                                     :class="getMemoryActivityClass(memory)"
                                     :draggable="true"
                                     @dragstart="handleMemoryDragStart($event, memory)"
                                     @click="selectWorkingMemory(memory)">
                                    
                                    <!-- Memory Header -->
                                    <div class="flex items-center justify-between mb-2">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 rounded-full" :class="getMemoryTypeColor(memory.memory_type)"></div>
                                            <span class="text-xs font-medium text-gray-300" x-text="memory.memory_type"></span>
                                        </div>
                                        <div class="flex items-center space-x-2">
                                            <!-- Temperature indicator -->
                                            <div class="w-2 h-2 rounded-full" :class="getTemperatureIndicator(memory.temperature)"></div>
                                            <!-- Priority indicator -->
                                            <div class="text-xs" :class="getPriorityColor(memory.priority)" x-text="memory.priority"></div>
                                            <!-- Remove button -->
                                            <button @click.stop="removeFromWorkingMemory(memory)" 
                                                    class="w-4 h-4 rounded-full bg-red-500/20 hover:bg-red-500/40 flex items-center justify-center transition-colors">
                                                <i data-lucide="x" class="w-3 h-3 text-red-400"></i>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Memory Content -->
                                    <div class="text-sm text-gray-300 mb-2 line-clamp-2" x-text="memory.content"></div>
                                    
                                    <!-- Memory Metrics -->
                                    <div class="flex items-center justify-between text-xs text-gray-500">
                                        <span x-text="`Importance: ${memory.importance}/10`"></span>
                                        <span x-text="`Last: ${formatRelativeTime(memory.last_accessed_at)}`"></span>
                                    </div>
                                    
                                    <!-- Access frequency indicator -->
                                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                                        <div class="h-full bg-amber-400 rounded-full transition-all duration-300" 
                                             :style="`width: ${Math.min(memory.access_frequency * 10, 100)}%`"></div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Empty slots -->
                            <template x-for="i in Math.max(0, workingMemoryStats.capacity - activeWorkingMemories.length)" :key="`empty-${i}`">
                                <div class="working-memory-slot p-4 border-2 border-dashed border-gray-600 rounded-lg flex items-center justify-center text-gray-500 hover:border-amber-400/50 transition-colors min-h-[120px]"
                                     @drop.prevent="handleEmptySlotDrop($event, i)"
                                     @dragover.prevent="$event.dataTransfer.dropEffect = 'move'">
                                    <div class="text-center">
                                        <i data-lucide="plus" class="w-6 h-6 mx-auto mb-2 opacity-50"></i>
                                        <div class="text-sm">Empty Slot</div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Sidebar Controls -->
                <div class="col-span-12 lg:col-span-4 space-y-6">
                    <!-- Optimization Recommendations -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="lightbulb" class="w-5 h-5 mr-2 text-yellow-400"></i>
                            Optimization Suggestions
                        </h3>
                        
                        <div class="space-y-3">
                            <template x-for="suggestion in optimizationSuggestions" :key="suggestion.id">
                                <div class="p-3 bg-white/5 rounded-lg border-l-4" :class="getSuggestionBorderClass(suggestion.priority)">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex items-center space-x-2">
                                            <i :data-lucide="suggestion.icon" class="w-4 h-4" :class="getSuggestionIconClass(suggestion.priority)"></i>
                                            <span class="text-sm font-medium" x-text="suggestion.title"></span>
                                        </div>
                                        <div class="flex items-center space-x-1">
                                            <span class="text-xs px-2 py-1 rounded-full" 
                                                  :class="getSuggestionPriorityClass(suggestion.priority)" 
                                                  x-text="suggestion.priority"></span>
                                        </div>
                                    </div>
                                    <p class="text-xs text-gray-400 mb-3" x-text="suggestion.description"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-green-400" x-text="`Impact: ${suggestion.impact}`"></span>
                                        <button @click="applyOptimization(suggestion)" 
                                                :disabled="suggestion.applying"
                                                class="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-xs font-medium transition-colors">
                                            <span x-text="suggestion.applying ? 'Applying...' : suggestion.action"></span>
                                        </button>
                                    </div>
                                </div>
                            </template>
                            
                            <div x-show="optimizationSuggestions.length === 0" class="text-center text-gray-500 py-4">
                                <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                                <div class="text-sm">Memory is optimally configured</div>
                            </div>
                        </div>
                    </div>

                    <!-- Focus Management -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="target" class="w-5 h-5 mr-2 text-blue-400"></i>
                            Focus Management
                        </h3>
                        
                        <!-- Focus Score Chart -->
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm text-gray-400">Current Focus Score</span>
                                <span class="text-lg font-bold text-blue-400" x-text="workingMemoryStats.focusScore.toFixed(1) + '%'"></span>
                            </div>
                            <canvas x-ref="focusScoreChart" class="w-full h-32" style="max-height: 128px !important; height: 128px !important;"></canvas>
                        </div>
                        
                        <!-- Focus Controls -->
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium mb-2">Focus Mode</label>
                                <select x-model="focusSettings.mode" @change="applyFocusMode()" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                    <option value="normal">Normal</option>
                                    <option value="deep">Deep Focus</option>
                                    <option value="creative">Creative Flow</option>
                                    <option value="analytical">Analytical</option>
                                    <option value="maintenance">Maintenance</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Memory Retention (minutes)</label>
                                <input type="range" 
                                       x-model.number="focusSettings.retentionTime" 
                                       @input="updateRetentionTime()"
                                       min="5" max="120" step="5" 
                                       class="w-full">
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>5m</span>
                                    <span x-text="focusSettings.retentionTime + 'm'"></span>
                                    <span>120m</span>
                                </div>
                            </div>
                            
                            <button @click="enterDeepFocus()" 
                                    :disabled="focusSettings.mode === 'deep'"
                                    class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                                <i data-lucide="focus" class="w-4 h-4 mr-2 inline"></i>
                                Enter Deep Focus
                            </button>
                        </div>
                    </div>

                    <!-- Memory Pool -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold flex items-center">
                                <i data-lucide="database" class="w-5 h-5 mr-2 text-gray-400"></i>
                                Memory Pool
                            </h3>
                            <div class="flex items-center space-x-2">
                                <input type="text" 
                                       x-model="memoryPoolSearch" 
                                       @input="filterMemoryPool()"
                                       placeholder="Search..." 
                                       class="w-24 px-2 py-1 bg-white/10 border border-white/20 rounded text-xs">
                                <select x-model="memoryPoolFilter" @change="filterMemoryPool()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-xs">
                                    <option value="">All</option>
                                    <option value="high">High Priority</option>
                                    <option value="recent">Recent</option>
                                    <option value="related">Related</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="max-h-96 overflow-y-auto space-y-2" x-ref="memoryPool">
                            <template x-for="memory in filteredMemoryPool" :key="memory.memory_id">
                                <div class="memory-pool-item p-3 bg-white/5 rounded-lg cursor-move hover:bg-white/10 transition-colors"
                                     :draggable="true"
                                     @dragstart="handleMemoryDragStart($event, memory)"
                                     @click="addToWorkingMemory(memory)">
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-xs font-medium" :class="getMemoryTypeColor(memory.memory_type)" x-text="memory.memory_type"></span>
                                        <span class="text-xs text-gray-500" x-text="`${memory.importance}/10`"></span>
                                    </div>
                                    <div class="text-sm text-gray-300 line-clamp-2" x-text="memory.content"></div>
                                    <div class="flex items-center justify-between mt-2 text-xs text-gray-500">
                                        <span x-text="formatRelativeTime(memory.created_at)"></span>
                                        <div class="flex items-center space-x-1">
                                            <div class="w-2 h-2 rounded-full" :class="getAccessFrequencyColor(memory.access_count)"></div>
                                            <span x-text="`${memory.access_count || 0} acc`"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Artifact Gallery View -->
        <div x-show="dbLoaded && currentView === 'artifact-gallery'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="image" class="w-8 h-8 mr-3 text-pink-400"></i>
                        Artifact Gallery
                    </h2>
                    <p class="text-gray-400">Pinterest-style artifact browsing with preview generation and version tracking</p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <select x-model="artifactViewMode" @change="loadArtifacts()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                            <option value="masonry">Masonry Grid</option>
                            <option value="list">List View</option>
                            <option value="timeline">Timeline</option>
                        </select>
                        <select x-model="artifactTypeFilter" @change="loadArtifacts()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                            <option value="">All Types</option>
                            <option value="image">Images</option>
                            <option value="document">Documents</option>
                            <option value="code">Code</option>
                            <option value="data">Data</option>
                            <option value="model">Models</option>
                        </select>
                        <select x-model="artifactSortBy" @change="loadArtifacts()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                            <option value="created_at">Created Date</option>
                            <option value="updated_at">Updated Date</option>
                            <option value="importance">Importance</option>
                            <option value="access_count">Most Viewed</option>
                            <option value="name">Name</option>
                        </select>
                    </div>
                    <button @click="showArtifactUpload = true" 
                            class="px-4 py-2 bg-pink-600 hover:bg-pink-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="upload" class="w-4 h-4 mr-2 inline"></i>
                        Upload Artifact
                    </button>
                </div>
            </div>

            <!-- Gallery Stats -->
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-pink-400" x-text="artifactStats.total_artifacts || 0"></div>
                    <div class="text-xs text-gray-400">Total Artifacts</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="artifactStats.unique_workflows || 0"></div>
                    <div class="text-xs text-gray-400">Workflows</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-green-400" x-text="artifactStats.total_file_size_human || '0 B'"></div>
                    <div class="text-xs text-gray-400">Total Size</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-yellow-400" x-text="artifactStats.recent_artifacts_24h || 0"></div>
                    <div class="text-xs text-gray-400">Recent (24h)</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="artifactStats.total_relationships || 0"></div>
                    <div class="text-xs text-gray-400">Relationships</div>
                </div>
            </div>

            <!-- Gallery Search and Filters -->
            <div class="enhanced-card rounded-2xl p-6 mb-6">
                <div class="flex items-center space-x-4">
                    <div class="flex-1 relative">
                        <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400"></i>
                        <input type="text" 
                               x-model="artifactSearchQuery" 
                               @input.debounce.300ms="searchArtifacts()"
                               placeholder="Search artifacts by name, description, or tags..." 
                               class="w-full pl-10 pr-4 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-pink-400 transition-colors">
                    </div>
                    <div class="flex items-center space-x-2">
                        <button @click="showTagFilter = !showTagFilter" 
                                :class="{'bg-pink-600': showTagFilter, 'bg-white/10': !showTagFilter}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors hover:bg-pink-600">
                            <i data-lucide="tag" class="w-4 h-4 mr-2 inline"></i>
                            Tags
                        </button>
                        <button @click="showWorkflowFilter = !showWorkflowFilter" 
                                :class="{'bg-blue-600': showWorkflowFilter, 'bg-white/10': !showWorkflowFilter}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors hover:bg-blue-600">
                            <i data-lucide="git-branch" class="w-4 h-4 mr-2 inline"></i>
                            Workflows
                        </button>
                        <button @click="clearAllFilters()" 
                                class="px-3 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="x" class="w-4 h-4 mr-2 inline"></i>
                            Clear
                        </button>
                    </div>
                </div>

                <!-- Tag Filter Panel -->
                <div x-show="showTagFilter" 
                     x-transition:enter="transition ease-out duration-200" 
                     x-transition:enter-start="opacity-0 transform scale-95" 
                     x-transition:enter-end="opacity-100 transform scale-100"
                     class="mt-4 p-4 bg-white/5 rounded-lg">
                    <h4 class="text-sm font-medium mb-3">Filter by Tags</h4>
                    <div class="flex flex-wrap gap-2">
                        <template x-for="tag in availableTags" :key="tag">
                            <button @click="toggleTagFilter(tag)" 
                                    :class="{'bg-pink-600': selectedTags.includes(tag), 'bg-white/10': !selectedTags.includes(tag)}"
                                    class="px-3 py-1 rounded-full text-xs font-medium transition-colors hover:bg-pink-600">
                                <span x-text="tag"></span>
                            </button>
                        </template>
                    </div>
                </div>

                <!-- Workflow Filter Panel -->
                <div x-show="showWorkflowFilter" 
                     x-transition:enter="transition ease-out duration-200" 
                     x-transition:enter-start="opacity-0 transform scale-95" 
                     x-transition:enter-end="opacity-100 transform scale-100"
                     class="mt-4 p-4 bg-white/5 rounded-lg">
                    <h4 class="text-sm font-medium mb-3">Filter by Workflows</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2 max-h-32 overflow-y-auto">
                        <template x-for="workflow in availableWorkflows" :key="workflow.id">
                            <label class="flex items-center space-x-2 text-sm cursor-pointer hover:bg-white/5 p-2 rounded">
                                <input type="checkbox" 
                                       :value="workflow.id" 
                                       x-model="selectedWorkflows" 
                                       @change="loadArtifacts()"
                                       class="rounded border-gray-300">
                                <span x-text="workflow.title"></span>
                            </label>
                        </template>
                    </div>
                </div>
            </div>

            <!-- Gallery Content -->
            <div class="space-y-6">
                <!-- Masonry Grid View -->
                <div x-show="artifactViewMode === 'masonry'" class="masonry-grid" x-ref="masonryContainer">
                    <template x-for="artifact in filteredArtifacts" :key="artifact.artifact_id">
                        <div class="masonry-item enhanced-card rounded-xl overflow-hidden cursor-pointer group transform transition-all duration-300 hover:scale-105 hover:shadow-2xl"
                             @click="selectArtifact(artifact)"
                             :style="`min-height: ${getMasonryItemHeight(artifact)}px`">
                            
                            <!-- Artifact Preview -->
                            <div class="relative overflow-hidden bg-gradient-to-br from-gray-800 to-gray-900"
                                 :style="`height: ${getPreviewHeight(artifact)}px`">
                                
                                <!-- Image Preview -->
                                <template x-if="artifact.artifact_type === 'image'">
                                    <img :src="getArtifactPreview(artifact)" 
                                         :alt="artifact.name"
                                         class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
                                         @error="handleImageError($event, artifact)">
                                </template>
                                
                                <!-- Document Preview -->
                                <template x-if="artifact.artifact_type === 'document'">
                                    <div class="w-full h-full flex items-center justify-center">
                                        <div class="text-center">
                                            <i data-lucide="file-text" class="w-16 h-16 mx-auto mb-2 text-blue-400"></i>
                                            <div class="text-sm font-medium" x-text="artifact.name"></div>
                                            <div class="text-xs text-gray-400" x-text="artifact.file_size_human"></div>
                                        </div>
                                    </div>
                                </template>
                                
                                <!-- Code Preview -->
                                <template x-if="artifact.artifact_type === 'code'">
                                    <div class="w-full h-full p-4 bg-gray-900">
                                        <div class="flex items-center mb-2">
                                            <i data-lucide="code" class="w-4 h-4 mr-2 text-green-400"></i>
                                            <span class="text-xs text-green-400" x-text="getCodeLanguage(artifact)"></span>
                                        </div>
                                        <pre class="text-xs text-gray-300 overflow-hidden" x-text="getCodePreview(artifact)"></pre>
                                    </div>
                                </template>
                                
                                <!-- Default Preview -->
                                <template x-if="!['image', 'document', 'code'].includes(artifact.artifact_type)">
                                    <div class="w-full h-full flex items-center justify-center">
                                        <div class="text-center">
                                            <i :data-lucide="getArtifactIcon(artifact.artifact_type)" class="w-16 h-16 mx-auto mb-2 text-purple-400"></i>
                                            <div class="text-sm font-medium" x-text="artifact.name"></div>
                                            <div class="text-xs text-gray-400" x-text="artifact.artifact_type"></div>
                                        </div>
                                    </div>
                                </template>
                                
                                <!-- Overlay Icons -->
                                <div class="absolute top-2 right-2 flex items-center space-x-1">
                                    <template x-if="artifact.version_count > 1">
                                        <div class="bg-black/60 backdrop-blur-sm rounded-full px-2 py-1 text-xs text-white">
                                            <i data-lucide="git-branch" class="w-3 h-3 mr-1 inline"></i>
                                            <span x-text="artifact.version_count"></span>
                                        </div>
                                    </template>
                                    <template x-if="artifact.relationship_count > 0">
                                        <div class="bg-black/60 backdrop-blur-sm rounded-full px-2 py-1 text-xs text-white">
                                            <i data-lucide="link" class="w-3 h-3 mr-1 inline"></i>
                                            <span x-text="artifact.relationship_count"></span>
                                        </div>
                                    </template>
                                </div>
                                
                                <!-- Importance indicator -->
                                <div class="absolute top-2 left-2">
                                    <div class="flex">
                                        <template x-for="i in Math.round(artifact.importance * 5)" :key="i">
                                            <i data-lucide="star" class="w-3 h-3 text-yellow-400 fill-current"></i>
                                        </template>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Artifact Info -->
                            <div class="p-4">
                                <div class="flex items-start justify-between mb-2">
                                    <h3 class="font-semibold text-white line-clamp-1 flex-1 mr-2" x-text="artifact.name"></h3>
                                    <div class="flex items-center space-x-1 text-xs text-gray-400">
                                        <i data-lucide="eye" class="w-3 h-3"></i>
                                        <span x-text="artifact.access_count || 0"></span>
                                    </div>
                                </div>
                                
                                <p class="text-sm text-gray-400 line-clamp-2 mb-3" x-text="artifact.description || 'No description'"></p>
                                
                                <!-- Tags -->
                                <div class="flex flex-wrap gap-1 mb-3">
                                    <template x-for="tag in artifact.tags.slice(0, 3)" :key="tag">
                                        <span class="px-2 py-1 bg-pink-500/20 text-pink-300 rounded-full text-xs" x-text="tag"></span>
                                    </template>
                                    <template x-if="artifact.tags.length > 3">
                                        <span class="px-2 py-1 bg-gray-500/20 text-gray-400 rounded-full text-xs" x-text="`+${artifact.tags.length - 3}`"></span>
                                    </template>
                                </div>
                                
                                <!-- Metadata -->
                                <div class="flex items-center justify-between text-xs text-gray-500">
                                    <div class="flex items-center space-x-2">
                                        <span x-text="formatRelativeTime(artifact.created_at)"></span>
                                        <template x-if="artifact.workflow_title">
                                            <span class="flex items-center">
                                                <i data-lucide="git-branch" class="w-3 h-3 mr-1"></i>
                                                <span x-text="artifact.workflow_title"></span>
                                            </span>
                                        </template>
                                    </div>
                                    <div class="flex items-center space-x-1">
                                        <div :class="getArtifactTypeColor(artifact.artifact_type)" class="w-2 h-2 rounded-full"></div>
                                        <span x-text="artifact.artifact_type"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- List View -->
                <div x-show="artifactViewMode === 'list'" class="space-y-3">
                    <template x-for="artifact in filteredArtifacts" :key="artifact.artifact_id">
                        <div class="enhanced-card rounded-xl p-4 cursor-pointer group hover:bg-white/10 transition-all duration-300"
                             @click="selectArtifact(artifact)">
                            <div class="flex items-center space-x-4">
                                <!-- Preview Thumbnail -->
                                <div class="w-16 h-16 rounded-lg overflow-hidden bg-gradient-to-br from-gray-800 to-gray-900 flex-shrink-0">
                                    <template x-if="artifact.artifact_type === 'image'">
                                        <img :src="getArtifactPreview(artifact)" 
                                             :alt="artifact.name"
                                             class="w-full h-full object-cover">
                                    </template>
                                    <template x-if="artifact.artifact_type !== 'image'">
                                        <div class="w-full h-full flex items-center justify-center">
                                            <i :data-lucide="getArtifactIcon(artifact.artifact_type)" class="w-8 h-8 text-purple-400"></i>
                                        </div>
                                    </template>
                                </div>
                                
                                <!-- Artifact Info -->
                                <div class="flex-1 min-w-0">
                                    <div class="flex items-start justify-between mb-2">
                                        <h3 class="font-semibold text-white truncate mr-4" x-text="artifact.name"></h3>
                                        <div class="flex items-center space-x-2 text-xs text-gray-400 flex-shrink-0">
                                            <div class="flex">
                                                <template x-for="i in Math.round(artifact.importance * 5)" :key="i">
                                                    <i data-lucide="star" class="w-3 h-3 text-yellow-400 fill-current"></i>
                                                </template>
                                            </div>
                                            <span x-text="artifact.file_size_human"></span>
                                        </div>
                                    </div>
                                    
                                    <p class="text-sm text-gray-400 line-clamp-1 mb-2" x-text="artifact.description || 'No description'"></p>
                                    
                                    <div class="flex items-center justify-between">
                                        <div class="flex flex-wrap gap-1">
                                            <template x-for="tag in artifact.tags.slice(0, 3)" :key="tag">
                                                <span class="px-2 py-1 bg-pink-500/20 text-pink-300 rounded-full text-xs" x-text="tag"></span>
                                            </template>
                                        </div>
                                        
                                        <div class="flex items-center space-x-4 text-xs text-gray-500">
                                            <span x-text="formatRelativeTime(artifact.created_at)"></span>
                                            <span class="flex items-center">
                                                <i data-lucide="eye" class="w-3 h-3 mr-1"></i>
                                                <span x-text="artifact.access_count || 0"></span>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- Timeline View -->
                <div x-show="artifactViewMode === 'timeline'" class="space-y-6">
                    <template x-for="group in groupedArtifactsByDate" :key="group.date">
                        <div>
                            <h3 class="text-lg font-semibold mb-4 flex items-center">
                                <div class="w-3 h-3 bg-pink-400 rounded-full mr-3"></div>
                                <span x-text="group.date"></span>
                                <span class="ml-2 px-2 py-1 bg-pink-500/20 text-pink-300 rounded-full text-xs" x-text="`${group.artifacts.length} artifacts`"></span>
                            </h3>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 ml-6">
                                <template x-for="artifact in group.artifacts" :key="artifact.artifact_id">
                                    <div class="enhanced-card rounded-xl overflow-hidden cursor-pointer group transform transition-all duration-300 hover:scale-105"
                                         @click="selectArtifact(artifact)">
                                        <!-- Same content as masonry items but smaller -->
                                        <div class="relative overflow-hidden bg-gradient-to-br from-gray-800 to-gray-900 h-32">
                                            <template x-if="artifact.artifact_type === 'image'">
                                                <img :src="getArtifactPreview(artifact)" 
                                                     :alt="artifact.name"
                                                     class="w-full h-full object-cover">
                                            </template>
                                            <template x-if="artifact.artifact_type !== 'image'">
                                                <div class="w-full h-full flex items-center justify-center">
                                                    <i :data-lucide="getArtifactIcon(artifact.artifact_type)" class="w-8 h-8 text-purple-400"></i>
                                                </div>
                                            </template>
                                        </div>
                                        
                                        <div class="p-3">
                                            <h4 class="font-medium text-white line-clamp-1 mb-1" x-text="artifact.name"></h4>
                                            <div class="flex items-center justify-between text-xs text-gray-500">
                                                <span x-text="artifact.artifact_type"></span>
                                                <span x-text="formatTime(artifact.created_at)"></span>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- Load More -->
                <div x-show="hasMoreArtifacts" class="text-center py-6">
                    <button @click="loadMoreArtifacts()" 
                            :disabled="isLoadingMoreArtifacts"
                            class="px-6 py-3 bg-pink-600 hover:bg-pink-700 disabled:bg-gray-600 rounded-lg font-medium transition-colors">
                        <span x-text="isLoadingMoreArtifacts ? 'Loading...' : 'Load More Artifacts'"></span>
                    </button>
                </div>

                <!-- Empty State -->
                <div x-show="filteredArtifacts.length === 0 && !isLoadingArtifacts" class="text-center py-12">
                    <i data-lucide="image" class="w-16 h-16 mx-auto mb-4 text-gray-400 opacity-50"></i>
                    <h3 class="text-xl font-semibold mb-2">No Artifacts Found</h3>
                    <p class="text-gray-400 mb-4" x-text="artifactSearchQuery ? 'Try adjusting your search or filters' : 'Upload your first artifact to get started'"></p>
                    <button @click="showArtifactUpload = true" 
                            class="px-6 py-3 bg-pink-600 hover:bg-pink-700 rounded-lg font-medium transition-colors">
                        <i data-lucide="upload" class="w-4 h-4 mr-2 inline"></i>
                        Upload Artifact
                    </button>
                </div>
            </div>
        </div>

        <!-- Memory Quality Inspector View -->
        <div x-show="dbLoaded && currentView === 'memory-quality'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="scan-line" class="w-8 h-8 mr-3 text-red-400"></i>
                        Memory Quality Inspector
                    </h2>
                    <p class="text-gray-400">Advanced memory analysis, duplicate detection, and automated cleanup operations</p>
                </div>
                <div class="flex items-center space-x-3">
                    <button @click="runQuickQualityScan()" 
                            :disabled="isAnalyzing"
                            class="px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isAnalyzing ? 'Scanning...' : 'Quick Scan'"></span>
                    </button>
                    <button @click="showQualityAnalysisModal = true" 
                            class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="settings" class="w-4 h-4 mr-2 inline"></i>
                        Full Analysis
                    </button>
                </div>
            </div>

            <!-- Quality Overview Dashboard -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
                <div class="enhanced-card rounded-xl p-6 text-center">
                    <div class="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center mx-auto mb-3">
                        <i data-lucide="check-circle" class="w-6 h-6 text-green-400"></i>
                    </div>
                    <div class="text-2xl font-bold text-green-400" x-text="qualityStats?.overall_score || '--'"></div>
                    <div class="text-sm text-gray-400">Overall Quality Score</div>
                    <div class="mt-2 h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 rounded-full transition-all duration-1000" 
                             :style="`width: ${qualityStats?.overall_score || 0}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-6 text-center">
                    <div class="w-12 h-12 bg-yellow-500/20 rounded-xl flex items-center justify-center mx-auto mb-3">
                        <i data-lucide="copy" class="w-6 h-6 text-yellow-400"></i>
                    </div>
                    <div class="text-2xl font-bold text-yellow-400" x-text="duplicateClusters.length || 0"></div>
                    <div class="text-sm text-gray-400">Duplicate Clusters</div>
                    <div class="text-xs text-gray-500 mt-1" x-text="`${duplicateClusters.reduce((sum, c) => sum + c.duplicate_count, 0)} total duplicates`"></div>
                </div>
                
                <div class="enhanced-card rounded-xl p-6 text-center">
                    <div class="w-12 h-12 bg-orange-500/20 rounded-xl flex items-center justify-center mx-auto mb-3">
                        <i data-lucide="unlink" class="w-6 h-6 text-orange-400"></i>
                    </div>
                    <div class="text-2xl font-bold text-orange-400" x-text="orphanedMemories.length || 0"></div>
                    <div class="text-sm text-gray-400">Orphaned Memories</div>
                    <div class="text-xs text-gray-500 mt-1" x-text="`${orphanedMemories.filter(m => m.isolation_level === 'complete').length} completely isolated`"></div>
                </div>
                
                <div class="enhanced-card rounded-xl p-6 text-center">
                    <div class="w-12 h-12 bg-red-500/20 rounded-xl flex items-center justify-center mx-auto mb-3">
                        <i data-lucide="alert-triangle" class="w-6 h-6 text-red-400"></i>
                    </div>
                    <div class="text-2xl font-bold text-red-400" x-text="qualityIssues.filter(i => i.severity === 'critical').length || 0"></div>
                    <div class="text-sm text-gray-400">Critical Issues</div>
                    <div class="text-xs text-gray-500 mt-1" x-text="`${qualityIssues.length} total issues`"></div>
                </div>
            </div>

            <!-- Quality Navigation Tabs -->
            <div class="enhanced-card rounded-2xl p-6 mb-6">
                <div class="flex items-center space-x-1 mb-6">
                    <button @click="qualityViewMode = 'overview'" 
                            :class="{'bg-red-600 text-white': qualityViewMode === 'overview', 'bg-white/10 text-gray-300': qualityViewMode !== 'overview'}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="layout-dashboard" class="w-4 h-4 mr-2 inline"></i>
                        Overview
                    </button>
                    <button @click="qualityViewMode = 'issues'" 
                            :class="{'bg-red-600 text-white': qualityViewMode === 'issues', 'bg-white/10 text-gray-300': qualityViewMode !== 'issues'}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="alert-circle" class="w-4 h-4 mr-2 inline"></i>
                        Issues (<span x-text="qualityIssues.length"></span>)
                    </button>
                    <button @click="qualityViewMode = 'duplicates'" 
                            :class="{'bg-red-600 text-white': qualityViewMode === 'duplicates', 'bg-white/10 text-gray-300': qualityViewMode !== 'duplicates'}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="copy" class="w-4 h-4 mr-2 inline"></i>
                        Duplicates (<span x-text="duplicateClusters.length"></span>)
                    </button>
                    <button @click="qualityViewMode = 'orphaned'" 
                            :class="{'bg-red-600 text-white': qualityViewMode === 'orphaned', 'bg-white/10 text-gray-300': qualityViewMode !== 'orphaned'}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="unlink" class="w-4 h-4 mr-2 inline"></i>
                        Orphaned (<span x-text="orphanedMemories.length"></span>)
                    </button>
                    <button @click="qualityViewMode = 'bulk'" 
                            :class="{'bg-red-600 text-white': qualityViewMode === 'bulk', 'bg-white/10 text-gray-300': qualityViewMode !== 'bulk'}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="package" class="w-4 h-4 mr-2 inline"></i>
                        Bulk Operations
                    </button>
                </div>

                <!-- Overview Tab -->
                <div x-show="qualityViewMode === 'overview'" class="space-y-6">
                    <div x-show="qualityAnalysisResults" class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h4 class="font-semibold mb-3 flex items-center">
                                    <i data-lucide="bar-chart" class="w-5 h-5 mr-2 text-blue-400"></i>
                                    Analysis Summary
                                </h4>
                                <div class="space-y-2 text-sm">
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Total Memories:</span>
                                        <span x-text="qualityAnalysisResults?.total_memories || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Issues Found:</span>
                                        <span x-text="qualityAnalysisResults?.issues_found || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span class="text-gray-400">Analysis Time:</span>
                                        <span x-text="`${(qualityAnalysisResults?.analysis_time || 0).toFixed(2)}s`"></span>
                                    </div>
                                </div>
                            </div>
                            
                            <div>
                                <h4 class="font-semibold mb-3 flex items-center">
                                    <i data-lucide="lightbulb" class="w-5 h-5 mr-2 text-yellow-400"></i>
                                    Top Recommendations
                                </h4>
                                <div class="space-y-2">
                                    <template x-for="rec in (qualityAnalysisResults?.recommendations || []).slice(0, 3)" :key="rec">
                                        <div class="text-sm p-2 bg-yellow-500/10 border border-yellow-500/20 rounded-lg">
                                            <i data-lucide="arrow-right" class="w-3 h-3 mr-2 inline text-yellow-400"></i>
                                            <span x-text="rec"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Auto-Fix Available -->
                        <div x-show="autoFixAvailable.length > 0" class="p-4 bg-green-500/10 border border-green-500/20 rounded-lg">
                            <h4 class="font-semibold mb-2 flex items-center text-green-400">
                                <i data-lucide="zap" class="w-5 h-5 mr-2"></i>
                                Auto-Fix Available
                            </h4>
                            <p class="text-sm text-gray-300 mb-3">
                                <span x-text="autoFixAvailable.length"></span> issues can be automatically fixed.
                            </p>
                            <button @click="runAutoFix()" 
                                    class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                                <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                                Apply Auto-Fix
                            </button>
                        </div>
                    </div>
                    
                    <!-- No Analysis State -->
                    <div x-show="!qualityAnalysisResults" class="text-center py-12">
                        <i data-lucide="scan-line" class="w-16 h-16 mx-auto mb-4 text-gray-400 opacity-50"></i>
                        <h3 class="text-xl font-semibold mb-2">No Analysis Available</h3>
                        <p class="text-gray-400 mb-4">Run a quality analysis to identify issues and optimization opportunities</p>
                        <button @click="runQuickQualityScan()" 
                                class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-medium transition-colors">
                            <i data-lucide="play" class="w-4 h-4 mr-2 inline"></i>
                            Start Analysis
                        </button>
                    </div>
                </div>

                <!-- Issues Tab -->
                <div x-show="qualityViewMode === 'issues'" class="space-y-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-3">
                            <select x-model="qualityFilterType" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                <option value="all">All Severities</option>
                                <option value="critical">Critical</option>
                                <option value="high">High</option>
                                <option value="medium">Medium</option>
                                <option value="low">Low</option>
                            </select>
                            <input type="text" 
                                   x-model="qualitySearchQuery" 
                                   placeholder="Search issues..." 
                                   class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-64">
                        </div>
                        <button @click="selectAllIssues()" 
                                class="px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                            Select All
                        </button>
                    </div>
                    
                    <div class="space-y-3">
                        <template x-for="issue in filteredQualityIssues" :key="issue.issue_id">
                            <div class="p-4 bg-white/5 border border-white/10 rounded-lg hover:bg-white/10 transition-colors">
                                <div class="flex items-start justify-between">
                                    <div class="flex items-start space-x-3 flex-1">
                                        <input type="checkbox" 
                                               :value="issue.issue_id" 
                                               @change="toggleIssueSelection(issue)"
                                               class="mt-1 rounded border-gray-300">
                                        <div class="flex-1">
                                            <div class="flex items-center space-x-2 mb-2">
                                                <h4 class="font-semibold" x-text="issue.title"></h4>
                                                <span class="px-2 py-1 text-xs rounded-full" 
                                                      :class="getIssueSeverityClass(issue.severity)" 
                                                      x-text="issue.severity"></span>
                                                <template x-if="issue.auto_fixable">
                                                    <span class="px-2 py-1 bg-green-500/20 text-green-300 text-xs rounded-full">
                                                        Auto-fixable
                                                    </span>
                                                </template>
                                            </div>
                                            <p class="text-sm text-gray-400 mb-2" x-text="issue.description"></p>
                                            <p class="text-sm text-blue-300" x-text="issue.recommendation"></p>
                                            <div class="flex items-center space-x-4 mt-2 text-xs text-gray-500">
                                                <span x-text="`Impact: ${issue.impact_score.toFixed(1)}`"></span>
                                                <span x-text="`Memories: ${issue.memory_ids.length}`"></span>
                                                <template x-if="issue.estimated_savings">
                                                    <span x-text="`Savings: ${Object.entries(issue.estimated_savings).map(([k,v]) => `${k}: ${v.toFixed(0)}`).join(', ')}`"></span>
                                                </template>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex items-center space-x-2">
                                        <button @click="viewIssueDetails(issue)" 
                                                class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                            <i data-lucide="eye" class="w-4 h-4"></i>
                                        </button>
                                        <template x-if="issue.auto_fixable">
                                            <button @click="fixIssue(issue)" 
                                                    class="p-2 hover:bg-green-600 rounded-lg transition-colors text-green-400">
                                                <i data-lucide="wrench" class="w-4 h-4"></i>
                                            </button>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                    
                    <!-- Bulk Actions for Issues -->
                    <div x-show="selectedQualityIssues.size > 0" class="p-4 bg-blue-500/10 border border-blue-500/20 rounded-lg">
                        <div class="flex items-center justify-between">
                            <span class="text-sm" x-text="`${selectedQualityIssues.size} issues selected`"></span>
                            <div class="flex items-center space-x-2">
                                <button @click="bulkFixIssues()" 
                                        class="px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="wrench" class="w-4 h-4 mr-2 inline"></i>
                                    Fix Selected
                                </button>
                                <button @click="bulkIgnoreIssues()" 
                                        class="px-3 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="eye-off" class="w-4 h-4 mr-2 inline"></i>
                                    Ignore
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Duplicates Tab -->
                <div x-show="qualityViewMode === 'duplicates'" class="space-y-4">
                    <div class="space-y-3">
                        <template x-for="cluster in duplicateClusters" :key="cluster.cluster_id">
                            <div class="p-4 bg-white/5 border border-white/10 rounded-lg">
                                <div class="flex items-start justify-between mb-3">
                                    <div>
                                        <h4 class="font-semibold mb-1">
                                            Duplicate Cluster (<span x-text="cluster.duplicate_count"></span> duplicates)
                                        </h4>
                                        <p class="text-sm text-gray-400 mb-2" x-text="cluster.content_preview"></p>
                                        <div class="flex items-center space-x-4 text-xs text-gray-500">
                                            <span x-text="`Similarity: ${(cluster.similarity_score * 100).toFixed(1)}%`"></span>
                                            <span x-text="`Primary: ${cluster.primary_memory_id.substring(0, 8)}`"></span>
                                            <span x-text="`Avg Importance: ${cluster.metadata.avg_importance.toFixed(1)}`"></span>
                                        </div>
                                    </div>
                                    <div class="flex items-center space-x-2">
                                        <button @click="viewDuplicateCluster(cluster)" 
                                                class="px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                                            <i data-lucide="eye" class="w-4 h-4 mr-2 inline"></i>
                                            View
                                        </button>
                                        <button @click="mergeDuplicates(cluster)" 
                                                class="px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                                            <i data-lucide="git-merge" class="w-4 h-4 mr-2 inline"></i>
                                            Merge
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Memory List -->
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-3">
                                    <template x-for="memoryId in cluster.memory_ids" :key="memoryId">
                                        <div class="p-2 bg-white/5 rounded text-xs" 
                                             :class="{'border border-green-400': memoryId === cluster.primary_memory_id}">
                                            <div class="flex items-center justify-between">
                                                <span x-text="memoryId.substring(0, 12) + '...'"></span>
                                                <template x-if="memoryId === cluster.primary_memory_id">
                                                    <span class="px-1 py-0.5 bg-green-500/20 text-green-300 rounded text-xs">Primary</span>
                                                </template>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </template>
                    </div>
                    
                    <div x-show="duplicateClusters.length === 0" class="text-center py-8">
                        <i data-lucide="check-circle" class="w-12 h-12 mx-auto mb-3 text-green-400"></i>
                        <h3 class="text-lg font-semibold mb-2">No Duplicates Found</h3>
                        <p class="text-gray-400">Your memory system is free of duplicate content</p>
                    </div>
                </div>

                <!-- Orphaned Tab -->
                <div x-show="qualityViewMode === 'orphaned'" class="space-y-4">
                    <div class="space-y-3">
                        <template x-for="memory in orphanedMemories" :key="memory.memory_id">
                            <div class="p-4 bg-white/5 border border-white/10 rounded-lg">
                                <div class="flex items-start justify-between">
                                    <div class="flex-1">
                                        <div class="flex items-center space-x-2 mb-2">
                                            <h4 class="font-semibold" x-text="memory.memory_id.substring(0, 12) + '...'"></h4>
                                            <span class="px-2 py-1 text-xs rounded-full" 
                                                  :class="{'bg-red-500/20 text-red-300': memory.isolation_level === 'complete', 'bg-orange-500/20 text-orange-300': memory.isolation_level === 'partial'}" 
                                                  x-text="memory.isolation_level + ' isolation'"></span>
                                            <span class="px-2 py-1 bg-gray-500/20 text-gray-300 text-xs rounded-full" 
                                                  x-text="`Score: ${memory.orphan_score.toFixed(0)}`"></span>
                                        </div>
                                        <p class="text-sm text-gray-400 mb-2" x-text="memory.content.substring(0, 150) + (memory.content.length > 150 ? '...' : '')"></p>
                                        <div class="flex items-center space-x-4 text-xs text-gray-500">
                                            <span x-text="`Type: ${memory.memory_type}`"></span>
                                            <span x-text="`Level: ${memory.memory_level}`"></span>
                                            <span x-text="`Importance: ${memory.importance}`"></span>
                                            <span x-text="`Created: ${formatRelativeTime(memory.created_at)}`"></span>
                                        </div>
                                    </div>
                                    <div class="flex items-center space-x-2">
                                        <button @click="viewMemoryDetails(memory)" 
                                                class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                            <i data-lucide="eye" class="w-4 h-4"></i>
                                        </button>
                                        <button @click="connectOrphanedMemory(memory)" 
                                                class="p-2 hover:bg-blue-600 rounded-lg transition-colors text-blue-400">
                                            <i data-lucide="link" class="w-4 h-4"></i>
                                        </button>
                                        <button @click="archiveOrphanedMemory(memory)" 
                                                class="p-2 hover:bg-yellow-600 rounded-lg transition-colors text-yellow-400">
                                            <i data-lucide="archive" class="w-4 h-4"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                    
                    <div x-show="orphanedMemories.length === 0" class="text-center py-8">
                        <i data-lucide="check-circle" class="w-12 h-12 mx-auto mb-3 text-green-400"></i>
                        <h3 class="text-lg font-semibold mb-2">No Orphaned Memories</h3>
                        <p class="text-gray-400">All memories are properly connected to workflows and relationships</p>
                    </div>
                </div>

                <!-- Bulk Operations Tab -->
                <div x-show="qualityViewMode === 'bulk'" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-3">Operation Type</h4>
                            <div class="space-y-2">
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" x-model="bulkOperationType" value="delete" class="text-red-600">
                                    <span>Delete Memories</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" x-model="bulkOperationType" value="archive" class="text-yellow-600">
                                    <span>Archive Memories</span>
                                </label>
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="radio" x-model="bulkOperationType" value="merge" class="text-blue-600">
                                    <span>Merge Memories</span>
                                </label>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Selected Memories</h4>
                            <div class="text-sm text-gray-400">
                                <span x-text="selectedMemoriesForBulk.size"></span> memories selected
                            </div>
                            <button @click="clearBulkSelection()" 
                                    class="mt-2 px-3 py-1 bg-gray-600 hover:bg-gray-700 rounded text-sm transition-colors">
                                Clear Selection
                            </button>
                        </div>
                    </div>
                    
                    <div x-show="selectedMemoriesForBulk.size > 0" class="space-y-4">
                        <button @click="previewBulkOperation()" 
                                class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition-colors">
                            <i data-lucide="eye" class="w-4 h-4 mr-2 inline"></i>
                            Preview Operation
                        </button>
                        
                        <!-- Bulk Operation Preview -->
                        <div x-show="bulkOperationPreview" class="p-4 bg-yellow-500/10 border border-yellow-500/20 rounded-lg">
                            <h4 class="font-semibold mb-3 text-yellow-400">Operation Preview</h4>
                            <div class="space-y-2 text-sm">
                                <div class="flex justify-between">
                                    <span>Operation:</span>
                                    <span x-text="bulkOperationPreview?.operation_type"></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Memories Affected:</span>
                                    <span x-text="bulkOperationPreview?.memory_ids.length"></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Reversible:</span>
                                    <span x-text="bulkOperationPreview?.reversible ? 'Yes' : 'No'"></span>
                                </div>
                            </div>
                            
                            <div class="mt-4 space-y-2">
                                <template x-for="change in (bulkOperationPreview?.preview_changes || []).slice(0, 5)" :key="change.memory_id">
                                    <div class="p-2 bg-white/5 rounded text-xs">
                                        <div class="flex items-center justify-between">
                                            <span x-text="change.memory_id.substring(0, 12) + '...'"></span>
                                            <span x-text="change.action"></span>
                                        </div>
                                        <div class="text-gray-400 mt-1" x-text="change.impact"></div>
                                    </div>
                                </template>
                            </div>
                            
                            <div class="mt-4 flex items-center space-x-3">
                                <button @click="executeBulkOperation()" 
                                        class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg font-medium transition-colors">
                                    <i data-lucide="play" class="w-4 h-4 mr-2 inline"></i>
                                    Execute Operation
                                </button>
                                <button @click="bulkOperationPreview = null" 
                                        class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-medium transition-colors">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Enhanced modals -->
         <div x-show="showWorkflowModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showWorkflowModal = false">
        <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
             x-transition:enter="transition ease-out duration-300" 
             x-transition:enter-start="opacity-0 scale-95" 
             x-transition:enter-end="opacity-100 scale-100"
             x-transition:leave="transition ease-in duration-200" 
             x-transition:leave-start="opacity-100 scale-100" 
             x-transition:leave-end="opacity-0 scale-95"
             @click.stop="">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-2xl font-bold">Workflow Details</h3>
                    <button @click="showWorkflowModal = false" 
                            class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div x-show="selectedWorkflow" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-3">Basic Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Title:</span> <span x-text="selectedWorkflow?.title"></span></div>
                                <div><span class="text-gray-400">Status:</span> 
                                    <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                          :class="getWorkflowStatusClass(selectedWorkflow?.status)" 
                                          x-text="selectedWorkflow?.status"></span>
                                </div>
                                <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedWorkflow?.created_at)"></span></div>
                                <div><span class="text-gray-400">Updated:</span> <span x-text="formatDate(selectedWorkflow?.updated_at)"></span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Metrics</h4>
                            <div class="grid grid-cols-3 gap-4">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-blue-400" x-text="selectedWorkflow?.action_count || 0"></div>
                                    <div class="text-xs text-gray-400">Actions</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-green-400" x-text="selectedWorkflow?.memory_count || 0"></div>
                                    <div class="text-xs text-gray-400">Memories</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-purple-400" x-text="selectedWorkflow?.artifact_count || 0"></div>
                                    <div class="text-xs text-gray-400">Artifacts</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold mb-3">Description</h4>
                        <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedWorkflow?.description || selectedWorkflow?.goal || 'No description available'"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Quality Analysis Settings Modal -->
    <div x-show="showQualityAnalysisModal" 
         x-transition:enter="transition ease-out duration-300" 
         x-transition:enter-start="opacity-0" 
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-200" 
         x-transition:leave-start="opacity-100" 
         x-transition:leave-end="opacity-0"
         class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
         @click="showQualityAnalysisModal = false">
        <div class="enhanced-card rounded-2xl max-w-2xl w-full" 
             x-transition:enter="transition ease-out duration-300" 
             x-transition:enter-start="opacity-0 scale-95" 
             x-transition:enter-end="opacity-100 scale-100"
             x-transition:leave="transition ease-in duration-200" 
             x-transition:leave-start="opacity-100 scale-100" 
             x-transition:leave-end="opacity-0 scale-95"
             @click.stop="">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-2xl font-bold flex items-center">
                        <i data-lucide="settings" class="w-6 h-6 mr-3 text-red-400"></i>
                        Quality Analysis Settings
                    </h3>
                    <button @click="showQualityAnalysisModal = false" 
                            class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium mb-2">Analysis Type</label>
                            <select x-model="qualityAnalysisSettings.analysisType" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2">
                                <option value="comprehensive">Comprehensive Analysis</option>
                                <option value="duplicates">Duplicates Only</option>
                                <option value="orphaned">Orphaned Memories Only</option>
                                <option value="low_quality">Quality Issues Only</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2">Similarity Threshold</label>
                            <input type="range" 
                                   x-model="qualityAnalysisSettings.similarityThreshold" 
                                   min="0.5" max="1.0" step="0.05"
                                   class="w-full">
                            <div class="text-xs text-gray-400 mt-1" x-text="`${(qualityAnalysisSettings.similarityThreshold * 100).toFixed(0)}% similarity`"></div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" x-model="qualityAnalysisSettings.includeStale" class="rounded">
                                <span class="text-sm">Include Stale Memories</span>
                            </label>
                        </div>
                        
                        <div>
                            <label class="flex items-center space-x-2">
                                <input type="checkbox" x-model="qualityAnalysisSettings.includeLowImportance" class="rounded">
                                <span class="text-sm">Include Low Importance</span>
                            </label>
                        </div>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium mb-2">Stale Threshold (Days)</label>
                        <input type="number" 
                               x-model="qualityAnalysisSettings.staleThresholdDays" 
                               min="1" max="365"
                               class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2">
                    </div>
                    
                    <div class="flex items-center justify-end space-x-3">
                        <button @click="showQualityAnalysisModal = false" 
                                class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg font-medium transition-colors">
                            Cancel
                        </button>
                        <button @click="runFullQualityAnalysis()" 
                                :disabled="isAnalyzing"
                                class="px-4 py-2 bg-red-600 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-medium transition-colors">
                            <i data-lucide="play" class="w-4 h-4 mr-2 inline"></i>
                            <span x-text="isAnalyzing ? 'Analyzing...' : 'Start Analysis'"></span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

         <div x-show="showMemoryModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showMemoryModal = false">
        <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
             x-transition:enter="transition ease-out duration-300" 
             x-transition:enter-start="opacity-0 scale-95" 
             x-transition:enter-end="opacity-100 scale-100"
             x-transition:leave="transition ease-in duration-200" 
             x-transition:leave-start="opacity-100 scale-100" 
             x-transition:leave-end="opacity-0 scale-95"
             @click.stop="">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-2xl font-bold">Memory Details</h3>
                    <button @click="showMemoryModal = false" 
                            class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div x-show="selectedMemory" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-3">Memory Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Level:</span> 
                                    <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                          :class="getMemoryLevelClass(selectedMemory?.memory_level)" 
                                          x-text="selectedMemory?.memory_level"></span>
                                </div>
                                <div><span class="text-gray-400">Type:</span> <span x-text="selectedMemory?.memory_type"></span></div>
                                <div><span class="text-gray-400">Importance:</span> <span x-text="selectedMemory?.importance + '/10'"></span></div>
                                <div><span class="text-gray-400">Confidence:</span> <span x-text="Math.round((selectedMemory?.confidence || 0) * 100) + '%'"></span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Access Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedMemory?.created_at)"></span></div>
                                <div><span class="text-gray-400">Last Access:</span> <span x-text="formatDate(selectedMemory?.last_accessed_at)"></span></div>
                                <div><span class="text-gray-400">Access Count:</span> <span x-text="selectedMemory?.access_count || 0"></span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold mb-3">Content</h4>
                        <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                            <pre class="text-sm whitespace-pre-wrap" x-text="selectedMemory?.content"></pre>
                        </div>
                    </div>
                    
                    <div x-show="selectedMemory?.description">
                        <h4 class="font-semibold mb-3">Description</h4>
                        <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedMemory?.description"></p>
                    </div>
                </div>
            </div>
                 </div>
     </div>

     <div x-show="showActionModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showActionModal = false">
         <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold">Action Details</h3>
                     <button @click="showActionModal = false" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <div x-show="selectedAction" class="space-y-6">
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                         <div>
                             <h4 class="font-semibold mb-3">Action Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Type:</span> <span x-text="selectedAction?.action_type"></span></div>
                                 <div><span class="text-gray-400">Status:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                           :class="getActionStatusClass(selectedAction?.status)" 
                                           x-text="selectedAction?.status"></span>
                                 </div>
                                 <div x-show="selectedAction?.tool_name"><span class="text-gray-400">Tool:</span> <span x-text="selectedAction?.tool_name"></span></div>
                                 <div><span class="text-gray-400">Duration:</span> <span x-text="formatDuration(selectedAction?.started_at, selectedAction?.completed_at)"></span></div>
                             </div>
                         </div>
                         
                         <div>
                             <h4 class="font-semibold mb-3">Timing Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Started:</span> <span x-text="formatDate(selectedAction?.started_at)"></span></div>
                                 <div x-show="selectedAction?.completed_at"><span class="text-gray-400">Completed:</span> <span x-text="formatDate(selectedAction?.completed_at)"></span></div>
                                 <div x-show="selectedAction?.workflow_id"><span class="text-gray-400">Workflow:</span> <span x-text="selectedAction?.workflow_id?.substring(0, 8) + '...'"></span></div>
                             </div>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.reasoning">
                         <h4 class="font-semibold mb-3">Reasoning</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <p class="text-sm whitespace-pre-wrap" x-text="selectedAction?.reasoning"></p>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.tool_args">
                         <h4 class="font-semibold mb-3">Tool Arguments</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <pre class="text-sm" x-text="JSON.stringify(JSON.parse(selectedAction?.tool_args || '{}'), null, 2)"></pre>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.tool_result">
                         <h4 class="font-semibold mb-3">Tool Result</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <pre class="text-sm" x-text="JSON.stringify(JSON.parse(selectedAction?.tool_result || '{}'), null, 2)"></pre>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.summary">
                         <h4 class="font-semibold mb-3">Summary</h4>
                         <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedAction?.summary"></p>
                     </div>
                 </div>
             </div>
         </div>
     </div>

     <!-- Goal Modal -->
     <div x-show="showGoalModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showGoalModal = false">
         <div class="enhanced-card rounded-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold" x-text="editingGoal ? 'Edit Goal' : 'Create New Goal'"></h3>
                     <button @click="showGoalModal = false; editingGoal = null" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <form @submit.prevent="saveGoal()" class="space-y-4">
                     <div>
                         <label class="block text-sm font-medium mb-2">Title *</label>
                         <input type="text" 
                                x-model="goalForm.title" 
                                required 
                                class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                placeholder="Enter goal title">
                     </div>
                     
                     <div>
                         <label class="block text-sm font-medium mb-2">Description</label>
                         <textarea x-model="goalForm.description" 
                                   rows="3"
                                   class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                   placeholder="Describe the goal in detail"></textarea>
                     </div>
                     
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                             <label class="block text-sm font-medium mb-2">Priority</label>
                             <select x-model="goalForm.priority" 
                                     class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                                 <option value="low">Low</option>
                                 <option value="medium">Medium</option>
                                 <option value="high">High</option>
                             </select>
                         </div>
                         
                         <div>
                             <label class="block text-sm font-medium mb-2">Status</label>
                             <select x-model="goalForm.status" 
                                     class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                                 <option value="pending">Pending</option>
                                 <option value="active">Active</option>
                                 <option value="in_progress">In Progress</option>
                                 <option value="completed">Completed</option>
                                 <option value="cancelled">Cancelled</option>
                             </select>
                         </div>
                     </div>
                     
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                             <label class="block text-sm font-medium mb-2">Progress (%)</label>
                             <input type="number" 
                                    x-model.number="goalForm.progress" 
                                    min="0" 
                                    max="100"
                                    class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors">
                         </div>
                         
                         <div>
                             <label class="block text-sm font-medium mb-2">Due Date</label>
                             <input type="date" 
                                    x-model="goalForm.due_date"
                                    class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors">
                         </div>
                     </div>
                     
                     <div x-show="!editingGoal">
                         <label class="block text-sm font-medium mb-2">Parent Goal</label>
                         <select x-model="goalForm.parent_goal_id" 
                                 class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                             <option value="">None (Root Goal)</option>
                             <template x-for="goal in goals.filter(g => g.goal_id !== editingGoal?.goal_id)" :key="goal.goal_id">
                                 <option :value="goal.goal_id" x-text="goal.title"></option>
                             </template>
                         </select>
                     </div>
                     
                     <div x-show="editingGoal">
                         <label class="block text-sm font-medium mb-2">Notes</label>
                         <textarea x-model="goalForm.notes" 
                                   rows="2"
                                   class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                   placeholder="Add any updates or notes"></textarea>
                     </div>
                     
                     <div class="flex items-center justify-end space-x-3 pt-4 border-t border-white/10">
                         <button type="button" 
                                 @click="showGoalModal = false; editingGoal = null"
                                 class="px-4 py-2 text-gray-400 hover:text-white transition-colors">
                             Cancel
                         </button>
                         <button type="submit" 
                                 class="px-6 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-medium transition-colors">
                             <span x-text="editingGoal ? 'Update Goal' : 'Create Goal'"></span>
                         </button>
                     </div>
                 </form>
             </div>
         </div>
     </div>

     <!-- Thought Modal -->
     <div x-show="showThoughtModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showThoughtModal = false">
         <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold">Thought Details</h3>
                     <button @click="showThoughtModal = false" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <div x-show="selectedThought" class="space-y-6">
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                         <div>
                             <h4 class="font-semibold mb-3">Thought Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Type:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2 bg-indigo-500/20 text-indigo-400" 
                                           x-text="selectedThought?.memory_type"></span>
                                 </div>
                                 <div><span class="text-gray-400">Level:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                           :class="getMemoryLevelClass(selectedThought?.memory_level)" 
                                           x-text="selectedThought?.memory_level"></span>
                                 </div>
                                 <div><span class="text-gray-400">Importance:</span> <span x-text="selectedThought?.importance + '/10'"></span></div>
                                 <div><span class="text-gray-400">Confidence:</span> <span x-text="Math.round((selectedThought?.confidence || 0) * 100) + '%'"></span></div>
                             </div>
                         </div>
                         
                         <div>
                             <h4 class="font-semibold mb-3">Chain Context</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Position:</span> <span x-text="`${currentThoughtIndex + 1} of ${thoughtsInCurrentChain.length}`"></span></div>
                                 <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedThought?.created_at)"></span></div>
                                 <div x-show="selectedThought?.workflow_id"><span class="text-gray-400">Workflow:</span> <span x-text="selectedThought?.workflow_id?.substring(0, 8) + '...'"></span></div>
                                 <div x-show="selectedThought?.hasChildren">
                                     <span class="text-gray-400">Branches:</span> 
                                     <span class="text-purple-400">Yes</span>
                                 </div>
                             </div>
                         </div>
                     </div>
                     
                     <div>
                         <h4 class="font-semibold mb-3">Thought Content</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <p class="text-sm whitespace-pre-wrap" x-text="selectedThought?.content"></p>
                         </div>
                     </div>
                     
                     <div x-show="selectedThought?.description">
                         <h4 class="font-semibold mb-3">Description</h4>
                         <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedThought?.description"></p>
                     </div>
                     
                     <!-- Chain Navigation in Modal -->
                     <div class="grid grid-cols-2 gap-4">
                         <button @click="navigateToPreviousThought()" 
                                 :disabled="currentThoughtIndex === 0"
                                 class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 rounded-lg text-sm font-medium transition-colors flex items-center justify-center">
                             <i data-lucide="chevron-left" class="w-4 h-4 mr-2"></i>
                             Previous Thought
                         </button>
                         <button @click="navigateToNextThought()" 
                                 :disabled="currentThoughtIndex === thoughtsInCurrentChain.length - 1"
                                 class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 rounded-lg text-sm font-medium transition-colors flex items-center justify-center">
                             Next Thought
                             <i data-lucide="chevron-right" class="w-4 h-4 ml-2"></i>
                         </button>
                     </div>
                 </div>
             </div>
         </div>
     </div>

     <!-- Artifact Modal -->
     <div x-show="showArtifactModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showArtifactModal = false">
         <div class="enhanced-card rounded-2xl max-w-6xl w-full max-h-[95vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <!-- Header -->
                 <div class="flex items-start justify-between mb-6">
                     <div class="flex items-center space-x-4">
                         <div class="w-16 h-16 rounded-xl overflow-hidden bg-gradient-to-br from-gray-800 to-gray-900 flex-shrink-0">
                             <template x-if="selectedArtifact?.artifact_type === 'image'">
                                 <img :src="getArtifactPreview(selectedArtifact)" 
                                      :alt="selectedArtifact?.name"
                                      class="w-full h-full object-cover">
                             </template>
                             <template x-if="selectedArtifact?.artifact_type !== 'image'">
                                 <div class="w-full h-full flex items-center justify-center">
                                     <i :data-lucide="getArtifactIcon(selectedArtifact?.artifact_type)" class="w-8 h-8 text-pink-400"></i>
                                 </div>
                             </template>
                         </div>
                         <div>
                             <h3 class="text-2xl font-bold text-white" x-text="selectedArtifact?.name"></h3>
                             <div class="flex items-center space-x-3 mt-1">
                                 <span class="px-2 py-1 text-xs rounded-full" 
                                       :class="getArtifactTypeColor(selectedArtifact?.artifact_type)"
                                       x-text="selectedArtifact?.artifact_type"></span>
                                 <div class="flex items-center space-x-1 text-sm text-gray-400">
                                     <template x-for="i in Math.round((selectedArtifact?.importance || 0) * 5)" :key="i">
                                         <i data-lucide="star" class="w-3 h-3 text-yellow-400 fill-current"></i>
                                     </template>
                                 </div>
                                 <span class="text-sm text-gray-400" x-text="selectedArtifact?.file_size_human"></span>
                             </div>
                         </div>
                     </div>
                     <div class="flex items-center space-x-2">
                         <button @click="downloadArtifact(selectedArtifact)" 
                                 class="p-2 rounded-lg hover:bg-white/10 transition-colors" 
                                 title="Download">
                             <i data-lucide="download" class="w-5 h-5"></i>
                         </button>
                         <button @click="shareArtifact(selectedArtifact)" 
                                 class="p-2 rounded-lg hover:bg-white/10 transition-colors" 
                                 title="Share">
                             <i data-lucide="share" class="w-5 h-5"></i>
                         </button>
                         <button @click="showArtifactModal = false" 
                                 class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                             <i data-lucide="x" class="w-5 h-5"></i>
                         </button>
                     </div>
                 </div>

                 <!-- Content Tabs -->
                 <div x-show="selectedArtifact" class="space-y-6">
                     <div class="flex items-center space-x-1 border-b border-white/10">
                         <button @click="artifactModalTab = 'content'" 
                                 :class="{'bg-pink-600 text-white': artifactModalTab === 'content', 'bg-white/10 text-gray-300': artifactModalTab !== 'content'}"
                                 class="px-4 py-2 rounded-t-lg text-sm font-medium transition-colors">
                             <i data-lucide="file-text" class="w-4 h-4 mr-2 inline"></i>
                             Content
                         </button>
                         <button @click="artifactModalTab = 'metadata'" 
                                 :class="{'bg-pink-600 text-white': artifactModalTab === 'metadata', 'bg-white/10 text-gray-300': artifactModalTab !== 'metadata'}"
                                 class="px-4 py-2 rounded-t-lg text-sm font-medium transition-colors">
                             <i data-lucide="info" class="w-4 h-4 mr-2 inline"></i>
                             Details
                         </button>
                         <button @click="artifactModalTab = 'versions'" 
                                 :class="{'bg-pink-600 text-white': artifactModalTab === 'versions', 'bg-white/10 text-gray-300': artifactModalTab !== 'versions'}"
                                 class="px-4 py-2 rounded-t-lg text-sm font-medium transition-colors">
                             <i data-lucide="git-branch" class="w-4 h-4 mr-2 inline"></i>
                             Versions
                         </button>
                         <button @click="artifactModalTab = 'relationships'" 
                                 :class="{'bg-pink-600 text-white': artifactModalTab === 'relationships', 'bg-white/10 text-gray-300': artifactModalTab !== 'relationships'}"
                                 class="px-4 py-2 rounded-t-lg text-sm font-medium transition-colors">
                             <i data-lucide="link" class="w-4 h-4 mr-2 inline"></i>
                             Links
                         </button>
                     </div>

                     <!-- Content Tab -->
                     <div x-show="artifactModalTab === 'content'" class="space-y-4">
                         <!-- Image Display -->
                         <template x-if="selectedArtifact?.artifact_type === 'image'">
                             <div class="bg-white/5 rounded-xl p-4">
                                 <img :src="getArtifactPreview(selectedArtifact)" 
                                      :alt="selectedArtifact?.name"
                                      class="max-w-full h-auto rounded-lg shadow-lg mx-auto">
                             </div>
                         </template>

                         <!-- Document/Markdown Display -->
                         <template x-if="selectedArtifact?.artifact_type === 'document' || selectedArtifact?.content">
                             <div class="bg-white/5 rounded-xl p-6">
                                 <div class="markdown-content" x-html="renderMarkdownContent(selectedArtifact)"></div>
                             </div>
                         </template>

                         <!-- Code Display -->
                         <template x-if="selectedArtifact?.artifact_type === 'code'">
                             <div class="bg-white/5 rounded-xl overflow-hidden">
                                 <div class="flex items-center justify-between p-4 border-b border-white/10">
                                     <div class="flex items-center space-x-2">
                                         <i data-lucide="code" class="w-4 h-4 text-green-400"></i>
                                         <span class="text-sm font-medium" x-text="getCodeLanguage(selectedArtifact)"></span>
                                     </div>
                                     <button @click="copyCodeToClipboard(selectedArtifact)" 
                                             class="px-3 py-1 bg-white/10 hover:bg-white/20 rounded text-xs font-medium transition-colors">
                                         <i data-lucide="copy" class="w-3 h-3 mr-1 inline"></i>
                                         Copy
                                     </button>
                                 </div>
                                 <pre class="p-4 overflow-x-auto"><code x-text="getFullCodeContent(selectedArtifact)" class="text-sm"></code></pre>
                             </div>
                         </template>

                         <!-- Data Preview -->
                         <template x-if="selectedArtifact?.artifact_type === 'data'">
                             <div class="bg-white/5 rounded-xl p-6">
                                 <div class="space-y-4">
                                     <div class="flex items-center justify-between">
                                         <h4 class="font-semibold text-purple-400">Data Preview</h4>
                                         <span class="text-xs text-gray-400" x-text="`${selectedArtifact?.metadata?.records || 'N/A'} records`"></span>
                                     </div>
                                     <div class="bg-black/20 rounded-lg p-4 overflow-x-auto">
                                         <pre class="text-xs text-gray-300" x-text="getDataPreview(selectedArtifact)"></pre>
                                     </div>
                                 </div>
                             </div>
                         </template>

                         <!-- Default Content Display -->
                         <template x-if="!['image', 'document', 'code', 'data'].includes(selectedArtifact?.artifact_type) && selectedArtifact?.description">
                             <div class="bg-white/5 rounded-xl p-6">
                                 <div class="markdown-content" x-html="renderMarkdownContent({ content: selectedArtifact?.description })"></div>
                             </div>
                         </template>

                         <!-- Empty Content State -->
                         <div x-show="!selectedArtifact?.content && !selectedArtifact?.description && selectedArtifact?.artifact_type !== 'image'" 
                              class="text-center py-12">
                             <i data-lucide="file-x" class="w-16 h-16 mx-auto mb-4 text-gray-400 opacity-50"></i>
                             <h3 class="text-lg font-semibold mb-2">No Content Available</h3>
                             <p class="text-gray-400">This artifact doesn't have readable content or preview.</p>
                         </div>
                     </div>

                     <!-- Metadata Tab -->
                     <div x-show="artifactModalTab === 'metadata'" class="space-y-6">
                         <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                             <div class="space-y-4">
                                 <h4 class="font-semibold text-pink-400 flex items-center">
                                     <i data-lucide="info" class="w-5 h-5 mr-2"></i>
                                     Basic Information
                                 </h4>
                                 <div class="bg-white/5 rounded-xl p-4 space-y-3">
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Name:</span>
                                         <span x-text="selectedArtifact?.name"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Type:</span>
                                         <span x-text="selectedArtifact?.artifact_type"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Size:</span>
                                         <span x-text="selectedArtifact?.file_size_human"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Created:</span>
                                         <span x-text="formatDate(selectedArtifact?.created_at)"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Modified:</span>
                                         <span x-text="formatDate(selectedArtifact?.updated_at)"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Importance:</span>
                                         <span x-text="selectedArtifact?.importance + '/10'"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Access Count:</span>
                                         <span x-text="selectedArtifact?.access_count || 0"></span>
                                     </div>
                                 </div>
                             </div>

                             <div class="space-y-4">
                                 <h4 class="font-semibold text-pink-400 flex items-center">
                                     <i data-lucide="git-branch" class="w-5 h-5 mr-2"></i>
                                     Workflow & Context
                                 </h4>
                                 <div class="bg-white/5 rounded-xl p-4 space-y-3">
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Workflow:</span>
                                         <span x-text="selectedArtifact?.workflow_title || 'N/A'"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Creator:</span>
                                         <span x-text="selectedArtifact?.created_by || 'System'"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Source:</span>
                                         <span x-text="selectedArtifact?.source || 'N/A'"></span>
                                     </div>
                                     <div class="flex justify-between text-sm">
                                         <span class="text-gray-400">Status:</span>
                                         <span class="px-2 py-1 text-xs rounded-full bg-green-500/20 text-green-400">Active</span>
                                     </div>
                                 </div>
                             </div>
                         </div>

                         <!-- Description -->
                         <div x-show="selectedArtifact?.description">
                             <h4 class="font-semibold text-pink-400 mb-3 flex items-center">
                                 <i data-lucide="file-text" class="w-5 h-5 mr-2"></i>
                                 Description
                             </h4>
                             <div class="bg-white/5 rounded-xl p-4">
                                 <p class="text-gray-300" x-text="selectedArtifact?.description"></p>
                             </div>
                         </div>

                         <!-- Tags -->
                         <div x-show="selectedArtifact?.tags?.length > 0">
                             <h4 class="font-semibold text-pink-400 mb-3 flex items-center">
                                 <i data-lucide="tag" class="w-5 h-5 mr-2"></i>
                                 Tags
                             </h4>
                             <div class="flex flex-wrap gap-2">
                                 <template x-for="tag in selectedArtifact?.tags" :key="tag">
                                     <span class="px-3 py-1 bg-pink-500/20 text-pink-300 rounded-full text-sm" x-text="tag"></span>
                                 </template>
                             </div>
                         </div>

                         <!-- Technical Metadata -->
                         <div x-show="selectedArtifact?.metadata">
                             <h4 class="font-semibold text-pink-400 mb-3 flex items-center">
                                 <i data-lucide="settings" class="w-5 h-5 mr-2"></i>
                                 Technical Details
                             </h4>
                             <div class="bg-white/5 rounded-xl p-4">
                                 <pre class="text-sm text-gray-300 overflow-x-auto" x-text="JSON.stringify(selectedArtifact?.metadata || {}, null, 2)"></pre>
                             </div>
                         </div>
                     </div>

                     <!-- Versions Tab -->
                     <div x-show="artifactModalTab === 'versions'" class="space-y-4">
                         <div class="flex items-center justify-between">
                             <h4 class="font-semibold text-pink-400 flex items-center">
                                 <i data-lucide="git-branch" class="w-5 h-5 mr-2"></i>
                                 Version History
                             </h4>
                             <span class="text-sm text-gray-400" x-text="`${selectedArtifact?.version_count || 1} versions`"></span>
                         </div>

                         <div class="space-y-3">
                             <!-- Current Version -->
                             <div class="bg-white/5 rounded-xl p-4 border border-pink-500/30">
                                 <div class="flex items-center justify-between mb-2">
                                     <div class="flex items-center space-x-3">
                                         <span class="px-2 py-1 bg-pink-500/20 text-pink-300 rounded text-xs font-medium">CURRENT</span>
                                         <span class="font-medium">v1.0</span>
                                     </div>
                                     <span class="text-sm text-gray-400" x-text="formatRelativeTime(selectedArtifact?.updated_at)"></span>
                                 </div>
                                 <p class="text-sm text-gray-400">Latest version</p>
                             </div>

                             <!-- Previous Versions (placeholder) -->
                             <div class="text-center py-8">
                                 <i data-lucide="git-branch" class="w-12 h-12 mx-auto mb-3 text-gray-400 opacity-50"></i>
                                 <h3 class="text-lg font-semibold mb-2">No Previous Versions</h3>
                                 <p class="text-gray-400">This is the first version of this artifact.</p>
                             </div>
                         </div>
                     </div>

                     <!-- Relationships Tab -->
                     <div x-show="artifactModalTab === 'relationships'" class="space-y-4">
                         <div class="flex items-center justify-between">
                             <h4 class="font-semibold text-pink-400 flex items-center">
                                 <i data-lucide="link" class="w-5 h-5 mr-2"></i>
                                 Related Items
                             </h4>
                             <span class="text-sm text-gray-400" x-text="`${selectedArtifact?.relationship_count || 0} connections`"></span>
                         </div>

                         <!-- Related Memories -->
                         <div class="bg-white/5 rounded-xl p-4">
                             <h5 class="font-medium mb-3 flex items-center">
                                 <i data-lucide="brain" class="w-4 h-4 mr-2 text-blue-400"></i>
                                 Related Memories
                             </h5>
                             <div class="space-y-2">
                                 <div class="text-center py-6">
                                     <i data-lucide="brain" class="w-8 h-8 mx-auto mb-2 text-gray-400 opacity-50"></i>
                                     <p class="text-sm text-gray-400">No related memories found</p>
                                 </div>
                             </div>
                         </div>

                         <!-- Related Workflows -->
                         <div class="bg-white/5 rounded-xl p-4">
                             <h5 class="font-medium mb-3 flex items-center">
                                 <i data-lucide="git-branch" class="w-4 h-4 mr-2 text-green-400"></i>
                                 Related Workflows
                             </h5>
                             <div x-show="selectedArtifact?.workflow_title" class="space-y-2">
                                 <div class="flex items-center justify-between p-3 bg-white/5 rounded-lg">
                                     <div class="flex items-center space-x-3">
                                         <i data-lucide="git-branch" class="w-4 h-4 text-green-400"></i>
                                         <span class="text-sm" x-text="selectedArtifact?.workflow_title"></span>
                                     </div>
                                     <button class="text-xs text-blue-400 hover:text-blue-300">View</button>
                                 </div>
                             </div>
                             <div x-show="!selectedArtifact?.workflow_title" class="text-center py-6">
                                 <i data-lucide="git-branch" class="w-8 h-8 mx-auto mb-2 text-gray-400 opacity-50"></i>
                                 <p class="text-sm text-gray-400">No related workflows found</p>
                             </div>
                         </div>
                     </div>
                 </div>
             </div>
         </div>
     </div>
 
     <!-- Floating Action Button -->
    <button class="fab" @click="showCommandPalette = true" title="Open Command Palette (Ctrl+K)">
        <i data-lucide="command" class="w-6 h-6"></i>
    </button>

    <script>
        // Initialize SQL.js
        let SQL;
        
        async function initializeSqlJs() {
            try {
                if (typeof initSqlJs === 'undefined') {
                    throw new Error('SQL.js library not loaded. Please check your internet connection.');
                }
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                });
                console.log(' SQL.js initialized successfully');
            } catch (error) {
                console.error(' Failed to initialize SQL.js:', error);
                throw error;
            }
        }

        function umsExplorer() {
            return {
                // Core state
                db: null,
                dbLoaded: false,
                isLoading: false,
                isProcessing: false,
                loadingMessage: '',
                currentView: 'dashboard',
                theme: 'dark',
                
                // Navigation and UI
                showCommandPalette: false,
                showSearchSuggestions: false,
                commandQuery: '',
                filteredCommands: [],
                
                // Search
                globalSearch: '',
                searchSuggestions: [],
                
                // Data
                workflows: [],
                memories: [],
                actions: [],
                artifacts: [],
                goals: [],

                // Artifact Gallery state
                artifactViewMode: 'masonry',
                artifactTypeFilter: '',
                artifactSortBy: 'created_at',
                artifactSortOrder: 'desc',
                artifactSearchQuery: '',
                filteredArtifacts: [],
                artifactStats: {
                    total_artifacts: 0,
                    unique_workflows: 0,
                    total_file_size_human: '0 B',
                    recent_artifacts_24h: 0,
                    total_relationships: 0
                },
                selectedArtifact: null,
                showArtifactModal: false,
                artifactModalTab: 'content',
                markdownInitialized: false,
                showArtifactUpload: false,
                showTagFilter: false,
                showWorkflowFilter: false,
                selectedTags: [],
                selectedWorkflows: [],
                availableTags: [],
                availableWorkflows: [],
                groupedArtifactsByDate: [],
                hasMoreArtifacts: false,
                isLoadingArtifacts: false,
                isLoadingMoreArtifacts: false,
                artifactCurrentPage: 1,
                artifactPageSize: 20,
                
                // Filters
                workflowFilter: '',
                memoryLevelFilter: '',
                memorySearch: '',
                actionStatusFilter: '',
                actionTypeFilter: '',
                actionSearch: '',
                memorySortBy: 'created_at',
                memorySortOrder: 'desc',
                
                // Pagination
                currentPage: 1,
                pageSize: 12,
                
                // Stats
                stats: {
                    totalMemories: 0,
                    totalWorkflows: 0,
                    totalActions: 0,
                    totalGoals: 0,
                    totalLinks: 0
                },
                
                // Selected items
                selectedWorkflow: null,
                selectedMemory: null,
                selectedAction: null,
                showWorkflowModal: false,
                showMemoryModal: false,
                showActionModal: false,
                
                // Recent activity
                recentActivity: [],
                
                // Charts
                charts: {},
                isRenderingCharts: false,
                
                // Commands
                commands: [
                    { id: 'search', title: 'Search Everything', description: 'Global search across all data', icon: 'search', shortcut: 'Ctrl+F' },
                    { id: 'workflows', title: 'View Workflows', description: 'Navigate to workflows view', icon: 'git-branch', shortcut: 'W' },
                    { id: 'memories', title: 'View Memories', description: 'Navigate to memories view', icon: 'brain', shortcut: 'M' },
                    { id: 'actions', title: 'View Actions', description: 'Navigate to actions view', icon: 'zap', shortcut: 'R' },
                    { id: 'goals', title: 'Goal Hierarchy', description: 'Interactive goal tree with dependencies', icon: 'target', shortcut: 'L' },
                    { id: 'analytics', title: 'View Analytics', description: 'Navigate to analytics view', icon: 'bar-chart-3', shortcut: 'A' },
                    { id: 'graph', title: 'Memory Graph', description: 'Interactive network visualization', icon: 'network', shortcut: 'G' },
                    { id: 'thought-chains', title: 'Thought Chains', description: 'Reasoning flow diagrams with timeline', icon: 'git-branch-plus', shortcut: 'C' },
                    { id: 'semantic-search', title: 'Semantic Search', description: 'Advanced vector similarity search with clustering', icon: 'search', shortcut: 'S' },
                    { id: 'working-memory', title: 'Working Memory', description: 'Real-time memory management dashboard', icon: 'cpu', shortcut: 'U' },
                    { id: 'workflow-dependencies', title: 'Workflow Dependencies', description: 'Gantt chart + network diagram for workflow scheduling', icon: 'git-merge', shortcut: 'Y' },
                    { id: 'action-monitor', title: 'Action Monitor', description: 'Real-time action execution monitoring with performance metrics', icon: 'activity', shortcut: 'X' },
                    { id: 'memory-quality', title: 'Memory Quality Inspector', description: 'Advanced memory quality analysis and cleanup automation', icon: 'scan-line', shortcut: 'Q' },
                    { id: 'dashboard', title: 'Dashboard', description: 'Go back to dashboard', icon: 'layout-dashboard', shortcut: 'D' },
                    { id: 'theme', title: 'Toggle Theme', description: 'Switch between light and dark mode', icon: 'palette', shortcut: 'T' },
                    { id: 'export', title: 'Export Data', description: 'Export current view as JSON/CSV', icon: 'download', shortcut: 'E' }
                ],
                
                // Graph-specific state
                graphData: { nodes: [], links: [] },
                graphSettings: {
                    layout: 'force',
                    colorBy: 'memory_level',
                    forceStrength: -30,
                    linkDistance: 80,
                    physicsEnabled: true,
                    showLegend: true,
                    visibleLevels: ['working', 'episodic', 'semantic', 'procedural']
                },
                selectedGraphNode: null,
                graphClusters: [],
                graphTooltip: { visible: false, x: 0, y: 0, title: '', subtitle: '', content: '' },
                currentLegend: [],
                
                // D3 objects
                svg: null,
                simulation: null,
                zoom: null,
                
                // Thought Chain state
                thoughtChains: [],
                currentChain: null,
                thoughtTimelinePosition: 0,
                thoughtTimelineLength: 0,
                thoughtsInCurrentChain: [],
                currentThoughtIndex: 0,
                isPlaybackActive: false,
                playbackSpeed: 1,
                playbackInterval: null,
                mermaidDiagram: '',
                chainFilter: '',
                selectedThought: null,
                showThoughtModal: false,
                thoughtChainStats: {
                    totalChains: 0,
                    totalThoughts: 0,
                    avgChainLength: 0,
                    branchingPoints: 0
                },

                // Goal Hierarchy state
                goalTreeData: { children: [] },
                goalTreeSettings: {
                    showCompleted: true,
                    showProgress: true,
                    groupBy: 'none', // 'none', 'priority', 'status', 'owner'
                    sortBy: 'created', // 'created', 'priority', 'progress', 'title'
                    expandLevel: 2 // Auto-expand to this level
                },
                selectedGoal: null,
                goalFilter: '',
                goalSearch: '',
                showGoalModal: false,
                editingGoal: null,
                goalForm: {
                    title: '',
                    description: '',
                    priority: 'medium',
                    status: 'pending',
                    progress: 0,
                    due_date: '',
                    parent_goal_id: '',
                    notes: ''
                },
                isDragging: false,
                draggedGoal: null,
                dropTarget: null,
                goalStats: {
                    total: 0,
                    completed: 0,
                    inProgress: 0,
                    pending: 0,
                    overdue: 0,
                    completionRate: 0
                },

                // Semantic Search state
                semanticQuery: '',
                searchMode: 'hybrid', // 'hybrid', 'semantic', 'structured'
                isSearching: false,
                searchResults: [],
                searchClusters: [],
                searchHistory: [],
                savedSearches: [],
                searchFilters: {
                    memoryLevel: '',
                    memoryType: '',
                    semanticWeight: 0.6,
                    keywordWeight: 0.4,
                    minImportance: null,
                    maxImportance: null,
                    dateRange: null
                },
                searchStats: {
                    totalTime: 0,
                    semanticMatches: 0,
                    keywordMatches: 0,
                    totalConsidered: 0
                },
                showAdvancedOptions: false,
                resultsView: 'list', // 'list', 'clusters', 'context'
                sortBy: 'similarity',
                searchStatusMessage: '',
                searchDebounceTimer: null,

                // Working Memory Dashboard state
                workingMemoryStatus: {
                    connected: false,
                    lastUpdate: null,
                    updateFrequency: 5000 // 5 seconds
                },
                isRefreshingWorkingMemory: false,
                isOptimizing: false,
                workingMemoryStats: {
                    activeCount: 0,
                    capacity: 7, // Working memory capacity (72 rule)
                    pressure: 0, // 0-100%
                    temperature: 0, // Activity level
                    focusScore: 0, // 0-100%
                    efficiency: 0, // 0-100%
                    avgRetentionTime: 0,
                    totalAccesses: 0
                },
                activeWorkingMemories: [],
                workingMemorySettings: {
                    autoRefresh: true,
                    notificationEnabled: true,
                    pressureThreshold: 80,
                    temperatureThreshold: 70
                },
                heatmapSettings: {
                    timeframe: '24h',
                    granularity: 'hour'
                },
                memoryHeatmapData: [],
                focusSettings: {
                    mode: 'normal', // 'normal', 'deep', 'creative', 'analytical', 'maintenance'
                    retentionTime: 30, // minutes
                    maxWorkingMemory: 7
                },
                focusHistory: [],
                optimizationSuggestions: [],
                memoryPoolSearch: '',
                memoryPoolFilter: '',
                filteredMemoryPool: [],
                workingMemoryCharts: {},
                workingMemoryInterval: null,
                draggedMemory: null,

                // Cognitive State Timeline state
                cognitiveTimelineData: [],
                cognitiveTimelineSettings: {
                    timeRange: 24, // hours
                    granularity: 'hour'
                },
                timelineStats: {},
                patternAnalysis: {
                    patterns: [],
                    transitions: [],
                    anomalies: [],
                    summary: {}
                },
                selectedTimelineState: null,
                currentTimelineIndex: 0,
                isLoadingTimeline: false,
                isAnalyzingPatterns: false,
                isTimelineAnimating: false,
                timelineAnimationSpeed: 1,
                timelineViewMode: 'timeline', // 'timeline', 'heatmap', 'network'
                timelineInterval: null,
                showTimelineStateModal: false,
                showPatternsModal: false,
                showComparisonModal: false,
                stateComparison: null,

                // Workflow Dependencies state
                dependencyWorkflows: [],
                selectedDependencyWorkflow: null,
                dependencyViewMode: 'combined', // 'combined', 'network', 'gantt'
                simulationMode: false,
                simulationSnapshot: null,
                isDraggingWorkflow: false,
                originalWorkflowTiming: null,
                isOptimizingSchedule: false,
                resourceConflicts: [],
                criticalPathStats: {
                    totalWorkflows: 0,
                    totalDuration: 0,
                    bottlenecks: []
                },
                dependencyFilter: '',
                dependencySimulation: null,
                ganttSvg: null,
                ganttXScale: null,
                ganttYScale: null,

                // Action Monitor state
                actionMonitorData: {
                    realTimeActions: [],
                    queuedActions: [],
                    completedActions: [],
                    batchOperations: [],
                    toolUsageStats: {},
                    performanceMetrics: {},
                    errorLog: []
                },
                actionMonitorSettings: {
                    autoRefresh: true,
                    refreshInterval: 1000, // 1 second
                    showCompleted: true,
                    maxHistoryItems: 100,
                    enableNotifications: true,
                    soundAlerts: false
                },
                actionMonitorStatus: {
                    connected: false,
                    lastUpdate: null,
                    totalActions: 0,
                    avgExecutionTime: 0,
                    successRate: 0,
                    errorRate: 0
                },
                selectedActionDetail: null,
                actionFilterType: 'all', // 'all', 'running', 'queued', 'completed', 'failed'
                actionFilterTool: '',
                actionSearchQuery: '',
                showActionDetailModal: false,
                actionMonitorInterval: null,
                actionWebSocket: null,
                isMonitoringActions: false,
                actionPerformanceCharts: {},
                batchOperationProgress: {},
                realtimeMetrics: {
                    actionsPerSecond: 0,
                    avgResponseTime: 0,
                    cpuUsage: 0,
                    memoryUsage: 0,
                    errorCount: 0
                },
                
                // Performance chart settings
                performanceChartTimeRange: '24h',
                performanceChartsUpdateTimer: null,
                workingMemoryChartsUpdateTimer: null,

                // Memory Quality Inspector state
                qualityAnalysisResults: null,
                qualityStats: null,
                duplicateClusters: [],
                orphanedMemories: [],
                qualityIssues: [],
                selectedQualityIssue: null,
                bulkOperationPreview: null,
                isAnalyzing: false,
                isLoadingQuality: false,
                qualityAnalysisSettings: {
                    analysisType: 'comprehensive', // comprehensive, duplicates, orphaned, low_quality
                    includeStale: true,
                    includeLowImportance: true,
                    similarityThreshold: 0.85,
                    staleThresholdDays: 30
                },
                qualityFilterType: 'all', // all, critical, high, medium, low
                qualitySearchQuery: '',
                selectedMemoriesForBulk: new Set(),
                selectedQualityIssues: new Set(),
                bulkOperationType: 'delete', // delete, merge, archive, update
                showQualityAnalysisModal: false,
                showBulkOperationModal: false,
                showQualityIssueModal: false,
                qualityViewMode: 'overview', // overview, issues, duplicates, orphaned, bulk
                autoFixAvailable: [],
                lastQualityAnalysis: null,

                async init() {
                    console.log(' UMS Explorer Pro initializing...');
                    
                    try {
                        // Initialize SQL.js
                        await initializeSqlJs();
                        
                        // Load theme
                        this.loadTheme();
                        
                        // Initialize commands
                        this.filteredCommands = this.commands;
                        
                        // Setup keyboard shortcuts
                        this.setupKeyboardShortcuts();
                        
                        // Initialize icons
                        this.$nextTick(() => {
                            if (window.lucide) {
                                lucide.createIcons();
                            }
                        });
                        
                        // Initialize Mermaid
                        if (window.mermaid) {
                            mermaid.initialize({
                                startOnLoad: false,
                                theme: 'dark'
                            });
                        }
                        
                        // Watch for view changes
                        this.$watch('currentView', (newView, oldView) => {
                            // Cleanup charts when leaving views with charts
                            if (oldView === 'analytics' || oldView === 'working-memory' || oldView === 'action-monitor') {
                                this.cleanupCharts();
                            }
                            
                            if (newView === 'analytics') {
                                this.$nextTick(() => this.renderCharts());
                            } else if (newView === 'graph') {
                                this.$nextTick(() => this.initializeGraph());
                            } else if (newView === 'thought-chains') {
                                this.$nextTick(() => this.initializeThoughtChains());
                            } else if (newView === 'goals') {
                                this.$nextTick(() => this.initializeGoalTree());
                            } else if (newView === 'working-memory') {
                                this.$nextTick(() => this.initializeWorkingMemory());
                            } else if (newView === 'workflow-dependencies') {
                                this.$nextTick(() => this.initializeWorkflowDependencies());
                            } else if (newView === 'cognitive-timeline') {
                                this.$nextTick(() => this.initializeCognitiveTimeline());
                            } else if (newView === 'action-monitor') {
                                this.$nextTick(() => this.initializeActionMonitor());
                            } else if (newView === 'artifact-gallery') {
                                this.$nextTick(() => this.initializeArtifactGallery());
                            } else if (newView === 'memory-quality') {
                                this.$nextTick(() => this.initializeMemoryQuality());
                            }
                            
                            this.$nextTick(() => {
                                if (window.lucide) {
                                    lucide.createIcons();
                                }
                            });
                        });
                        
                        // Watch for search
                        this.$watch('globalSearch', (query) => {
                            this.updateSearchSuggestions(query);
                        });
                        
                        console.log(' UMS Explorer Pro initialized successfully');
                        
                        // Try to auto-load database from default location
                        this.tryAutoLoadDatabase();
                        
                        // Load semantic search state
                        this.loadSemanticSearchState();
                        
                    } catch (error) {
                        console.error(' Failed to initialize UMS Explorer:', error);
                        // Show error state to user
                        this.isLoading = false;
                        this.loadingMessage = '';
                        if (window.Toastify) {
                            this.showToast('Failed to initialize application. Please refresh and try again.', 'error');
                        } else {
                            alert('Failed to initialize application. Please refresh and try again.');
                        }
                    }
                },

                async tryAutoLoadDatabase() {
                    try {
                        // Try to fetch the default database file from the server
                        const defaultPaths = [
                            '/storage/unified_agent_memory.db',       // Server route (FastAPI static mount)
                            '../../storage/unified_agent_memory.db',  // Fallback: relative path from tools/ directory
                            '../storage/unified_agent_memory.db',     // Fallback: one level up
                            './storage/unified_agent_memory.db',      // Fallback: same level
                            'storage/unified_agent_memory.db'         // Fallback: direct
                        ];
                        
                        for (const path of defaultPaths) {
                            try {
                                console.log(` Checking for database at: ${path}`);
                                const response = await fetch(path);
                                if (response.ok) {
                                    console.log(` Found database at: ${path}`);
                                    const arrayBuffer = await response.arrayBuffer();
                                    const data = new Uint8Array(arrayBuffer);
                                    
                                    if (this.db) {
                                        this.db.close();
                                    }
                                    
                                    this.db = new SQL.Database(data);
                                    this.db.exec("PRAGMA foreign_keys = ON;");
                                    this.db.exec("PRAGMA journal_mode = MEMORY;");
                                    
                                    // Test the database
                                    const testResult = this.executeQuery("SELECT count(*) as count FROM sqlite_master WHERE type='table';");
                                    if (testResult && testResult.length > 0) {
                                        this.dbLoaded = true;
                                        await this.loadAllData();
                                        this.showToast(`Database auto-loaded from ${path} `, 'success');
                                        return; // Exit once we've successfully loaded
                                    }
                                }
                            } catch (pathError) {
                                // Silently continue to next path
                                console.log(` Database not found at: ${path}`);
                            }
                        }
                        
                        console.log(' No database found at default locations');
                    } catch (error) {
                        console.log(' Auto-load failed, user will need to select database manually');
                    }
                },

                setupKeyboardShortcuts() {
                    document.addEventListener('keydown', (e) => {
                        // Command palette
                        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                            e.preventDefault();
                            this.showCommandPalette = true;
                        }
                        
                        // Quick navigation (only when not in input)
                        if (!e.target.matches('input, textarea')) {
                            switch(e.key.toLowerCase()) {
                                case 'd':
                                    this.navigateTo('dashboard');
                                    break;
                                case 'w':
                                    this.navigateTo('workflows');
                                    break;
                                case 'm':
                                    this.navigateTo('memories');
                                    break;
                                case 'r':
                                    this.navigateTo('actions');
                                    break;
                                case 'l':
                                    this.navigateTo('goals');
                                    break;
                                case 'a':
                                    this.navigateTo('analytics');
                                    break;
                                case 'g':
                                    this.navigateTo('graph');
                                    break;
                                case 'c':
                                    this.navigateTo('thought-chains');
                                    break;
                                case 's':
                                    this.navigateTo('semantic-search');
                                    break;
                                case 'u':
                                    this.navigateTo('working-memory');
                                    break;
                                case 'y':
                                    this.navigateTo('workflow-dependencies');
                                    break;
                                case 'x':
                                    this.navigateTo('action-monitor');
                                    break;
                                case 'q':
                                    this.navigateTo('memory-quality');
                                    break;
                                case 't':
                                    this.toggleTheme();
                                    break;
                                case 'escape':
                                    this.showCommandPalette = false;
                                    this.showWorkflowModal = false;
                                    this.showMemoryModal = false;
                                    this.showActionModal = false;
                                    this.selectedGraphNode = null;
                                    break;
                            }
                        }
                    });
                },

                updateCommands() {
                    if (!this.commandQuery) {
                        this.filteredCommands = this.commands;
                        return;
                    }
                    
                    const query = this.commandQuery.toLowerCase();
                    this.filteredCommands = this.commands.filter(cmd => 
                        cmd.title.toLowerCase().includes(query) || 
                        cmd.description.toLowerCase().includes(query)
                    );
                },

                executeCommand(cmd = null) {
                    if (!cmd && this.filteredCommands.length > 0) {
                        cmd = this.filteredCommands[0];
                    }
                    
                    if (!cmd) return;
                    
                    this.showCommandPalette = false;
                    this.commandQuery = '';
                    
                    switch(cmd.id) {
                        case 'search':
                            document.querySelector('input[placeholder*="Search everything"]')?.focus();
                            break;
                        case 'workflows':
                        case 'memories':
                        case 'actions':
                        case 'goals':
                        case 'analytics':
                        case 'graph':
                        case 'thought-chains':
                        case 'semantic-search':
                        case 'working-memory':
                        case 'workflow-dependencies':
                        case 'action-monitor':
                        case 'memory-quality':
                        case 'dashboard':
                            this.navigateTo(cmd.id);
                            break;
                        case 'theme':
                            this.toggleTheme();
                            break;
                        case 'export':
                            this.exportCurrentView();
                            break;
                    }
                },

                handleFileDrop(event) {
                    event.currentTarget.classList.remove('border-blue-400', 'bg-blue-400/10');
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadDatabaseFromFile(files[0]);
                    }
                },

                loadDatabase(event) {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadDatabaseFromFile(file);
                    }
                },

                async loadDatabaseFromFile(file) {
                    this.isLoading = true;
                    this.loadingMessage = `Loading ${file.name}...`;
                    
                    try {
                        if (!SQL) {
                            throw new Error('SQL.js not initialized. Please refresh the page and try again.');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);
                        
                        if (this.db) {
                            this.db.close();
                        }
                        
                        this.db = new SQL.Database(data);
                        
                        // Set pragmas
                        this.db.exec("PRAGMA foreign_keys = ON;");
                        this.db.exec("PRAGMA journal_mode = MEMORY;");
                        
                        // Test the database
                        const testResult = this.executeQuery("SELECT count(*) as count FROM sqlite_master WHERE type='table';");
                        if (testResult && testResult.length > 0) {
                            this.dbLoaded = true;
                            await this.loadAllData();
                            this.showToast('Database loaded successfully! ', 'success');
                        } else {
                            throw new Error('Invalid database file');
                        }
                        
                    } catch (error) {
                        console.error('Database loading error:', error);
                        this.showToast(`Error loading database: ${error.message}`, 'error');
                        this.dbLoaded = false;
                        if (this.db) {
                            this.db.close();
                            this.db = null;
                        }
                    } finally {
                        this.isLoading = false;
                        this.loadingMessage = '';
                    }
                },

                executeQuery(sql, params = []) {
                    if (!this.db) return [];
                    
                    try {
                        const stmt = this.db.prepare(sql);
                        stmt.bind(params);
                        const results = [];
                        while (stmt.step()) {
                            results.push(stmt.getAsObject());
                        }
                        stmt.free();
                        return results;
                    } catch (error) {
                        console.error('SQL Error:', error, { sql, params });
                        return [];
                    }
                },

                async loadAllData() {
                    this.isProcessing = true;
                    this.loadingMessage = 'Processing data...';
                    
                    try {
                        // Load workflows with counts
                        this.workflows = this.executeQuery(`
                            SELECT w.*, 
                                   COUNT(DISTINCT a.action_id) as action_count,
                                   COUNT(DISTINCT m.memory_id) as memory_count,
                                   COUNT(DISTINCT ar.artifact_id) as artifact_count
                            FROM workflows w
                            LEFT JOIN actions a ON w.workflow_id = a.workflow_id
                            LEFT JOIN memories m ON w.workflow_id = m.workflow_id
                            LEFT JOIN artifacts ar ON w.workflow_id = ar.workflow_id
                            GROUP BY w.workflow_id
                            ORDER BY w.updated_at DESC
                        `);

                        // Load memories
                        this.memories = this.executeQuery(`
                            SELECT * FROM memories 
                            ORDER BY created_at DESC
                        `);

                        // Load actions
                        this.actions = this.executeQuery(`
                            SELECT * FROM actions 
                            ORDER BY started_at DESC
                        `);

                        // Load artifacts
                        this.artifacts = this.executeQuery(`
                            SELECT * FROM artifacts 
                            ORDER BY created_at DESC
                        `);

                        // Load goals
                        this.goals = this.executeQuery(`
                            SELECT * FROM goals 
                            ORDER BY created_at DESC
                        `);

                        // Calculate stats
                        this.stats = {
                            totalMemories: this.memories.length,
                            totalWorkflows: this.workflows.length,
                            totalActions: this.actions.length,
                            totalGoals: this.goals.length,
                            totalLinks: this.executeQuery("SELECT COUNT(*) as count FROM memory_links")[0]?.count || 0
                        };

                        // Generate recent activity
                        this.generateRecentActivity();
                        
                        // Load graph data
                        this.loadingMessage = 'Building graph data...';
                        await this.loadGraphData();
                        
                        // Load thought chain data
                        this.loadingMessage = 'Building thought chains...';
                        await this.loadThoughtChainData();
                        
                        // Load goal tree data
                        this.loadingMessage = 'Building goal hierarchy...';
                        await this.loadGoalTreeData();
                        
                        this.loadingMessage = 'Finalizing...';
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for better UX
                        
                    } catch (error) {
                        console.error('Error loading data:', error);
                        this.showToast('Error loading some data from database', 'warning');
                    } finally {
                        this.isProcessing = false;
                        this.loadingMessage = '';
                    }
                },

                parseActivityContent(content, type) {
                    if (!content) return 'No description available';
                    
                    // Parse thought content like "Thought [1] (Goal): Established new UMS sub-goal: Overall objectives for workflow a1981ba9"
                    if (type === 'thought') {
                        const thoughtMatch = content.match(/Thought \[(\d+)\] \(([^)]+)\): (.+)/);
                        if (thoughtMatch) {
                            const [, number, thoughtType, description] = thoughtMatch;
                            return `${thoughtType} #${number}: ${description}`;
                        }
                    }
                    
                    // Parse goal content 
                    if (type === 'goal') {
                        if (content.includes('Established new UMS sub-goal:')) {
                            return content.replace('Established new UMS sub-goal:', 'New goal:');
                        }
                    }
                    
                    // Parse action content
                    if (type === 'action') {
                        if (content.includes('tool_use:')) {
                            const tool = content.split('tool_use:')[1]?.split(' ')[0];
                            return `Used tool: ${tool}`;
                        }
                    }
                    
                    // Generic parsing - clean up common patterns
                    return content
                        .replace(/workflow [a-f0-9-]+/gi, 'workflow')
                        .replace(/memory [a-f0-9-]+/gi, 'memory')
                        .replace(/action [a-f0-9-]+/gi, 'action')
                        .substring(0, 80) + (content.length > 80 ? '...' : '');
                },

                generateRecentActivity() {
                    const activities = [];
                    
                    // Recent memories with better parsing
                    this.memories.slice(0, 3).forEach(memory => {
                        let title = 'Memory Created';
                        let description = this.parseActivityContent(memory.content, 'memory');
                        let icon = 'brain';
                        
                        // Determine memory type for better context
                        if (memory.memory_type === 'thought') {
                            title = 'Thought Recorded';
                            description = this.parseActivityContent(memory.content, 'thought');
                            icon = 'lightbulb';
                        } else if (memory.memory_type === 'goal') {
                            title = 'Goal Established';
                            description = this.parseActivityContent(memory.content, 'goal');
                            icon = 'target';
                        } else if (memory.memory_type === 'plan') {
                            title = 'Plan Created';
                            icon = 'map';
                        }
                        
                        activities.push({
                            id: memory.memory_id,
                            title,
                            description,
                            timestamp: memory.created_at,
                            icon,
                            type: 'memory'
                        });
                    });
                    
                    // Recent workflows
                    this.workflows.slice(0, 2).forEach(workflow => {
                        activities.push({
                            id: workflow.workflow_id,
                            title: 'Workflow Updated',
                            description: workflow.title || workflow.goal || 'Workflow activity',
                            timestamp: workflow.updated_at,
                            icon: 'git-branch',
                            type: 'workflow'
                        });
                    });
                    
                    // Recent actions with better descriptions
                    this.actions.slice(0, 2).forEach(action => {
                        let title = 'Action Executed';
                        let description = action.title || action.action_type || 'Action performed';
                        let icon = 'zap';
                        
                        if (action.action_type === 'tool_use') {
                            title = 'Tool Used';
                            description = action.tool_name ? `Used ${action.tool_name}` : description;
                            icon = 'wrench';
                        } else if (action.action_type === 'reasoning') {
                            title = 'Analysis Performed';
                            icon = 'brain';
                        } else if (action.action_type === 'planning') {
                            title = 'Planning Session';
                            icon = 'map';
                        }
                        
                        activities.push({
                            id: action.action_id,
                            title,
                            description: this.parseActivityContent(description, 'action'),
                            timestamp: action.started_at,
                            icon,
                            type: 'action'
                        });
                    });
                    
                    // Sort by timestamp
                    this.recentActivity = activities.sort((a, b) => b.timestamp - a.timestamp);
                },

                navigateTo(view) {
                    this.currentView = view;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                },

                get filteredWorkflows() {
                    if (!this.workflowFilter) return this.workflows;
                    return this.workflows.filter(w => w.status === this.workflowFilter);
                },

                get filteredMemories() {
                    let filtered = this.memories;
                    
                    if (this.memoryLevelFilter) {
                        filtered = filtered.filter(m => m.memory_level === this.memoryLevelFilter);
                    }
                    
                    if (this.memorySearch) {
                        const search = this.memorySearch.toLowerCase();
                        filtered = filtered.filter(m => 
                            m.content?.toLowerCase().includes(search) ||
                            m.memory_type?.toLowerCase().includes(search) ||
                            m.description?.toLowerCase().includes(search)
                        );
                    }
                    
                    // Apply sorting
                    filtered.sort((a, b) => {
                        let aVal = a[this.memorySortBy];
                        let bVal = b[this.memorySortBy];
                        
                        if (this.memorySortBy === 'importance' || this.memorySortBy === 'confidence') {
                            aVal = parseFloat(aVal) || 0;
                            bVal = parseFloat(bVal) || 0;
                        }
                        
                        if (this.memorySortOrder === 'desc') {
                            return bVal > aVal ? 1 : -1;
                        } else {
                            return aVal > bVal ? 1 : -1;
                        }
                    });
                    
                    return filtered;
                },

                get groupedMemories() {
                    const groups = new Map();
                    const filtered = this.filteredMemories;
                    
                    // Group memories by workflow_id
                    filtered.forEach(memory => {
                        const workflowId = memory.workflow_id || 'standalone';
                        if (!groups.has(workflowId)) {
                            const workflow = this.workflows.find(w => w.workflow_id === workflowId);
                            groups.set(workflowId, {
                                workflowId,
                                workflowTitle: workflow?.title || workflow?.goal || (workflowId === 'standalone' ? 'Standalone Memories' : `Workflow ${workflowId.substring(0, 8)}`),
                                memories: [],
                                collapsed: false
                            });
                        }
                        groups.get(workflowId).memories.push(memory);
                    });
                    
                    // Convert to array and sort by memory count (descending)
                    return Array.from(groups.values()).sort((a, b) => b.memories.length - a.memories.length);
                },

                get filteredActions() {
                    let filtered = this.actions;
                    
                    if (this.actionStatusFilter) {
                        filtered = filtered.filter(a => a.status === this.actionStatusFilter);
                    }
                    
                    if (this.actionTypeFilter) {
                        filtered = filtered.filter(a => a.action_type === this.actionTypeFilter);
                    }
                    
                    if (this.actionSearch) {
                        const search = this.actionSearch.toLowerCase();
                        filtered = filtered.filter(a => 
                            a.title?.toLowerCase().includes(search) ||
                            a.action_type?.toLowerCase().includes(search) ||
                            a.tool_name?.toLowerCase().includes(search) ||
                            a.reasoning?.toLowerCase().includes(search) ||
                            a.summary?.toLowerCase().includes(search)
                        );
                    }
                    
                    return filtered;
                },

                get sortedSearchResults() {
                    if (!this.searchResults.length) return [];
                    
                    return [...this.searchResults].sort((a, b) => {
                        switch (this.sortBy) {
                            case 'similarity':
                                return (b.similarity || 0) - (a.similarity || 0);
                            case 'hybrid':
                                return (b.hybrid_score || 0) - (a.hybrid_score || 0);
                            case 'importance':
                                return b.importance - a.importance;
                            case 'created_at':
                                return b.created_at - a.created_at;
                            default:
                                return 0;
                        }
                    });
                },

                loadMore() {
                    this.currentPage++;
                },

                selectWorkflow(workflow) {
                    this.selectedWorkflow = workflow;
                    this.showWorkflowModal = true;
                },

                selectMemory(memory) {
                    this.selectedMemory = memory;
                    this.showMemoryModal = true;
                },

                selectAction(action) {
                    this.selectedAction = action;
                    this.showActionModal = true;
                },

                // Artifact Gallery Methods
                async loadArtifacts() {
                    this.isLoadingArtifacts = true;
                    
                    try {
                        const params = new URLSearchParams({
                            artifact_type: this.artifactTypeFilter,
                            search: this.artifactSearchQuery,
                            sort_by: this.artifactSortBy,
                            sort_order: this.artifactSortOrder,
                            limit: this.artifactPageSize,
                            offset: (this.artifactCurrentPage - 1) * this.artifactPageSize
                        });

                        // Add workflow filter
                        if (this.selectedWorkflows.length > 0) {
                            params.append('workflow_id', this.selectedWorkflows.join(','));
                        }

                        // Add tag filter
                        if (this.selectedTags.length > 0) {
                            params.append('tags', this.selectedTags.join(','));
                        }

                        const response = await fetch(`/api/artifacts?${params}`);
                        
                        // Check if response is okay and contains JSON
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.log(' Artifacts API not available, falling back to database query');
                                return this.loadArtifactsFromDatabase();
                            }
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error('Response is not JSON');
                        }
                        
                        const data = await response.json();

                        if (this.artifactCurrentPage === 1) {
                            this.filteredArtifacts = data.artifacts || [];
                        } else {
                            this.filteredArtifacts.push(...(data.artifacts || []));
                        }

                        this.hasMoreArtifacts = data.has_more || false;
                        this.updateGroupedArtifactsByDate();
                        await this.loadArtifactStats();
                        await this.loadAvailableFilters();

                    } catch (error) {
                        console.error('Error loading artifacts:', error);
                        // Fall back to database query if API fails
                        this.loadArtifactsFromDatabase();
                    } finally {
                        this.isLoadingArtifacts = false;
                    }
                },

                // Fallback method to load artifacts directly from database
                async loadArtifactsFromDatabase() {
                    try {
                        if (!this.db) {
                            this.filteredArtifacts = [];
                            this.hasMoreArtifacts = false;
                            return;
                        }

                        // Build SQL query based on filters
                        let sql = `SELECT * FROM artifacts WHERE 1=1`;
                        const params = [];

                        if (this.artifactTypeFilter) {
                            sql += ` AND artifact_type = ?`;
                            params.push(this.artifactTypeFilter);
                        }

                        if (this.artifactSearchQuery) {
                            sql += ` AND (name LIKE ? OR description LIKE ?)`;
                            const searchTerm = `%${this.artifactSearchQuery}%`;
                            params.push(searchTerm, searchTerm);
                        }

                        // Add ordering
                        sql += ` ORDER BY ${this.artifactSortBy} ${this.artifactSortOrder.toUpperCase()}`;
                        
                        // Add pagination
                        const limit = this.artifactPageSize;
                        const offset = (this.artifactCurrentPage - 1) * this.artifactPageSize;
                        sql += ` LIMIT ? OFFSET ?`;
                        params.push(limit, offset);

                        const results = this.executeQuery(sql, params);
                        
                        // Process results to add missing fields
                        const processedResults = results.map(artifact => ({
                            ...artifact,
                            tags: artifact.tags ? JSON.parse(artifact.tags) : [],
                            metadata: artifact.metadata ? JSON.parse(artifact.metadata) : {}
                        }));

                        if (this.artifactCurrentPage === 1) {
                            this.filteredArtifacts = processedResults;
                        } else {
                            this.filteredArtifacts.push(...processedResults);
                        }

                        // Check if there are more artifacts
                        const countSql = `SELECT COUNT(*) as total FROM artifacts WHERE 1=1`;
                        const countResults = this.executeQuery(countSql);
                        const totalArtifacts = countResults[0]?.total || 0;
                        this.hasMoreArtifacts = (this.artifactCurrentPage * this.artifactPageSize) < totalArtifacts;

                        this.updateGroupedArtifactsByDate();
                        await this.loadAvailableFilters();

                    } catch (error) {
                        console.error('Error loading artifacts from database:', error);
                        this.filteredArtifacts = [];
                        this.hasMoreArtifacts = false;
                        this.showToast('Error loading artifacts from database', 'error');
                    }
                },

                async loadArtifactStats() {
                    try {
                        const response = await fetch('/api/artifacts/stats');
                        
                        // Check if response is okay and contains JSON
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.log(' Artifacts stats API not available, using database fallback');
                                return this.loadArtifactStatsFromDatabase();
                            }
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error('Response is not JSON');
                        }
                        
                        const data = await response.json();
                        this.artifactStats = data.overall;
                    } catch (error) {
                        console.error('Error loading artifact stats:', error);
                        this.loadArtifactStatsFromDatabase();
                    }
                },

                // Fallback method to load artifact stats from database
                async loadArtifactStatsFromDatabase() {
                    try {
                        if (!this.db) {
                            this.artifactStats = {
                                total_artifacts: 0,
                                unique_workflows: 0,
                                total_file_size_human: '0 B',
                                recent_artifacts_24h: 0,
                                total_relationships: 0
                            };
                            return;
                        }

                        // Calculate stats from database
                        const totalArtifacts = this.executeQuery('SELECT COUNT(*) as count FROM artifacts')[0]?.count || 0;
                        const uniqueWorkflows = this.executeQuery('SELECT COUNT(DISTINCT workflow_id) as count FROM artifacts')[0]?.count || 0;
                        
                        // Calculate recent artifacts (last 24 hours)
                        const yesterday = Math.floor(Date.now() / 1000) - (24 * 60 * 60);
                        const recentArtifacts = this.executeQuery('SELECT COUNT(*) as count FROM artifacts WHERE created_at > ?', [yesterday])[0]?.count || 0;

                        this.artifactStats = {
                            total_artifacts: totalArtifacts,
                            unique_workflows: uniqueWorkflows,
                            total_file_size_human: 'N/A',
                            recent_artifacts_24h: recentArtifacts,
                            total_relationships: 0
                        };

                    } catch (error) {
                        console.error('Error loading artifact stats from database:', error);
                        this.artifactStats = {
                            total_artifacts: 0,
                            unique_workflows: 0,
                            total_file_size_human: '0 B',
                            recent_artifacts_24h: 0,
                            total_relationships: 0
                        };
                    }
                },

                async loadAvailableFilters() {
                    try {
                        // Load available tags
                        const allTags = new Set();
                        this.filteredArtifacts.forEach(artifact => {
                            artifact.tags.forEach(tag => allTags.add(tag));
                        });
                        this.availableTags = Array.from(allTags).sort();

                        // Load available workflows
                        this.availableWorkflows = this.workflows.map(w => ({
                            id: w.workflow_id,
                            title: w.title || w.goal || `Workflow ${w.workflow_id.substring(0, 8)}`
                        }));

                    } catch (error) {
                        console.error('Error loading filters:', error);
                    }
                },

                updateGroupedArtifactsByDate() {
                    const groups = new Map();
                    
                    this.filteredArtifacts.forEach(artifact => {
                        const date = new Date(artifact.created_at * 1000).toDateString();
                        if (!groups.has(date)) {
                            groups.set(date, {
                                date,
                                artifacts: []
                            });
                        }
                        groups.get(date).artifacts.push(artifact);
                    });

                    this.groupedArtifactsByDate = Array.from(groups.values())
                        .sort((a, b) => new Date(b.date) - new Date(a.date));
                },

                async loadMoreArtifacts() {
                    if (this.isLoadingMoreArtifacts || !this.hasMoreArtifacts) return;
                    
                    this.isLoadingMoreArtifacts = true;
                    this.artifactCurrentPage++;
                    await this.loadArtifacts();
                    this.isLoadingMoreArtifacts = false;
                },

                async searchArtifacts() {
                    this.artifactCurrentPage = 1;
                    await this.loadArtifacts();
                },

                selectArtifact(artifact) {
                    this.selectedArtifact = artifact;
                    this.artifactModalTab = 'content';
                    this.showArtifactModal = true;
                    
                    // Initialize markdown renderer if not already done
                    this.initializeMarkdownRenderer();
                },

                initializeMarkdownRenderer() {
                    if (typeof marked !== 'undefined' && !this.markdownInitialized) {
                        // Configure marked with highlight.js for syntax highlighting
                        marked.setOptions({
                            highlight: function(code, lang) {
                                if (typeof hljs !== 'undefined' && lang && hljs.getLanguage(lang)) {
                                    try {
                                        return hljs.highlight(code, { language: lang }).value;
                                    } catch (err) {
                                        console.warn('Syntax highlighting failed:', err);
                                    }
                                }
                                return code;
                            },
                            breaks: true,
                            gfm: true
                        });
                        this.markdownInitialized = true;
                    }
                },

                renderMarkdownContent(artifact) {
                    if (!artifact || typeof marked === 'undefined') {
                        return '<p class="text-gray-400">Content not available</p>';
                    }

                    try {
                        let content = artifact.content || artifact.description || '';
                        
                        // If no content, return empty state
                        if (!content || content.trim() === '') {
                            return '<div class="text-center py-8"><i data-lucide="file-text" class="w-12 h-12 mx-auto mb-3 text-gray-400 opacity-50"></i><p class="text-gray-400">No content available</p></div>';
                        }

                        // For code artifacts, wrap in markdown code block if not already
                        if (artifact.artifact_type === 'code' && !content.includes('```')) {
                            const lang = this.getCodeLanguageShort(artifact);
                            content = `\`\`\`${lang}\n${content}\n\`\`\``;
                        }

                        // Render markdown
                        const html = marked.parse(content);
                        
                        // Post-process to add classes and handle images
                        return html.replace(/<img/g, '<img loading="lazy"');
                        
                    } catch (error) {
                        console.error('Error rendering markdown:', error);
                        return `<div class="bg-red-500/10 border border-red-500/20 rounded-lg p-4"><p class="text-red-400">Error rendering content: ${error.message}</p></div>`;
                    }
                },

                getCodeLanguageShort(artifact) {
                    if (artifact.metadata && artifact.metadata.language) {
                        return artifact.metadata.language.toLowerCase();
                    }
                    
                    const ext = artifact.name?.split('.').pop()?.toLowerCase();
                    const languages = {
                        js: 'javascript',
                        py: 'python',
                        ts: 'typescript',
                        jsx: 'jsx',
                        vue: 'vue',
                        html: 'html',
                        css: 'css',
                        json: 'json',
                        sql: 'sql',
                        md: 'markdown',
                        yaml: 'yaml',
                        yml: 'yaml'
                    };
                    
                    return languages[ext] || 'text';
                },

                getFullCodeContent(artifact) {
                    return artifact.content || artifact.metadata?.preview || `// ${artifact.name}\n// Content not available`;
                },

                getDataPreview(artifact) {
                    if (artifact.metadata && artifact.metadata.preview) {
                        try {
                            const data = JSON.parse(artifact.metadata.preview);
                            return JSON.stringify(data, null, 2);
                        } catch (e) {
                            return artifact.metadata.preview;
                        }
                    }
                    
                    if (artifact.content) {
                        try {
                            const data = JSON.parse(artifact.content);
                            return JSON.stringify(data, null, 2);
                        } catch (e) {
                            return artifact.content.substring(0, 500) + (artifact.content.length > 500 ? '...' : '');
                        }
                    }
                    
                    return 'No preview available';
                },

                copyCodeToClipboard(artifact) {
                    const content = this.getFullCodeContent(artifact);
                    
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(content).then(() => {
                            this.showToast('Code copied to clipboard!', 'success');
                        }).catch(err => {
                            console.error('Failed to copy:', err);
                            this.showToast('Failed to copy code', 'error');
                        });
                    } else {
                        // Fallback for older browsers
                        const textArea = document.createElement('textarea');
                        textArea.value = content;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            this.showToast('Code copied to clipboard!', 'success');
                        } catch (err) {
                            this.showToast('Failed to copy code', 'error');
                        }
                        document.body.removeChild(textArea);
                    }
                },

                downloadArtifact(artifact) {
                    if (!artifact) return;
                    
                    // For now, show toast - in real implementation this would trigger download
                    this.showToast(`Download started: ${artifact.name}`, 'info');
                    
                    // Real implementation would be:
                    // window.open(`/api/artifacts/${artifact.artifact_id}/download`, '_blank');
                },

                shareArtifact(artifact) {
                    if (!artifact) return;
                    
                    const shareData = {
                        title: artifact.name,
                        text: artifact.description || `Shared artifact: ${artifact.name}`,
                        url: window.location.href // In real app, would be artifact-specific URL
                    };
                    
                    if (navigator.share) {
                        navigator.share(shareData).then(() => {
                            this.showToast('Artifact shared successfully!', 'success');
                        }).catch(err => {
                            console.error('Error sharing:', err);
                            this.fallbackShare(artifact);
                        });
                    } else {
                        this.fallbackShare(artifact);
                    }
                },

                fallbackShare(artifact) {
                    // Copy link to clipboard as fallback
                    const shareText = `${artifact.name} - ${artifact.description || 'Shared artifact'}`;
                    
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(shareText).then(() => {
                            this.showToast('Artifact info copied to clipboard!', 'success');
                        });
                    } else {
                        this.showToast('Sharing not supported on this browser', 'warning');
                    }
                },

                toggleTagFilter(tag) {
                    const index = this.selectedTags.indexOf(tag);
                    if (index > -1) {
                        this.selectedTags.splice(index, 1);
                    } else {
                        this.selectedTags.push(tag);
                    }
                    this.searchArtifacts();
                },

                clearAllFilters() {
                    this.selectedTags = [];
                    this.selectedWorkflows = [];
                    this.artifactSearchQuery = '';
                    this.artifactTypeFilter = '';
                    this.showTagFilter = false;
                    this.showWorkflowFilter = false;
                    this.searchArtifacts();
                },

                getArtifactPreview(artifact) {
                    if (artifact.thumbnail_path) {
                        return artifact.thumbnail_path;
                    }
                    
                    if (artifact.file_path && artifact.artifact_type === 'image') {
                        return artifact.file_path;
                    }
                    
                    // Return placeholder for non-image types
                    return `data:image/svg+xml;base64,${btoa(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="200" height="150" viewBox="0 0 200 150">
                            <rect width="200" height="150" fill="#374151"/>
                            <text x="100" y="75" text-anchor="middle" fill="#9CA3AF" font-family="Arial" font-size="14">
                                ${artifact.artifact_type.toUpperCase()}
                            </text>
                        </svg>
                    `)}`;
                },

                getArtifactIcon(artifactType) {
                    const icons = {
                        image: 'image',
                        document: 'file-text',
                        code: 'code',
                        data: 'database',
                        model: 'cpu',
                        video: 'video',
                        audio: 'volume-2',
                        archive: 'archive'
                    };
                    return icons[artifactType] || 'file';
                },

                getArtifactTypeColor(artifactType) {
                    const colors = {
                        image: 'type-image',
                        document: 'type-document',
                        code: 'type-code',
                        data: 'type-data',
                        model: 'type-model'
                    };
                    return colors[artifactType] || 'type-default';
                },

                getMasonryItemHeight(artifact) {
                    // Calculate dynamic height based on content
                    const baseHeight = 200;
                    const contentHeight = Math.min(150, (artifact.description?.length || 0) / 2);
                    const tagHeight = Math.min(30, artifact.tags.length * 6);
                    
                    return baseHeight + contentHeight + tagHeight;
                },

                getPreviewHeight(artifact) {
                    if (artifact.artifact_type === 'image') {
                        return Math.min(300, Math.max(150, this.getMasonryItemHeight(artifact) * 0.6));
                    }
                    return 150;
                },

                getCodeLanguage(artifact) {
                    if (artifact.metadata && artifact.metadata.language) {
                        return artifact.metadata.language;
                    }
                    
                    // Try to detect from file extension
                    const ext = artifact.name?.split('.').pop()?.toLowerCase();
                    const languages = {
                        js: 'JavaScript',
                        py: 'Python',
                        ts: 'TypeScript',
                        jsx: 'React',
                        vue: 'Vue',
                        html: 'HTML',
                        css: 'CSS',
                        json: 'JSON',
                        sql: 'SQL'
                    };
                    
                    return languages[ext] || 'Code';
                },

                getCodePreview(artifact) {
                    if (artifact.metadata && artifact.metadata.preview) {
                        return artifact.metadata.preview.substring(0, 200) + '...';
                    }
                    
                    return `// ${artifact.name}\n// Preview not available`;
                },

                handleImageError(event, artifact) {
                    event.target.style.display = 'none';
                    event.target.parentNode.innerHTML = `
                        <div class="w-full h-full flex items-center justify-center bg-gray-800">
                            <div class="text-center">
                                <i data-lucide="${this.getArtifactIcon(artifact.artifact_type)}" class="w-16 h-16 mx-auto mb-2 text-gray-400"></i>
                                <div class="text-sm text-gray-400">Preview unavailable</div>
                            </div>
                        </div>
                    `;
                },

                formatTime(timestamp) {
                    return new Date(timestamp * 1000).toLocaleTimeString();
                },

                async initializeArtifactGallery() {
                    console.log(' Initializing Artifact Gallery...');
                    try {
                        await this.loadArtifacts();
                        console.log(' Artifact Gallery initialized');
                    } catch (error) {
                        console.error(' Failed to initialize Artifact Gallery:', error);
                        this.showToast('Failed to initialize Artifact Gallery', 'error');
                    }
                },

                performGlobalSearch() {
                    // Implement global search logic
                    console.log('Performing global search:', this.globalSearch);
                },

                updateSearchSuggestions(query) {
                    if (!query || query.length < 2) {
                        this.searchSuggestions = [];
                        return;
                    }
                    
                    const suggestions = [];
                    const search = query.toLowerCase();
                    
                    // Search workflows
                    this.workflows.forEach(w => {
                        if (w.title?.toLowerCase().includes(search)) {
                            suggestions.push({
                                id: w.workflow_id,
                                title: w.title,
                                type: 'Workflow',
                                icon: 'git-branch'
                            });
                        }
                    });
                    
                    // Search memories
                    this.memories.forEach(m => {
                        if (m.content?.toLowerCase().includes(search)) {
                            suggestions.push({
                                id: m.memory_id,
                                title: m.content.substring(0, 50) + '...',
                                type: 'Memory',
                                icon: 'brain'
                            });
                        }
                    });
                    
                    this.searchSuggestions = suggestions.slice(0, 10);
                },

                showToast(message, type = 'info') {
                    const colors = {
                        success: '#10b981',
                        error: '#ef4444',
                        warning: '#f59e0b',
                        info: '#3b82f6'
                    };
                    
                    Toastify({
                        text: message,
                        duration: 4000,
                        gravity: "top",
                        position: "right",
                        style: {
                            background: colors[type]
                        },
                        className: type,
                        close: true
                    }).showToast();
                },

                getWorkflowStatusClass(status) {
                    const classes = {
                        active: 'bg-green-500/20 text-green-400',
                        completed: 'bg-blue-500/20 text-blue-400',
                        paused: 'bg-yellow-500/20 text-yellow-400',
                        failed: 'bg-red-500/20 text-red-400',
                        abandoned: 'bg-gray-500/20 text-gray-400'
                    };
                    return classes[status] || 'bg-gray-500/20 text-gray-400';
                },

                getMemoryLevelClass(level) {
                    const classes = {
                        working: 'bg-yellow-500/20 text-yellow-400',
                        episodic: 'bg-blue-500/20 text-blue-400',
                        semantic: 'bg-green-500/20 text-green-400',
                        procedural: 'bg-purple-500/20 text-purple-400'
                    };
                    return classes[level] || 'bg-gray-500/20 text-gray-400';
                },

                getActionStatusClass(status) {
                    const classes = {
                        completed: 'bg-green-500/20 text-green-400',
                        in_progress: 'bg-blue-500/20 text-blue-400',
                        failed: 'bg-red-500/20 text-red-400',
                        planned: 'bg-yellow-500/20 text-yellow-400',
                        skipped: 'bg-gray-500/20 text-gray-400'
                    };
                    return classes[status] || 'bg-gray-500/20 text-gray-400';
                },

                getActionIcon(actionType) {
                    const icons = {
                        tool_use: 'wrench',
                        reasoning: 'brain',
                        planning: 'map',
                        analysis: 'search',
                        research: 'book-open',
                        decision: 'check-circle',
                        observation: 'eye',
                        reflection: 'mirror',
                        summary: 'file-text',
                        consolidation: 'layers',
                        memory_operation: 'database'
                    };
                    return icons[actionType] || 'zap';
                },

                formatDuration(startTime, endTime) {
                    if (!startTime) return 'N/A';
                    if (!endTime) return 'In progress';
                    
                    const duration = endTime - startTime;
                    if (duration < 60) return `${Math.round(duration)}s`;
                    if (duration < 3600) return `${Math.round(duration / 60)}m`;
                    return `${Math.round(duration / 3600)}h`;
                },

                formatDate(timestamp) {
                    if (!timestamp) return 'N/A';
                    return new Date(timestamp * 1000).toLocaleDateString();
                },

                formatRelativeTime(timestamp) {
                    if (!timestamp) return 'N/A';
                    const now = Date.now();
                    const time = timestamp * 1000;
                    const diff = now - time;
                    
                    const minute = 60 * 1000;
                    const hour = minute * 60;
                    const day = hour * 24;
                    
                    if (diff < minute) return 'Just now';
                    if (diff < hour) return Math.floor(diff / minute) + 'm ago';
                    if (diff < day) return Math.floor(diff / hour) + 'h ago';
                    return Math.floor(diff / day) + 'd ago';
                },

                loadTheme() {
                    const savedTheme = localStorage.getItem('ums-explorer-theme') || 'dark';
                    this.theme = savedTheme;
                    document.documentElement.setAttribute('data-theme', savedTheme);
                },

                toggleTheme() {
                    this.theme = this.theme === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', this.theme);
                    localStorage.setItem('ums-explorer-theme', this.theme);
                    this.showToast(`Switched to ${this.theme} mode`, 'info');
                },

                async renderCharts() {
                    if (!this.dbLoaded || !window.Chart) return;
                    
                    // Prevent multiple simultaneous chart renderings
                    if (this.isRenderingCharts) return;
                    this.isRenderingCharts = true;
                    
                    await this.$nextTick();
                    
                    try {
                        await this.renderMemoryLevelChart();
                        await this.renderMemoryTypeChart();
                        await this.renderWorkflowStatusChart();
                        await this.renderActivityChart();
                    } catch (error) {
                        console.error('Error rendering charts:', error);
                    } finally {
                        this.isRenderingCharts = false;
                    }
                },

                async renderMemoryLevelChart() {
                    const canvas = this.$refs.memoryLevelChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.memoryLevel) {
                        this.charts.memoryLevel.destroy();
                        this.charts.memoryLevel = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const levels = {};
                    this.memories.forEach(m => {
                        levels[m.memory_level] = (levels[m.memory_level] || 0) + 1;
                    });
                    
                    this.charts.memoryLevel = new Chart(canvas, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(levels),
                            datasets: [{
                                data: Object.values(levels),
                                backgroundColor: ['#f59e0b', '#3b82f6', '#10b981', '#8b5cf6'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#e5e7eb',
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                }
                            }
                        }
                    });
                },

                async renderMemoryTypeChart() {
                    const canvas = this.$refs.memoryTypeChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.memoryType) {
                        this.charts.memoryType.destroy();
                        this.charts.memoryType = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const types = {};
                    this.memories.forEach(m => {
                        types[m.memory_type] = (types[m.memory_type] || 0) + 1;
                    });
                    
                    const sortedTypes = Object.entries(types)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8);
                    
                    this.charts.memoryType = new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                label: 'Count',
                                data: sortedTypes.map(([, count]) => count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: '#9ca3af',
                                        maxRotation: 45
                                    },
                                    grid: {
                                        display: false
                                    }
                                },
                                y: {
                                    ticks: {
                                        color: '#9ca3af'
                                    },
                                    grid: {
                                        color: 'rgba(156, 163, 175, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                },

                async renderWorkflowStatusChart() {
                    const canvas = this.$refs.workflowStatusChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.workflowStatus) {
                        this.charts.workflowStatus.destroy();
                        this.charts.workflowStatus = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const statuses = {};
                    this.workflows.forEach(w => {
                        statuses[w.status] = (statuses[w.status] || 0) + 1;
                    });
                    
                    this.charts.workflowStatus = new Chart(canvas, {
                        type: 'pie',
                        data: {
                            labels: Object.keys(statuses),
                            datasets: [{
                                data: Object.values(statuses),
                                backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#6b7280'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#e5e7eb',
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                }
                            }
                        }
                    });
                },

                async renderActivityChart() {
                    const canvas = this.$refs.activityChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.activity) {
                        this.charts.activity.destroy();
                        this.charts.activity = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    // Create activity timeline
                    const now = new Date();
                    const days = [];
                    const activityCounts = [];
                    
                    for (let i = 6; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        days.push(date.toLocaleDateString('en-US', { weekday: 'short' }));
                        
                        const dayStart = new Date(date);
                        dayStart.setHours(0, 0, 0, 0);
                        const dayEnd = new Date(date);
                        dayEnd.setHours(23, 59, 59, 999);
                        
                        const count = this.memories.filter(m => {
                            const memDate = new Date(m.created_at * 1000);
                            return memDate >= dayStart && memDate <= dayEnd;
                        }).length;
                        
                        activityCounts.push(count);
                    }
                    
                    this.charts.activity = new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: days,
                            datasets: [{
                                label: 'Memories Created',
                                data: activityCounts,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointBackgroundColor: '#10b981',
                                pointBorderColor: '#10b981',
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: '#9ca3af'
                                    },
                                    grid: {
                                        display: false
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#9ca3af',
                                        stepSize: 1
                                    },
                                    grid: {
                                        color: 'rgba(156, 163, 175, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                },

                exportCurrentView() {
                    // Implement export functionality
                    this.showToast('Export functionality coming soon!', 'info');
                },

                cleanupCharts() {
                    // Clear all timers first to prevent continued updates
                    if (this.performanceChartsUpdateTimer) {
                        clearTimeout(this.performanceChartsUpdateTimer);
                        this.performanceChartsUpdateTimer = null;
                    }
                    if (this.workingMemoryChartsUpdateTimer) {
                        clearTimeout(this.workingMemoryChartsUpdateTimer);
                        this.workingMemoryChartsUpdateTimer = null;
                    }
                    
                    // Cleanup all Chart.js instances to prevent memory leaks
                    if (this.charts) {
                        Object.values(this.charts).forEach(chart => {
                            if (chart && typeof chart.destroy === 'function') {
                                try {
                                    chart.destroy();
                                } catch (e) {
                                    console.warn('Error destroying chart:', e);
                                }
                            }
                        });
                        this.charts = {};
                    }
                    
                    if (this.workingMemoryCharts) {
                        Object.values(this.workingMemoryCharts).forEach(chart => {
                            if (chart && typeof chart.destroy === 'function') {
                                try {
                                    chart.destroy();
                                } catch (e) {
                                    console.warn('Error destroying working memory chart:', e);
                                }
                            }
                        });
                        this.workingMemoryCharts = {};
                    }
                    
                    // Cleanup action performance charts
                    if (this.actionPerformanceCharts) {
                        Object.values(this.actionPerformanceCharts).forEach(chart => {
                            if (chart && typeof chart.destroy === 'function') {
                                try {
                                    chart.destroy();
                                } catch (e) {
                                    console.warn('Error destroying action performance chart:', e);
                                }
                            }
                        });
                        this.actionPerformanceCharts = {};
                    }
                    
                    console.log('Charts and timers cleaned up');
                },

                // =================== GRAPH METHODS ===================

                async loadGraphData() {
                    try {
                        // Load memory links
                        const links = this.executeQuery(`
                            SELECT ml.*, 
                                   m1.memory_type as source_type,
                                   m1.memory_level as source_level,
                                   m1.content as source_content,
                                   m1.importance as source_importance,
                                   m2.memory_type as target_type,
                                   m2.memory_level as target_level,
                                   m2.content as target_content,
                                   m2.importance as target_importance
                            FROM memory_links ml
                            LEFT JOIN memories m1 ON ml.source_memory_id = m1.memory_id
                            LEFT JOIN memories m2 ON ml.target_memory_id = m2.memory_id
                            WHERE m1.memory_id IS NOT NULL AND m2.memory_id IS NOT NULL
                        `);

                        // Create nodes from memories
                        const nodeMap = new Map();
                        
                        // Add all memories as potential nodes
                        this.memories.forEach(memory => {
                            nodeMap.set(memory.memory_id, {
                                id: memory.memory_id,
                                ...memory,
                                x: Math.random() * 800,
                                y: Math.random() * 600,
                                connections: 0,
                                cluster: null
                            });
                        });
                        
                        // Process existing explicit links and update connection counts
                        const processedLinks = [];
                        links.forEach(link => {
                            if (nodeMap.has(link.source_memory_id) && nodeMap.has(link.target_memory_id)) {
                                processedLinks.push({
                                    source: link.source_memory_id,
                                    target: link.target_memory_id,
                                    link_type: link.link_type,
                                    strength: link.strength || 1,
                                    created_at: link.created_at
                                });
                                
                                // Update connection counts
                                nodeMap.get(link.source_memory_id).connections++;
                                nodeMap.get(link.target_memory_id).connections++;
                            }
                        });
                        
                        // If no explicit links exist, create implicit connections based on workflows and memory types
                        if (processedLinks.length === 0 && this.memories.length > 0) {
                            console.log('No explicit memory links found, creating implicit connections...');
                            
                            // Group memories by workflow
                            const workflowGroups = new Map();
                            const typeGroups = new Map();
                            
                            this.memories.forEach(memory => {
                                // Group by workflow
                                if (memory.workflow_id) {
                                    if (!workflowGroups.has(memory.workflow_id)) {
                                        workflowGroups.set(memory.workflow_id, []);
                                    }
                                    workflowGroups.get(memory.workflow_id).push(memory);
                                }
                                
                                // Group by memory type
                                if (!typeGroups.has(memory.memory_type)) {
                                    typeGroups.set(memory.memory_type, []);
                                }
                                typeGroups.get(memory.memory_type).push(memory);
                            });
                            
                            // Create workflow-based connections
                            workflowGroups.forEach((memories, workflowId) => {
                                if (memories.length > 1) {
                                    for (let i = 0; i < memories.length - 1; i++) {
                                        for (let j = i + 1; j < Math.min(memories.length, i + 3); j++) {
                                            processedLinks.push({
                                                source: memories[i].memory_id,
                                                target: memories[j].memory_id,
                                                link_type: 'workflow_related',
                                                strength: 0.6,
                                                created_at: Math.max(memories[i].created_at, memories[j].created_at)
                                            });
                                            
                                            nodeMap.get(memories[i].memory_id).connections++;
                                            nodeMap.get(memories[j].memory_id).connections++;
                                        }
                                    }
                                }
                            });
                            
                            // Create type-based connections (limited to avoid overcrowding)
                            typeGroups.forEach((memories, memoryType) => {
                                if (memories.length > 1 && memories.length <= 10) {
                                    // Connect similar memory types, but limit connections
                                    const sortedByImportance = memories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
                                    for (let i = 0; i < Math.min(3, sortedByImportance.length - 1); i++) {
                                        for (let j = i + 1; j < Math.min(sortedByImportance.length, i + 2); j++) {
                                            // Only create if not already connected via workflow
                                            const existingLink = processedLinks.find(link => 
                                                (link.source === sortedByImportance[i].memory_id && link.target === sortedByImportance[j].memory_id) ||
                                                (link.source === sortedByImportance[j].memory_id && link.target === sortedByImportance[i].memory_id)
                                            );
                                            
                                            if (!existingLink) {
                                                processedLinks.push({
                                                    source: sortedByImportance[i].memory_id,
                                                    target: sortedByImportance[j].memory_id,
                                                    link_type: 'type_similarity',
                                                    strength: 0.4,
                                                    created_at: Math.max(sortedByImportance[i].created_at, sortedByImportance[j].created_at)
                                                });
                                                
                                                nodeMap.get(sortedByImportance[i].memory_id).connections++;
                                                nodeMap.get(sortedByImportance[j].memory_id).connections++;
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Show all nodes if we have memories, prioritizing those with connections
                        let nodesToShow = Array.from(nodeMap.values());
                        
                        // If we have too many nodes (>50), prioritize connected ones and high importance ones
                        if (nodesToShow.length > 50) {
                            const connectedNodes = nodesToShow.filter(node => node.connections > 0);
                            const unconnectedImportant = nodesToShow
                                .filter(node => node.connections === 0 && (node.importance || 0) >= 7)
                                .sort((a, b) => (b.importance || 0) - (a.importance || 0))
                                .slice(0, Math.max(0, 50 - connectedNodes.length));
                            
                            nodesToShow = [...connectedNodes, ...unconnectedImportant];
                        }
                        
                        // If still no connections and we have memories, show at least the top memories
                        if (processedLinks.length === 0 && this.memories.length > 0) {
                            nodesToShow = nodesToShow
                                .sort((a, b) => (b.importance || 0) - (a.importance || 0))
                                .slice(0, Math.min(20, this.memories.length));
                        }
                        
                        this.graphData = {
                            nodes: nodesToShow,
                            links: processedLinks
                        };
                        
                        // Generate clusters
                        this.generateClusters();
                        
                        console.log(`Graph loaded: ${this.graphData.nodes.length} nodes, ${this.graphData.links.length} links`);
                        if (processedLinks.length === 0 && this.memories.length > 0) {
                            console.log('Note: No connections found. Showing memories without links.');
                        }
                        
                    } catch (error) {
                        console.error('Error loading graph data:', error);
                        this.showToast('Error loading graph data', 'error');
                    }
                },

                async initializeGraph() {
                    if (!window.d3 || !this.graphData.nodes.length) {
                        console.log('D3 not available or no graph data');
                        return;
                    }
                    
                    try {
                        const svg = d3.select(this.$refs.graphSvg);
                        const container = this.$refs.graphSvg.parentElement;
                        const rect = container.getBoundingClientRect();
                        
                        const width = rect.width;
                        const height = rect.height;
                        
                        // Clear previous content
                        svg.selectAll("*").remove();
                        
                        // Set dimensions
                        svg.attr("width", width).attr("height", height);
                        
                        // Initialize zoom
                        this.zoom = d3.zoom()
                            .scaleExtent([0.1, 10])
                            .on("zoom", (event) => {
                                svg.select(".graph-content").attr("transform", event.transform);
                            });
                        
                        svg.call(this.zoom);
                        
                        // Create main group for all graph content
                        const g = svg.append("g").attr("class", "graph-content");
                        
                        // Initialize force simulation
                        this.simulation = d3.forceSimulation(this.graphData.nodes)
                            .force("link", d3.forceLink(this.graphData.links)
                                .id(d => d.id)
                                .distance(this.graphSettings.linkDistance))
                            .force("charge", d3.forceManyBody()
                                .strength(this.graphSettings.forceStrength))
                            .force("center", d3.forceCenter(width / 2, height / 2))
                            .force("collision", d3.forceCollide().radius(15));
                        
                        // Draw links
                        const link = g.append("g")
                            .attr("class", "links")
                            .selectAll("line")
                            .data(this.graphData.links)
                            .enter().append("line")
                            .attr("class", "graph-link")
                            .attr("stroke", d => this.getLinkColor(d.link_type))
                            .attr("stroke-width", d => Math.sqrt(d.strength || 1) * 2);
                        
                        // Draw nodes
                        const node = g.append("g")
                            .attr("class", "nodes")
                            .selectAll("circle")
                            .data(this.graphData.nodes)
                            .enter().append("circle")
                            .attr("class", "graph-node")
                            .attr("r", d => Math.max(5, Math.min(15, 5 + Math.sqrt(d.connections * 2))))
                            .attr("fill", d => this.getNodeColor(d))
                            .attr("stroke", d => d3.color(this.getNodeColor(d)).darker(1))
                            .call(this.createDrag());
                        
                        // Add labels
                        const labels = g.append("g")
                            .attr("class", "labels")
                            .selectAll("text")
                            .data(this.graphData.nodes)
                            .enter().append("text")
                            .attr("class", "graph-text")
                            .text(d => d.memory_type.substring(0, 8))
                            .attr("dy", "0.35em");
                        
                        // Add interactions
                        node
                            .on("mouseover", (event, d) => this.showGraphTooltip(event, d))
                            .on("mouseout", () => this.hideGraphTooltip())
                            .on("click", (event, d) => this.selectGraphNode(d));
                        
                        // Update positions on simulation tick
                        this.simulation.on("tick", () => {
                            link
                                .attr("x1", d => d.source.x)
                                .attr("y1", d => d.source.y)
                                .attr("x2", d => d.target.x)
                                .attr("y2", d => d.target.y);
                            
                            node
                                .attr("cx", d => d.x)
                                .attr("cy", d => d.y);
                            
                            labels
                                .attr("x", d => d.x)
                                .attr("y", d => d.y + 20);
                        });
                        
                        // Store references
                        this.svg = svg;
                        this.updateLegend();
                        
                        console.log('Graph initialized successfully');
                        
                    } catch (error) {
                        console.error('Error initializing graph:', error);
                        this.showToast('Error initializing graph', 'error');
                    }
                },

                createDrag() {
                    return d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        });
                },

                getNodeColor(node) {
                    switch (this.graphSettings.colorBy) {
                        case 'memory_level':
                            const levelColors = {
                                working: '#f59e0b',
                                episodic: '#3b82f6',
                                semantic: '#10b981',
                                procedural: '#8b5cf6'
                            };
                            return levelColors[node.memory_level] || '#6b7280';
                        
                        case 'memory_type':
                            // Generate color based on memory type hash
                            const hash = node.memory_type.split('').reduce((a, b) => {
                                a = ((a << 5) - a) + b.charCodeAt(0);
                                return a & a;
                            }, 0);
                            const hue = Math.abs(hash) % 360;
                            return `hsl(${hue}, 70%, 60%)`;
                        
                        case 'workflow':
                            if (!node.workflow_id) return '#6b7280';
                            const workflowHash = node.workflow_id.split('').reduce((a, b) => {
                                a = ((a << 5) - a) + b.charCodeAt(0);
                                return a & a;
                            }, 0);
                            const workflowHue = Math.abs(workflowHash) % 360;
                            return `hsl(${workflowHue}, 60%, 50%)`;
                        
                        case 'importance':
                            const importance = node.importance || 0;
                            const intensity = importance / 10;
                            return d3.interpolateReds(intensity);
                        
                        default:
                            return '#3b82f6';
                    }
                },

                getLinkColor(linkType) {
                    const colors = {
                        'references': '#3b82f6',
                        'causal': '#10b981',
                        'similarity': '#8b5cf6',
                        'temporal': '#f59e0b',
                        'spatial': '#ef4444',
                        'workflow_related': '#06b6d4',  // cyan for workflow connections
                        'type_similarity': '#a855f7'   // purple for type similarity
                    };
                    return colors[linkType] || '#6b7280';
                },

                updateLegend() {
                    const legend = [];
                    
                    switch (this.graphSettings.colorBy) {
                        case 'memory_level':
                            legend.push(
                                { key: 'working', label: 'Working', color: '#f59e0b' },
                                { key: 'episodic', label: 'Episodic', color: '#3b82f6' },
                                { key: 'semantic', label: 'Semantic', color: '#10b981' },
                                { key: 'procedural', label: 'Procedural', color: '#8b5cf6' }
                            );
                            break;
                        
                        case 'memory_type':
                            const types = [...new Set(this.graphData.nodes.map(n => n.memory_type))];
                            types.slice(0, 8).forEach(type => {
                                const hash = type.split('').reduce((a, b) => {
                                    a = ((a << 5) - a) + b.charCodeAt(0);
                                    return a & a;
                                }, 0);
                                const hue = Math.abs(hash) % 360;
                                legend.push({
                                    key: type,
                                    label: type,
                                    color: `hsl(${hue}, 70%, 60%)`
                                });
                            });
                            break;
                        
                        case 'importance':
                            legend.push(
                                { key: 'low', label: 'Low (1-3)', color: d3.interpolateReds(0.3) },
                                { key: 'medium', label: 'Medium (4-6)', color: d3.interpolateReds(0.6) },
                                { key: 'high', label: 'High (7-10)', color: d3.interpolateReds(0.9) }
                            );
                            break;
                    }
                    
                    this.currentLegend = legend;
                },

                showGraphTooltip(event, node) {
                    this.graphTooltip = {
                        visible: true,
                        x: event.pageX + 10,
                        y: event.pageY - 10,
                        title: node.memory_type,
                        subtitle: `${node.memory_level}  ${node.connections} connections`,
                        content: node.content.substring(0, 100) + (node.content.length > 100 ? '...' : '')
                    };
                },

                hideGraphTooltip() {
                    this.graphTooltip.visible = false;
                },

                selectGraphNode(node) {
                    this.selectedGraphNode = node;
                    
                    // Highlight connected nodes and links
                    if (this.svg) {
                        this.svg.selectAll('.graph-node')
                            .classed('selected', d => d.id === node.id);
                        
                        this.svg.selectAll('.graph-link')
                            .classed('highlighted', d => 
                                d.source.id === node.id || d.target.id === node.id
                            );
                    }
                },

                getNodeConnections(node) {
                    if (!node) return [];
                    
                    return this.graphData.links
                        .filter(link => link.source.id === node.id || link.target.id === node.id)
                        .map(link => ({
                            id: link.source.id === node.id ? link.target.id : link.source.id,
                            target: link.source.id === node.id ? link.target : link.source,
                            link_type: link.link_type,
                            strength: link.strength
                        }));
                },

                focusOnNode(node) {
                    this.selectGraphNode(node);
                    
                    if (this.svg && this.zoom) {
                        const scale = 2;
                        const translate = [
                            this.svg.node().clientWidth / 2 - node.x * scale,
                            this.svg.node().clientHeight / 2 - node.y * scale
                        ];
                        
                        this.svg.transition().duration(750).call(
                            this.zoom.transform,
                            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                        );
                    }
                },

                expandNeighborhood(node) {
                    // Find neighbors that aren't currently visible
                    const connectedIds = new Set(this.getNodeConnections(node).map(c => c.id));
                    const visibleIds = new Set(this.graphData.nodes.map(n => n.id));
                    
                    // Add any missing connected memories to the graph
                    const nodesToAdd = this.memories.filter(memory => 
                        connectedIds.has(memory.memory_id) && !visibleIds.has(memory.memory_id)
                    );
                    
                    if (nodesToAdd.length > 0) {
                        this.graphData.nodes.push(...nodesToAdd.map(memory => ({
                            id: memory.memory_id,
                            ...memory,
                            x: node.x + (Math.random() - 0.5) * 100,
                            y: node.y + (Math.random() - 0.5) * 100,
                            connections: 0,
                            cluster: null
                        })));
                        
                        this.initializeGraph();
                        this.showToast(`Expanded neighborhood: +${nodesToAdd.length} nodes`, 'success');
                    } else {
                        this.showToast('No additional connections to expand', 'info');
                    }
                },

                updateGraphLayout() {
                    if (!this.simulation) return;
                    
                    switch (this.graphSettings.layout) {
                        case 'force':
                            this.simulation
                                .force("charge", d3.forceManyBody().strength(this.graphSettings.forceStrength))
                                .force("center", d3.forceCenter(
                                    this.svg.node().clientWidth / 2, 
                                    this.svg.node().clientHeight / 2
                                ));
                            break;
                        
                        case 'hierarchical':
                            this.applyHierarchicalLayout();
                            break;
                        
                        case 'circular':
                            this.applyCircularLayout();
                            break;
                        
                        case 'cluster':
                            this.applyClusterLayout();
                            break;
                    }
                    
                    this.simulation.alpha(1).restart();
                },

                applyHierarchicalLayout() {
                    const levels = ['working', 'episodic', 'semantic', 'procedural'];
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    
                    this.graphData.nodes.forEach((node, i) => {
                        const levelIndex = levels.indexOf(node.memory_level);
                        node.fx = (levelIndex + 1) * (width / (levels.length + 1));
                        node.fy = (i % 10) * (height / 10) + height / 20;
                    });
                },

                applyCircularLayout() {
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    const radius = Math.min(width, height) / 3;
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    this.graphData.nodes.forEach((node, i) => {
                        const angle = (i / this.graphData.nodes.length) * 2 * Math.PI;
                        node.fx = centerX + radius * Math.cos(angle);
                        node.fy = centerY + radius * Math.sin(angle);
                    });
                },

                applyClusterLayout() {
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    const clusters = this.graphClusters;
                    
                    clusters.forEach((cluster, clusterIndex) => {
                        const clusterCenterX = (clusterIndex % 3) * (width / 3) + width / 6;
                        const clusterCenterY = Math.floor(clusterIndex / 3) * (height / 3) + height / 6;
                        const clusterRadius = 80;
                        
                        cluster.nodes.forEach((node, nodeIndex) => {
                            const angle = (nodeIndex / cluster.nodes.length) * 2 * Math.PI;
                            node.fx = clusterCenterX + clusterRadius * Math.cos(angle);
                            node.fy = clusterCenterY + clusterRadius * Math.sin(angle);
                        });
                    });
                },

                updateGraphColors() {
                    if (!this.svg) return;
                    
                    this.svg.selectAll('.graph-node')
                        .attr('fill', d => this.getNodeColor(d))
                        .attr('stroke', d => d3.color(this.getNodeColor(d)).darker(1));
                    
                    this.updateLegend();
                },

                updatePhysics() {
                    if (!this.simulation) return;
                    
                    this.simulation
                        .force("charge", d3.forceManyBody().strength(this.graphSettings.forceStrength))
                        .force("link", d3.forceLink(this.graphData.links)
                            .id(d => d.id)
                            .distance(this.graphSettings.linkDistance));
                    
                    this.simulation.alpha(0.3).restart();
                },

                togglePhysics() {
                    this.graphSettings.physicsEnabled = !this.graphSettings.physicsEnabled;
                    
                    if (this.simulation) {
                        if (this.graphSettings.physicsEnabled) {
                            this.simulation.alpha(0.3).restart();
                        } else {
                            this.simulation.stop();
                        }
                    }
                },

                toggleMemoryLevel(level) {
                    const index = this.graphSettings.visibleLevels.indexOf(level);
                    if (index > -1) {
                        this.graphSettings.visibleLevels.splice(index, 1);
                    } else {
                        this.graphSettings.visibleLevels.push(level);
                    }
                    
                    this.filterGraphNodes();
                },

                filterGraphNodes() {
                    if (!this.svg) return;
                    
                    this.svg.selectAll('.graph-node')
                        .style('opacity', d => 
                            this.graphSettings.visibleLevels.includes(d.memory_level) ? 1 : 0.1
                        );
                    
                    this.svg.selectAll('.graph-link')
                        .style('opacity', d => 
                            this.graphSettings.visibleLevels.includes(d.source.memory_level) && 
                            this.graphSettings.visibleLevels.includes(d.target.memory_level) ? 0.6 : 0.1
                        );
                },

                resetGraphView() {
                    if (this.zoom && this.svg) {
                        this.svg.transition().duration(750).call(
                            this.zoom.transform,
                            d3.zoomIdentity
                        );
                    }
                    
                    this.selectedGraphNode = null;
                    
                    if (this.svg) {
                        this.svg.selectAll('.graph-node').classed('selected', false);
                        this.svg.selectAll('.graph-link').classed('highlighted', false);
                    }
                    
                    // Reset node positions
                    if (this.simulation) {
                        this.graphData.nodes.forEach(node => {
                            node.fx = null;
                            node.fy = null;
                        });
                        this.simulation.alpha(1).restart();
                    }
                },

                calculateGraphDensity() {
                    const nodeCount = this.graphData.nodes.length;
                    const linkCount = this.graphData.links.length;
                    const maxPossibleLinks = (nodeCount * (nodeCount - 1)) / 2;
                    
                    if (maxPossibleLinks === 0) return '0%';
                    
                    const density = (linkCount / maxPossibleLinks) * 100;
                    return density.toFixed(1) + '%';
                },

                generateClusters() {
                    try {
                        if (!this.graphData.nodes || this.graphData.nodes.length === 0) {
                            this.graphClusters = [];
                            return;
                        }

                        // Simple clustering algorithm based on connected components
                        const visited = new Set();
                        const clusters = [];
                        
                        this.graphData.nodes.forEach(node => {
                            if (!visited.has(node.id)) {
                                const cluster = this.expandCluster(node, visited);
                                if (cluster.nodes.length > 1) {
                                    clusters.push({
                                        id: `cluster-${clusters.length}`,
                                        nodes: cluster.nodes,
                                        center: this.calculateClusterCenter(cluster.nodes),
                                        size: cluster.nodes.length,
                                        dominantType: this.getDominantType(cluster.nodes)
                                    });
                                }
                            }
                        });

                        // If no multi-node clusters found, create simple clusters based on memory type
                        if (clusters.length === 0) {
                            const typeGroups = new Map();
                            
                            this.graphData.nodes.forEach(node => {
                                const type = node.memory_type || 'unknown';
                                if (!typeGroups.has(type)) {
                                    typeGroups.set(type, []);
                                }
                                typeGroups.get(type).push(node);
                            });

                            typeGroups.forEach((nodes, type) => {
                                if (nodes.length > 1) {
                                    clusters.push({
                                        id: `cluster-type-${type}`,
                                        nodes: nodes,
                                        center: this.calculateClusterCenter(nodes),
                                        size: nodes.length,
                                        dominantType: type
                                    });
                                }
                            });
                        }

                        this.graphClusters = clusters;
                        console.log(`Generated ${clusters.length} clusters`);
                        
                    } catch (error) {
                        console.error('Error generating clusters:', error);
                        this.graphClusters = [];
                    }
                },

                expandCluster(startNode, visited) {
                    const cluster = { nodes: [] };
                    const stack = [startNode];
                    
                    while (stack.length > 0) {
                        const node = stack.pop();
                        
                        if (!visited.has(node.id)) {
                            visited.add(node.id);
                            cluster.nodes.push(node);
                            
                            // Find connected nodes
                            const connectedNodes = this.getConnectedNodes(node);
                            connectedNodes.forEach(connectedNode => {
                                if (!visited.has(connectedNode.id)) {
                                    stack.push(connectedNode);
                                }
                            });
                        }
                    }
                    
                    return cluster;
                },

                getConnectedNodes(node) {
                    const connected = [];
                    
                    this.graphData.links.forEach(link => {
                        if (link.source.id === node.id || link.source === node.id) {
                            const targetNode = this.graphData.nodes.find(n => 
                                n.id === (link.target.id || link.target)
                            );
                            if (targetNode) connected.push(targetNode);
                        } else if (link.target.id === node.id || link.target === node.id) {
                            const sourceNode = this.graphData.nodes.find(n => 
                                n.id === (link.source.id || link.source)
                            );
                            if (sourceNode) connected.push(sourceNode);
                        }
                    });
                    
                    return connected;
                },

                calculateClusterCenter(nodes) {
                    if (nodes.length === 0) return { x: 0, y: 0 };
                    
                    const sumX = nodes.reduce((sum, node) => sum + (node.x || 0), 0);
                    const sumY = nodes.reduce((sum, node) => sum + (node.y || 0), 0);
                    
                    return {
                        x: sumX / nodes.length,
                        y: sumY / nodes.length
                    };
                },

                getDominantType(nodes) {
                    const typeCounts = new Map();
                    
                    nodes.forEach(node => {
                        const type = node.memory_type || 'unknown';
                        typeCounts.set(type, (typeCounts.get(type) || 0) + 1);
                    });
                    
                    let dominantType = 'mixed';
                    let maxCount = 0;
                    
                    typeCounts.forEach((count, type) => {
                        if (count > maxCount) {
                            maxCount = count;
                            dominantType = type;
                        }
                    });
                    
                    return dominantType;
                },
                
                // =================== THOUGHT CHAIN METHODS ===================

                async initializeThoughtChains() {
                    if (!this.dbLoaded || !window.mermaid) {
                        console.log('Database not loaded or Mermaid not available');
                        return;
                    }
                    
                    try {
                        // Initialize Mermaid with dark theme
                        mermaid.initialize({
                            theme: 'dark',
                            themeVariables: {
                                primaryColor: '#3b82f6',
                                primaryTextColor: '#e5e7eb',
                                primaryBorderColor: '#1d4ed8',
                                lineColor: 'rgba(255, 255, 255, 0.4)',
                                secondaryColor: '#1f2937',
                                tertiaryColor: '#374151',
                                background: 'transparent',
                                mainBkg: '#1f2937',
                                secondBkg: '#374151',
                                tertiaryBkg: '#4b5563'
                            },
                            flowchart: {
                                nodeSpacing: 50,
                                rankSpacing: 80,
                                curve: 'basis',
                                padding: 20
                            },
                            fontSize: 14,
                            fontFamily: 'Inter, sans-serif'
                        });
                        
                        // Load thought chain data
                        await this.loadThoughtChainData();
                        
                        console.log(' Thought Chains initialized successfully');
                        
                    } catch (error) {
                        console.error(' Error initializing thought chains:', error);
                        this.showToast('Error initializing thought chains', 'error');
                    }
                },

                async loadThoughtChainData() {
                    if (!this.dbLoaded) {
                        console.log('Database not loaded, skipping thought chain data');
                        return;
                    }
                    
                    this.isProcessing = true;
                    this.loadingMessage = 'Loading thought chains...';
                    
                    try {
                        // Load thoughts (memories with type = 'thought')
                        const thoughts = this.executeQuery(`
                            SELECT * FROM memories 
                            WHERE memory_type = 'thought' 
                            ORDER BY created_at ASC
                        `);
                        
                        // If no thoughts found, try to load any memories that might contain reasoning
                        let allThoughts = thoughts;
                        if (thoughts.length === 0) {
                            // Fallback: load memories that contain reasoning-like content
                            allThoughts = this.executeQuery(`
                                SELECT * FROM memories 
                                WHERE (content LIKE '%reasoning%' OR 
                                       content LIKE '%thinking%' OR 
                                       content LIKE '%decision%' OR
                                       content LIKE '%analysis%' OR
                                       memory_type IN ('goal', 'plan', 'observation'))
                                ORDER BY created_at ASC
                            `);
                        }
                        
                        // Load memory links to understand parent-child relationships
                        let thoughtLinks = [];
                        if (allThoughts.length > 0) {
                            const thoughtIds = allThoughts.map(t => `'${t.memory_id}'`).join(',');
                            thoughtLinks = this.executeQuery(`
                                SELECT ml.*, 
                                       m1.memory_type as source_type,
                                       m2.memory_type as target_type
                                FROM memory_links ml
                                LEFT JOIN memories m1 ON ml.source_memory_id = m1.memory_id
                                LEFT JOIN memories m2 ON ml.target_memory_id = m2.memory_id
                                WHERE (m1.memory_id IN (${thoughtIds}) OR 
                                       m2.memory_id IN (${thoughtIds}))
                                AND ml.link_type IN ('causal', 'temporal', 'references')
                                ORDER BY ml.created_at ASC
                            `);
                        }
                        
                        // Build thought chains
                        this.thoughtChains = this.buildThoughtChains(allThoughts, thoughtLinks);
                        
                        // Calculate statistics
                        this.calculateThoughtChainStats();
                        
                        console.log(`Loaded ${this.thoughtChains.length} thought chains from ${allThoughts.length} thoughts`);
                        
                    } catch (error) {
                        console.error('Error loading thought chain data:', error);
                        // Don't show error toast for missing thought data, just log it
                        console.log('No thought chain data available or error in processing');
                        this.thoughtChains = [];
                        this.calculateThoughtChainStats();
                    } finally {
                        this.isProcessing = false;
                        this.loadingMessage = '';
                    }
                },

                buildThoughtChains(thoughts, links) {
                    // Create a map of thought relationships
                    const thoughtMap = new Map();
                    const childrenMap = new Map();
                    const parentMap = new Map();
                    
                    // Index all thoughts
                    thoughts.forEach(thought => {
                        thoughtMap.set(thought.memory_id, {
                            ...thought,
                            children: [],
                            hasChildren: false,
                            isBranch: false
                        });
                        childrenMap.set(thought.memory_id, []);
                    });
                    
                    // Build parent-child relationships from links
                    links.forEach(link => {
                        const sourceId = link.source_memory_id;
                        const targetId = link.target_memory_id;
                        
                        if (thoughtMap.has(sourceId) && thoughtMap.has(targetId)) {
                            childrenMap.get(sourceId).push(targetId);
                            parentMap.set(targetId, sourceId);
                            
                            const sourceThought = thoughtMap.get(sourceId);
                            sourceThought.children.push(targetId);
                            sourceThought.hasChildren = true;
                            
                            // Mark as branch if more than one child
                            if (sourceThought.children.length > 1) {
                                sourceThought.isBranch = true;
                            }
                        }
                    });
                    
                    const chains = [];
                    const processedThoughts = new Set();
                    
                    // If we have explicit links, use them to build chains
                    if (links.length > 0) {
                        // Find root thoughts (thoughts with no parents or workflow starts)
                        const rootThoughts = thoughts.filter(thought => 
                            !parentMap.has(thought.memory_id) || 
                            this.isWorkflowStart(thought)
                        );
                        
                        // Build chains from each root
                        rootThoughts.forEach(root => {
                            if (!processedThoughts.has(root.memory_id)) {
                                const chain = this.buildChainFromRoot(root, thoughtMap, childrenMap, processedThoughts);
                                if (chain.thoughts.length > 1) { // Only include chains with multiple thoughts
                                    chains.push(chain);
                                }
                            }
                        });
                    } else {
                        // No explicit links - group thoughts by workflow and time
                        console.log('No memory links found, grouping thoughts by workflow and time...');
                        
                        // Group thoughts by workflow
                        const workflowGroups = new Map();
                        const standaloneThoughts = [];
                        
                        thoughts.forEach(thought => {
                            if (thought.workflow_id) {
                                if (!workflowGroups.has(thought.workflow_id)) {
                                    workflowGroups.set(thought.workflow_id, []);
                                }
                                workflowGroups.get(thought.workflow_id).push(thought);
                            } else {
                                standaloneThoughts.push(thought);
                            }
                        });
                        
                        // Create chains from workflow groups
                        workflowGroups.forEach((workflowThoughts, workflowId) => {
                            // Sort by creation time
                            workflowThoughts.sort((a, b) => a.created_at - b.created_at);
                            
                            if (workflowThoughts.length >= 2) {
                                // Create a single chain for the workflow
                                const workflow = this.workflows.find(w => w.workflow_id === workflowId);
                                const chain = {
                                    id: `workflow-chain-${workflowId}`,
                                    title: workflow ? `${workflow.title || workflow.goal || 'Workflow'} - Thought Sequence` : `Workflow Thoughts (${workflowThoughts.length})`,
                                    description: `Thought sequence from ${new Date(workflowThoughts[0].created_at * 1000).toLocaleString()} to ${new Date(workflowThoughts[workflowThoughts.length - 1].created_at * 1000).toLocaleString()}`,
                                    thoughts: workflowThoughts.map(t => thoughtMap.get(t.memory_id)),
                                    created_at: workflowThoughts[0].created_at,
                                    hasBranches: false,
                                    branchCount: 0,
                                    complexity: workflowThoughts.length > 5 ? 'Medium' : 'Simple',
                                    workflow_id: workflowId
                                };
                                chains.push(chain);
                                workflowThoughts.forEach(t => processedThoughts.add(t.memory_id));
                            } else if (workflowThoughts.length === 1) {
                                // Single thought in workflow
                                const thought = workflowThoughts[0];
                                const workflow = this.workflows.find(w => w.workflow_id === workflowId);
                                const chain = {
                                    id: `single-workflow-${thought.memory_id}`,
                                    title: workflow ? `${workflow.title || workflow.goal || 'Workflow'} - Single Thought` : 'Workflow Thought',
                                    description: thought.content.substring(0, 100) + (thought.content.length > 100 ? '...' : ''),
                                    thoughts: [thoughtMap.get(thought.memory_id)],
                                    created_at: thought.created_at,
                                    hasBranches: false,
                                    branchCount: 0,
                                    complexity: 'Simple',
                                    workflow_id: workflowId
                                };
                                chains.push(chain);
                                processedThoughts.add(thought.memory_id);
                            }
                        });
                        
                        // Group standalone thoughts by time proximity (within 1 hour)
                        standaloneThoughts.sort((a, b) => a.created_at - b.created_at);
                        let currentGroup = [];
                        const timeThreshold = 3600; // 1 hour in seconds
                        
                        for (let i = 0; i < standaloneThoughts.length; i++) {
                            const thought = standaloneThoughts[i];
                            
                            if (currentGroup.length === 0) {
                                currentGroup.push(thought);
                            } else {
                                const lastThought = currentGroup[currentGroup.length - 1];
                                if (thought.created_at - lastThought.created_at <= timeThreshold) {
                                    currentGroup.push(thought);
                                } else {
                                    // Finalize current group
                                    if (currentGroup.length >= 2) {
                                        const chain = {
                                            id: `time-chain-${currentGroup[0].memory_id}`,
                                            title: `Thought Sequence (${currentGroup.length} thoughts)`,
                                            description: `Related thoughts from ${new Date(currentGroup[0].created_at * 1000).toLocaleString()}`,
                                            thoughts: currentGroup.map(t => thoughtMap.get(t.memory_id)),
                                            created_at: currentGroup[0].created_at,
                                            hasBranches: false,
                                            branchCount: 0,
                                            complexity: currentGroup.length > 3 ? 'Medium' : 'Simple',
                                            workflow_id: null
                                        };
                                        chains.push(chain);
                                        currentGroup.forEach(t => processedThoughts.add(t.memory_id));
                                    }
                                    
                                    // Start new group
                                    currentGroup = [thought];
                                }
                            }
                        }
                        
                        // Handle final group
                        if (currentGroup.length >= 2) {
                            const chain = {
                                id: `time-chain-${currentGroup[0].memory_id}`,
                                title: `Thought Sequence (${currentGroup.length} thoughts)`,
                                description: `Related thoughts from ${new Date(currentGroup[0].created_at * 1000).toLocaleString()}`,
                                thoughts: currentGroup.map(t => thoughtMap.get(t.memory_id)),
                                created_at: currentGroup[0].created_at,
                                hasBranches: false,
                                branchCount: 0,
                                complexity: currentGroup.length > 3 ? 'Medium' : 'Simple',
                                workflow_id: null
                            };
                            chains.push(chain);
                            currentGroup.forEach(t => processedThoughts.add(t.memory_id));
                        }
                    }
                    
                    // Handle any remaining orphaned thoughts by creating simple chains
                    thoughts.forEach(thought => {
                        if (!processedThoughts.has(thought.memory_id)) {
                            const chain = {
                                id: `orphan-${thought.memory_id}`,
                                title: `Individual ${thought.memory_type}`,
                                description: thought.content.substring(0, 100) + (thought.content.length > 100 ? '...' : ''),
                                thoughts: [thoughtMap.get(thought.memory_id)],
                                created_at: thought.created_at,
                                hasBranches: false,
                                branchCount: 0,
                                complexity: 'Simple',
                                workflow_id: thought.workflow_id
                            };
                            chains.push(chain);
                            processedThoughts.add(thought.memory_id);
                        }
                    });
                    
                    return chains.sort((a, b) => b.created_at - a.created_at);
                },

                buildChainFromRoot(root, thoughtMap, childrenMap, processedThoughts) {
                    const chainThoughts = [];
                    const visited = new Set();
                    let branchCount = 0;
                    
                    // Traverse the chain using DFS
                    const traverse = (thoughtId, depth = 0) => {
                        if (visited.has(thoughtId) || depth > 50) return; // Prevent infinite loops
                        
                        visited.add(thoughtId);
                        processedThoughts.add(thoughtId);
                        
                        const thought = thoughtMap.get(thoughtId);
                        if (thought) {
                            chainThoughts.push(thought);
                            
                            // Count branches
                            if (thought.children.length > 1) {
                                branchCount++;
                            }
                            
                            // Follow the main path (first child) and note branches
                            thought.children.forEach((childId, index) => {
                                if (index === 0) {
                                    // Main path
                                    traverse(childId, depth + 1);
                                } else {
                                    // Branch - for now, just note it exists
                                    // In a more complex implementation, we'd create sub-chains
                                    branchCount++;
                                }
                            });
                        }
                    };
                    
                    traverse(root.memory_id);
                    
                    // Determine complexity
                    let complexity = 'Simple';
                    if (chainThoughts.length > 10 || branchCount > 2) {
                        complexity = 'Complex';
                    } else if (chainThoughts.length > 5 || branchCount > 0) {
                        complexity = 'Medium';
                    }
                    
                    // Generate title and description
                    const title = this.generateChainTitle(chainThoughts, root);
                    const description = this.generateChainDescription(chainThoughts);
                    
                    return {
                        id: `chain-${root.memory_id}`,
                        title,
                        description,
                        thoughts: chainThoughts,
                        created_at: root.created_at,
                        hasBranches: branchCount > 0,
                        branchCount,
                        complexity,
                        workflow_id: root.workflow_id
                    };
                },

                generateChainTitle(thoughts, root) {
                    const workflow = this.workflows.find(w => w.workflow_id === root.workflow_id);
                    
                    if (workflow) {
                        return `${workflow.title || 'Workflow'} - Reasoning Chain`;
                    }
                    
                    // Generate title based on thought types
                    const types = [...new Set(thoughts.map(t => t.memory_type))];
                    if (types.length === 1) {
                        return `${types[0]} Chain (${thoughts.length} steps)`;
                    } else {
                        return `Mixed Reasoning Chain (${thoughts.length} steps)`;
                    }
                },

                generateChainDescription(thoughts) {
                    if (thoughts.length === 0) return 'Empty chain';
                    
                    const first = thoughts[0];
                    const last = thoughts[thoughts.length - 1];
                    
                    return `From: ${first.content.substring(0, 50)}... To: ${last.content.substring(0, 50)}...`;
                },

                isWorkflowStart(thought) {
                    // Check if this thought appears to be the start of a workflow
                    return thought.content.toLowerCase().includes('goal') || 
                           thought.content.toLowerCase().includes('objective') ||
                           thought.content.toLowerCase().includes('task');
                },

                calculateThoughtChainStats() {
                    const totalChains = this.thoughtChains.length;
                    const totalThoughts = this.thoughtChains.reduce((sum, chain) => sum + chain.thoughts.length, 0);
                    const totalBranches = this.thoughtChains.reduce((sum, chain) => sum + chain.branchCount, 0);
                    const avgChainLength = totalChains > 0 ? totalThoughts / totalChains : 0;
                    
                    this.thoughtChainStats = {
                        totalChains,
                        totalThoughts,
                        avgChainLength,
                        branchingPoints: totalBranches
                    };
                },

                selectThoughtChain(chain) {
                    this.currentChain = chain;
                    this.thoughtsInCurrentChain = [...chain.thoughts];
                    this.thoughtTimelineLength = chain.thoughts.length;
                    this.thoughtTimelinePosition = 0;
                    this.currentThoughtIndex = 0;
                    
                    // Generate and render the mermaid diagram
                    this.generateMermaidDiagram(chain);
                    this.renderMermaidDiagram();
                },

                generateMermaidDiagram(chain) {
                    let diagram = 'flowchart TD\n';
                    
                    chain.thoughts.forEach((thought, index) => {
                        const nodeId = `T${index}`;
                        const label = this.sanitizeForMermaid(thought.memory_type);
                        const nodeClass = this.getMermaidNodeClass(thought);
                        
                        // Add node
                        diagram += `    ${nodeId}[${label}]:::${nodeClass}\n`;
                        
                        // Add connections to next thoughts
                        if (index < chain.thoughts.length - 1) {
                            diagram += `    ${nodeId} --> T${index + 1}\n`;
                        }
                        
                        // Add branches if they exist
                        if (thought.children && thought.children.length > 1) {
                            thought.children.slice(1).forEach((childId, branchIndex) => {
                                const branchNodeId = `B${index}_${branchIndex}`;
                                diagram += `    ${branchNodeId}[Branch ${branchIndex + 1}]:::branch\n`;
                                diagram += `    ${nodeId} --> ${branchNodeId}\n`;
                            });
                        }
                    });
                    
                    // Add styling
                    diagram += `
    classDef default fill:#1f2937,stroke:#3b82f6,stroke-width:2px,color:#e5e7eb
    classDef active fill:#3b82f6,stroke:#1d4ed8,stroke-width:3px,color:#ffffff
    classDef branch fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#ffffff
    classDef decision fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#ffffff
    classDef conclusion fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff
    `;
                    
                    this.mermaidDiagram = diagram;
                },

                sanitizeForMermaid(text) {
                    // Clean text for Mermaid diagram
                    return text.replace(/[^\w\s]/g, '').substring(0, 20);
                },

                getMermaidNodeClass(thought) {
                    const content = thought.content.toLowerCase();
                    
                    if (content.includes('decision') || content.includes('choose')) {
                        return 'decision';
                    } else if (content.includes('conclusion') || content.includes('result')) {
                        return 'conclusion';
                    } else if (thought.isBranch) {
                        return 'branch';
                    }
                    
                    return 'default';
                },

                async renderMermaidDiagram() {
                    if (!this.mermaidDiagram || !this.$refs.mermaidContainer) return;
                    
                    try {
                        // Clear previous diagram
                        this.$refs.mermaidContainer.innerHTML = '';
                        
                        // Generate unique ID for this diagram
                        const diagramId = `mermaid-${Date.now()}`;
                        
                        // Render the diagram
                        const { svg } = await mermaid.render(diagramId, this.mermaidDiagram);
                        this.$refs.mermaidContainer.innerHTML = svg;
                        
                        // Add event listeners to nodes
                        this.addMermaidNodeInteractions();
                        
                        // Highlight current thought
                        this.updateDiagramHighlight();
                        
                    } catch (error) {
                        console.error('Error rendering Mermaid diagram:', error);
                        this.showToast('Error rendering thought chain diagram', 'error');
                    }
                },

                addMermaidNodeInteractions() {
                    const nodes = this.$refs.mermaidContainer.querySelectorAll('.node');
                    
                    nodes.forEach((node, index) => {
                        if (index < this.thoughtsInCurrentChain.length) {
                            node.style.cursor = 'pointer';
                            node.addEventListener('click', () => {
                                this.jumpToThought(index);
                            });
                        }
                    });
                },

                updateDiagramHighlight() {
                    if (!this.$refs.mermaidContainer) return;
                    
                    const nodes = this.$refs.mermaidContainer.querySelectorAll('.node');
                    
                    nodes.forEach((node, index) => {
                        node.classList.remove('active');
                        if (index === this.currentThoughtIndex) {
                            node.classList.add('active');
                        }
                        
                        // Dim nodes that haven't been reached yet
                        if (index > this.currentThoughtIndex) {
                            node.style.opacity = '0.3';
                        } else {
                            node.style.opacity = '1';
                        }
                    });
                },

                // Playback control methods
                togglePlayback() {
                    if (this.isPlaybackActive) {
                        this.stopPlayback();
                    } else {
                        this.startPlayback();
                    }
                },

                startPlayback() {
                    if (!this.currentChain || this.currentThoughtIndex >= this.thoughtsInCurrentChain.length - 1) {
                        return;
                    }
                    
                    this.isPlaybackActive = true;
                    const interval = 2000 / this.playbackSpeed; // Base interval of 2 seconds
                    
                    this.playbackInterval = setInterval(() => {
                        if (this.currentThoughtIndex < this.thoughtsInCurrentChain.length - 1) {
                            this.stepForward();
                        } else {
                            this.stopPlayback();
                        }
                    }, interval);
                },

                stopPlayback() {
                    this.isPlaybackActive = false;
                    if (this.playbackInterval) {
                        clearInterval(this.playbackInterval);
                        this.playbackInterval = null;
                    }
                },

                stepForward() {
                    if (this.currentThoughtIndex < this.thoughtsInCurrentChain.length - 1) {
                        this.currentThoughtIndex++;
                        this.thoughtTimelinePosition = this.currentThoughtIndex;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                stepBackward() {
                    if (this.currentThoughtIndex > 0) {
                        this.currentThoughtIndex--;
                        this.thoughtTimelinePosition = this.currentThoughtIndex;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                setPlaybackSpeed(speed) {
                    this.playbackSpeed = speed;
                    
                    // Restart playback with new speed if currently playing
                    if (this.isPlaybackActive) {
                        this.stopPlayback();
                        this.startPlayback();
                    }
                },

                jumpToThought(index) {
                    if (index >= 0 && index < this.thoughtsInCurrentChain.length) {
                        this.currentThoughtIndex = index;
                        this.thoughtTimelinePosition = index;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                seekToPosition(position) {
                    this.jumpToThought(parseInt(position));
                },

                updateSelectedThought() {
                    if (this.thoughtsInCurrentChain[this.currentThoughtIndex]) {
                        this.selectedThought = this.thoughtsInCurrentChain[this.currentThoughtIndex];
                    }
                },

                // Navigation helpers
                jumpToFirstBranch() {
                    const branchIndex = this.thoughtsInCurrentChain.findIndex(thought => thought.isBranch);
                    if (branchIndex !== -1) {
                        this.jumpToThought(branchIndex);
                    }
                },

                jumpToLastThought() {
                    this.jumpToThought(this.thoughtsInCurrentChain.length - 1);
                },

                jumpToKeyDecision() {
                    const decisionIndex = this.thoughtsInCurrentChain.findIndex(thought => 
                        thought.content.toLowerCase().includes('decision') || 
                        thought.content.toLowerCase().includes('choose')
                    );
                    if (decisionIndex !== -1) {
                        this.jumpToThought(decisionIndex);
                    }
                },

                jumpToConclusion() {
                    const conclusionIndex = this.thoughtsInCurrentChain.findIndex(thought => 
                        thought.content.toLowerCase().includes('conclusion') || 
                        thought.content.toLowerCase().includes('result')
                    );
                    if (conclusionIndex !== -1) {
                        this.jumpToThought(conclusionIndex);
                    } else {
                        this.jumpToLastThought();
                    }
                },

                // Modal navigation
                navigateToPreviousThought() {
                    this.stepBackward();
                },

                navigateToNextThought() {
                    this.stepForward();
                },

                selectThought(thought) {
                    this.selectedThought = thought;
                },

                // Chain management
                filterThoughtChains() {
                    // Implementation for filtering chains based on this.chainFilter
                    // This would filter this.thoughtChains based on the selected filter
                },

                resetThoughtChainView() {
                    this.currentChain = null;
                    this.thoughtsInCurrentChain = [];
                    this.currentThoughtIndex = 0;
                    this.thoughtTimelinePosition = 0;
                    this.stopPlayback();
                    this.selectedThought = null;
                    this.chainFilter = '';
                },

                exportThoughtChain() {
                    if (!this.currentChain) {
                        this.showToast('Please select a thought chain to export', 'warning');
                        return;
                    }
                    
                    const exportData = {
                        chain: this.currentChain,
                        diagram: this.mermaidDiagram,
                        timestamp: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `thought-chain-${this.currentChain.id}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Thought chain exported successfully! ', 'success');
                },

                calculateChainDuration(chain) {
                    if (!chain || chain.thoughts.length < 2) return 'N/A';
                    
                    const start = chain.thoughts[0].created_at;
                    const end = chain.thoughts[chain.thoughts.length - 1].created_at;
                    const duration = end - start;
                    
                    if (duration < 60) return `${duration}s`;
                    if (duration < 3600) return `${Math.round(duration / 60)}m`;
                    return `${Math.round(duration / 3600)}h`;
                },

                // =================== GOAL HIERARCHY METHODS ===================

                async loadGoalTreeData() {
                    if (!this.dbLoaded) {
                        console.log('Database not loaded, skipping goal tree data');
                        return;
                    }
                    
                    try {
                        // Use real goals from database only
                        const goals = this.goals;
                        
                        // Build tree structure with real data only
                        this.goalTreeData = this.buildGoalTree(goals);
                        
                        // Calculate goal statistics from real data
                        this.calculateGoalStats(goals);
                        
                        console.log(`Goal tree loaded: ${goals.length} goals`);
                        
                        if (goals.length === 0) {
                            console.log('No goals found in database. Use "Import from Memories" or "Create New Goal" to add goals.');
                        }
                        
                    } catch (error) {
                        console.error('Error loading goal tree data:', error);
                        // Initialize empty goal tree on error
                        this.goalTreeData = this.buildGoalTree([]);
                        this.calculateGoalStats([]);
                        console.log('Initialized empty goal tree due to error');
                    }
                },



                buildGoalTree(goals) {
                    // Create a map for quick lookup
                    const goalMap = new Map();
                    goals.forEach(goal => {
                        goalMap.set(goal.goal_id, {
                            ...goal,
                            children: [],
                            subgoals: [],
                            dependencies: [],
                            x: 0,
                            y: 0,
                            expanded: true
                        });
                    });
                    
                    // Build parent-child relationships
                    const rootGoals = [];
                    goals.forEach(goal => {
                        const goalNode = goalMap.get(goal.goal_id);
                        if (goal.parent_goal_id && goalMap.has(goal.parent_goal_id)) {
                            const parent = goalMap.get(goal.parent_goal_id);
                            parent.children.push(goalNode);
                            parent.subgoals.push(goalNode);
                        } else {
                            rootGoals.push(goalNode);
                        }
                    });
                    
                    return { children: rootGoals, name: 'Goals' };
                },

                calculateGoalStats(goals) {
                    if (!goals || goals.length === 0) {
                        this.goalStats = {
                            total: 0,
                            completed: 0,
                            inProgress: 0,
                            pending: 0,
                            overdue: 0,
                            completionRate: 0
                        };
                        return;
                    }
                    
                    const now = Date.now() / 1000;
                    const stats = {
                        total: goals.length,
                        completed: 0,
                        inProgress: 0,
                        pending: 0,
                        overdue: 0,
                        completionRate: 0
                    };
                    
                    goals.forEach(goal => {
                        switch (goal.status) {
                            case 'completed':
                                stats.completed++;
                                break;
                            case 'in_progress':
                            case 'active':
                                stats.inProgress++;
                                if (goal.due_date && goal.due_date < now) {
                                    stats.overdue++;
                                }
                                break;
                            case 'pending':
                                stats.pending++;
                                if (goal.due_date && goal.due_date < now) {
                                    stats.overdue++;
                                }
                                break;
                        }
                    });
                    
                    stats.completionRate = Math.round((stats.completed / stats.total) * 100);
                    this.goalStats = stats;
                },

                async initializeGoalTree() {
                    if (!window.d3 || !this.goalTreeData.children.length) {
                        console.log('D3 not available or no goal data');
                        return;
                    }
                    
                    try {
                        await this.renderGoalTree();
                        console.log(' Goal tree initialized successfully');
                    } catch (error) {
                        console.error(' Error initializing goal tree:', error);
                        this.showToast('Error initializing goal tree', 'error');
                    }
                },

                async renderGoalTree() {
                    if (!window.d3 || !this.goalTreeData || !this.goalTreeData.children.length) {
                        console.log('D3 not available or no goal data');
                        return;
                    }
                    
                    const container = this.$refs.goalTreeContainer;
                    if (!container) return;
                    
                    // Clear previous content
                    d3.select(container).selectAll("*").remove();
                    
                    const margin = { top: 20, right: 120, bottom: 20, left: 120 };
                    const width = Math.max(800, container.clientWidth - margin.left - margin.right);
                    const height = Math.max(400, container.clientHeight - margin.top - margin.bottom);
                    
                    const svg = d3.select(container)
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom);
                    
                    const g = svg.append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);
                    
                    const tree = d3.tree().size([height, width]);
                    const root = d3.hierarchy(this.goalTreeData);
                    
                    tree(root);
                    
                    // Add the links between nodes
                    const link = g.selectAll(".goal-link")
                        .data(root.descendants().slice(1))
                        .enter().append("path")
                        .attr("class", "goal-link")
                        .attr("d", d => {
                            return "M" + d.y + "," + d.x
                                + "C" + (d.y + d.parent.y) / 2 + "," + d.x
                                + " " + (d.y + d.parent.y) / 2 + "," + d.parent.x
                                + " " + d.parent.y + "," + d.parent.x;
                        })
                        .style("fill", "none")
                        .style("stroke", "#555")
                        .style("stroke-width", "2px");
                    
                    // Add the nodes
                    const node = g.selectAll(".goal-node")
                        .data(root.descendants())
                        .enter().append("g")
                        .attr("class", "goal-node")
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .style("cursor", "pointer")
                        .on("click", (event, d) => this.selectGoal(d.data));
                    
                    // Add circles for the nodes
                    node.append("circle")
                        .attr("class", "goal-node-bg")
                        .attr("r", 8)
                        .style("fill", d => this.getGoalNodeColor(d.data))
                        .style("stroke", d => this.getGoalBorderColor(d.data))
                        .style("stroke-width", "2px");
                    
                    // Add text labels
                    node.append("text")
                        .attr("dy", "0.35em")
                        .attr("x", d => d.children ? -15 : 15)
                        .style("text-anchor", d => d.children ? "end" : "start")
                        .style("fill", "#fff")
                        .style("font-size", "12px")
                        .text(d => this.truncateText(d.data.title, 30));
                    
                    // Store nodes for later use
                    this.goalTreeNodes = node;
                    
                    console.log(' Goal tree rendered successfully');
                },

                createGoalDrag() {
                    return d3.drag()
                        .on("start", (event, d) => {
                            this.isDragging = true;
                            this.draggedGoal = d.data;
                            event.sourceEvent.stopPropagation();
                        })
                        .on("drag", (event, d) => {
                            d3.select(event.sourceEvent.target.parentNode)
                                .attr("transform", `translate(${event.x}, ${event.y})`);
                        })
                        .on("end", (event, d) => {
                            this.isDragging = false;
                            this.draggedGoal = null;
                            // Reset position for now - in a real implementation, 
                            // you'd update the tree structure here
                            this.renderGoalTree();
                        });
                },

                getGoalNodeColor(goal) {
                    if (!goal.status) return '#6b7280';
                    
                    const colors = {
                        completed: '#10b981',
                        in_progress: '#3b82f6',
                        active: '#3b82f6',
                        pending: '#6b7280',
                        cancelled: '#ef4444',
                        overdue: '#ef4444'
                    };
                    
                    // Check if overdue
                    if (goal.due_date && goal.due_date < (Date.now() / 1000) && goal.status !== 'completed') {
                        return colors.overdue;
                    }
                    
                    return colors[goal.status] || colors.pending;
                },

                getGoalBorderColor(goal) {
                    return d3.color(this.getGoalNodeColor(goal)).darker(0.5);
                },

                getGoalPriorityColor(priority) {
                    const colors = {
                        high: '#ef4444',
                        medium: '#f59e0b',
                        low: '#3b82f6'
                    };
                    return colors[priority] || colors.medium;
                },

                getGoalStatusClass(status) {
                    const classes = {
                        completed: 'bg-green-500/20 text-green-400',
                        in_progress: 'bg-blue-500/20 text-blue-400',
                        active: 'bg-blue-500/20 text-blue-400',
                        pending: 'bg-gray-500/20 text-gray-400',
                        cancelled: 'bg-red-500/20 text-red-400',
                        overdue: 'bg-red-500/20 text-red-400'
                    };
                    return classes[status] || classes.pending;
                },

                getGoalPriorityClass(priority) {
                    const classes = {
                        high: 'bg-red-500/20 text-red-400',
                        medium: 'bg-yellow-500/20 text-yellow-400',
                        low: 'bg-blue-500/20 text-blue-400'
                    };
                    return classes[priority] || classes.medium;
                },

                selectGoal(goal) {
                    this.selectedGoal = goal;
                    
                    // Highlight selected node
                    if (this.goalTreeNodes) {
                        this.goalTreeNodes.selectAll('.goal-node-bg')
                            .attr('stroke-width', d => d.data === goal ? 4 : 2)
                            .attr('stroke', d => d.data === goal ? '#fbbf24' : this.getGoalBorderColor(d.data));
                    }
                },

                showGoalTooltip(event, goal) {
                    // Implementation for goal tooltip
                    // Similar to graph tooltip but with goal-specific content
                },

                hideGoalTooltip() {
                    // Hide tooltip
                },

                truncateText(text, maxLength) {
                    if (!text) return '';
                    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
                },

                // Goal management methods
                showNewGoalModal() {
                    this.editingGoal = null;
                    this.goalForm = {
                        title: '',
                        description: '',
                        priority: 'medium',
                        status: 'pending',
                        progress: 0,
                        due_date: '',
                        parent_goal_id: this.selectedGoal?.goal_id || '',
                        notes: ''
                    };
                    this.showGoalModal = true;
                },

                editGoal(goal) {
                    this.editingGoal = goal;
                    this.goalForm = {
                        title: goal.title || '',
                        description: goal.description || '',
                        priority: goal.priority || 'medium',
                        status: goal.status || 'pending',
                        progress: goal.progress || 0,
                        due_date: goal.due_date ? new Date(goal.due_date * 1000).toISOString().split('T')[0] : '',
                        parent_goal_id: goal.parent_goal_id || '',
                        notes: goal.notes || ''
                    };
                    this.showGoalModal = true;
                },

                async saveGoal() {
                    try {
                        const goalData = {
                            ...this.goalForm,
                            due_date: this.goalForm.due_date ? new Date(this.goalForm.due_date).getTime() / 1000 : null,
                            updated_at: Date.now() / 1000
                        };
                        
                        if (this.editingGoal) {
                            // Update existing goal
                            goalData.goal_id = this.editingGoal.goal_id;
                            const index = this.goals.findIndex(g => g.goal_id === this.editingGoal.goal_id);
                            if (index !== -1) {
                                this.goals[index] = { ...this.goals[index], ...goalData };
                            }
                            this.showToast('Goal updated successfully! ', 'success');
                        } else {
                            // Create new goal
                            goalData.goal_id = 'g' + Date.now();
                            goalData.created_at = Date.now() / 1000;
                            this.goals.push(goalData);
                            this.showToast('Goal created successfully! ', 'success');
                        }
                        
                        // Rebuild tree
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        // Close modal
                        this.showGoalModal = false;
                        this.editingGoal = null;
                        
                    } catch (error) {
                        console.error('Error saving goal:', error);
                        this.showToast('Error saving goal', 'error');
                    }
                },

                addSubgoal(parentGoal) {
                    this.selectedGoal = parentGoal;
                    this.showNewGoalModal();
                },

                async markGoalComplete(goal) {
                    try {
                        goal.status = 'completed';
                        goal.progress = 100;
                        goal.updated_at = Date.now() / 1000;
                        
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        this.showToast(`Goal "${goal.title}" marked as complete! `, 'success');
                        
                    } catch (error) {
                        console.error('Error completing goal:', error);
                        this.showToast('Error updating goal status', 'error');
                    }
                },

                async deleteGoal(goal) {
                    if (!confirm(`Are you sure you want to delete "${goal.title}"? This will also delete all subgoals.`)) {
                        return;
                    }
                    
                    try {
                        // Remove from goals array
                        this.goals = this.goals.filter(g => g.goal_id !== goal.goal_id && g.parent_goal_id !== goal.goal_id);
                        
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        this.selectedGoal = null;
                        this.showToast('Goal deleted successfully', 'success');
                        
                    } catch (error) {
                        console.error('Error deleting goal:', error);
                        this.showToast('Error deleting goal', 'error');
                    }
                },

                filterGoals() {
                    // Filter logic would update the tree display
                    this.rebuildGoalTree();
                },

                rebuildGoalTree() {
                    if (this.goals.length > 0) {
                        this.goalTreeData = this.buildGoalTree(this.goals);
                        if (this.currentView === 'goals') {
                            this.renderGoalTree();
                        }
                    }
                },

                expandAllGoals() {
                    // Expand all nodes in the tree
                    this.goalTreeSettings.expandLevel = 999;
                    this.rebuildGoalTree();
                    this.showToast('All goals expanded', 'info');
                },

                collapseAllGoals() {
                    // Collapse all nodes except root level
                    this.goalTreeSettings.expandLevel = 1;
                    this.rebuildGoalTree();
                    this.showToast('All goals collapsed', 'info');
                },

                resetGoalTreeView() {
                    this.selectedGoal = null;
                    this.goalFilter = '';
                    this.goalSearch = '';
                    this.goalTreeSettings.groupBy = 'none';
                    this.goalTreeSettings.sortBy = 'created';
                    this.goalTreeSettings.expandLevel = 2;
                    this.rebuildGoalTree();
                    this.showToast('Goal tree view reset', 'info');
                },

                importGoalsFromMemories() {
                    // Extract goal-like memories and create goals
                    const goalMemories = this.memories.filter(m => 
                        m.memory_type === 'goal' || 
                        m.content.toLowerCase().includes('goal') ||
                        m.content.toLowerCase().includes('objective') ||
                        m.content.toLowerCase().includes('task')
                    );
                    
                    let importedCount = 0;
                    goalMemories.forEach(memory => {
                        const goal = {
                            goal_id: 'g_import_' + memory.memory_id,
                            title: memory.content.substring(0, 50) + (memory.content.length > 50 ? '...' : ''),
                            description: memory.content,
                            priority: memory.importance > 7 ? 'high' : memory.importance > 4 ? 'medium' : 'low',
                            status: 'pending',
                            progress: 0,
                            created_at: memory.created_at,
                            updated_at: memory.created_at,
                            parent_goal_id: null,
                            workflow_id: memory.workflow_id
                        };
                        
                        // Check if already exists
                        if (!this.goals.find(g => g.title === goal.title)) {
                            this.goals.push(goal);
                            importedCount++;
                        }
                    });
                    
                    if (importedCount > 0) {
                        this.loadGoalTreeData();
                        this.showToast(`Imported ${importedCount} goals from memories! `, 'success');
                    } else {
                        this.showToast('No new goals found to import', 'info');
                    }
                },

                // Drag and drop handlers
                handleGoalDrop(event, target) {
                    if (!this.draggedGoal) return;
                    
                    if (target === 'root') {
                        this.draggedGoal.parent_goal_id = null;
                    } else {
                        this.draggedGoal.parent_goal_id = target.goal_id;
                    }
                    
                    this.rebuildGoalTree();
                    this.showToast('Goal hierarchy updated', 'success');
                },

                highlightDropZone(event, zone) {
                    event.currentTarget.style.opacity = '1';
                    event.currentTarget.style.transform = 'scale(1.05)';
                },

                unhighlightDropZone(event) {
                    event.currentTarget.style.opacity = '0.7';
                    event.currentTarget.style.transform = 'scale(1)';
                },

                // =================== SEMANTIC SEARCH METHODS ===================

                debounceSemanticSearch() {
                    if (this.searchDebounceTimer) {
                        clearTimeout(this.searchDebounceTimer);
                    }
                    this.searchDebounceTimer = setTimeout(() => {
                        if (this.semanticQuery.length >= 3) {
                            // Auto-search for queries > 3 characters after a pause
                            // this.performSemanticSearch();
                        }
                    }, 1000);
                },

                async performSemanticSearch() {
                    if (!this.semanticQuery.trim() || this.isSearching) {
                        return;
                    }

                    this.isSearching = true;
                    this.searchStatusMessage = 'Initializing search...';
                    this.searchResults = [];
                    this.searchClusters = [];

                    const startTime = performance.now();

                    try {
                        // Add to search history
                        this.addToSearchHistory();

                        // Perform the appropriate search based on mode
                        let results = [];
                        
                        if (this.searchMode === 'hybrid') {
                            this.searchStatusMessage = 'Performing hybrid semantic + keyword search...';
                            results = await this.performHybridSearch();
                        } else if (this.searchMode === 'semantic') {
                            this.searchStatusMessage = 'Performing pure semantic search...';
                            results = await this.performPureSemanticSearch();
                        } else if (this.searchMode === 'structured') {
                            this.searchStatusMessage = 'Performing structured query...';
                            results = await this.performStructuredQuery();
                        }

                        this.searchResults = results;
                        
                        // Generate clusters if we have enough results
                        if (results.length >= 3) {
                            this.searchStatusMessage = 'Generating clusters...';
                            await this.generateSearchClusters();
                        }

                        const endTime = performance.now();
                        this.searchStats.totalTime = Math.round(endTime - startTime);
                        this.searchStatusMessage = '';

                        this.showToast(`Found ${results.length} results in ${this.searchStats.totalTime}ms`, 'success');

                    } catch (error) {
                        console.error('Search error:', error);
                        this.showToast(`Search failed: ${error.message}`, 'error');
                        this.searchStatusMessage = '';
                    } finally {
                        this.isSearching = false;
                    }
                },

                async performHybridSearch() {
                    try {
                        // Use the UMS hybrid_search_memories tool via the executeQuery method
                        // Since we don't have direct tool access, we'll simulate calling the UMS
                        
                        // For now, use the existing database and do a hybrid search simulation
                        const query = `
                            SELECT DISTINCT m.*, 
                                   m.importance / 10.0 as hybrid_score,
                                   (CASE WHEN m.content LIKE ? THEN 0.8 ELSE 0.3 END) as similarity
                            FROM memories m
                            WHERE 1=1
                            ${this.searchFilters.memoryLevel ? 'AND m.memory_level = ?' : ''}
                            ${this.searchFilters.memoryType ? 'AND m.memory_type = ?' : ''}
                            AND (m.content LIKE ? OR m.memory_type LIKE ? OR m.description LIKE ?)
                            ORDER BY hybrid_score DESC, similarity DESC
                            LIMIT 50
                        `;
                        
                        const params = [];
                        const searchPattern = `%${this.semanticQuery}%`;
                        params.push(searchPattern); // for similarity calculation
                        
                        if (this.searchFilters.memoryLevel) params.push(this.searchFilters.memoryLevel);
                        if (this.searchFilters.memoryType) params.push(this.searchFilters.memoryType);
                        
                        params.push(searchPattern, searchPattern, searchPattern); // for WHERE clause

                        const results = this.executeQuery(query, params);
                        
                        this.searchStats.semanticMatches = results.length;
                        this.searchStats.keywordMatches = results.filter(r => 
                            r.content.toLowerCase().includes(this.semanticQuery.toLowerCase())
                        ).length;

                        return results;
                        
                    } catch (error) {
                        console.error('Hybrid search error:', error);
                        // Fallback to simple search
                        return this.performFallbackSearch();
                    }
                },

                async performPureSemanticSearch() {
                    try {
                        // Simulate semantic search by looking for conceptually related content
                        // In a real implementation, this would use embeddings
                        
                        const query = `
                            SELECT m.*, 
                                   0.85 as similarity
                            FROM memories m
                            WHERE m.content LIKE ? OR m.memory_type LIKE ?
                            ${this.searchFilters.memoryLevel ? 'AND m.memory_level = ?' : ''}
                            ${this.searchFilters.memoryType ? 'AND m.memory_type = ?' : ''}
                            ORDER BY m.importance DESC, m.created_at DESC
                            LIMIT 30
                        `;

                        const params = [`%${this.semanticQuery}%`, `%${this.semanticQuery}%`];
                        if (this.searchFilters.memoryLevel) params.push(this.searchFilters.memoryLevel);
                        if (this.searchFilters.memoryType) params.push(this.searchFilters.memoryType);

                        const results = this.executeQuery(query, params);
                        this.searchStats.semanticMatches = results.length;
                        
                        return results;
                        
                    } catch (error) {
                        console.error('Semantic search error:', error);
                        return this.performFallbackSearch();
                    }
                },

                async performStructuredQuery() {
                    try {
                        let whereConditions = ['1=1'];
                        let params = [];

                        if (this.semanticQuery) {
                            whereConditions.push('(m.content LIKE ? OR m.memory_type LIKE ? OR m.description LIKE ?)');
                            const pattern = `%${this.semanticQuery}%`;
                            params.push(pattern, pattern, pattern);
                        }

                        if (this.searchFilters.memoryLevel) {
                            whereConditions.push('m.memory_level = ?');
                            params.push(this.searchFilters.memoryLevel);
                        }

                        if (this.searchFilters.memoryType) {
                            whereConditions.push('m.memory_type = ?');
                            params.push(this.searchFilters.memoryType);
                        }

                        if (this.searchFilters.minImportance !== null) {
                            whereConditions.push('m.importance >= ?');
                            params.push(this.searchFilters.minImportance);
                        }

                        const query = `
                            SELECT m.*, 
                                   1.0 as similarity
                            FROM memories m
                            WHERE ${whereConditions.join(' AND ')}
                            ORDER BY m.importance DESC, m.created_at DESC
                            LIMIT 100
                        `;

                        const results = this.executeQuery(query, params);
                        return results;
                        
                    } catch (error) {
                        console.error('Structured query error:', error);
                        return this.performFallbackSearch();
                    }
                },

                performFallbackSearch() {
                    // Simple fallback search using existing memories
                    const query = this.semanticQuery.toLowerCase();
                    return this.memories.filter(memory => {
                        const matchesQuery = memory.content?.toLowerCase().includes(query) ||
                                           memory.memory_type?.toLowerCase().includes(query) ||
                                           memory.description?.toLowerCase().includes(query);
                        
                        const matchesLevel = !this.searchFilters.memoryLevel || 
                                           memory.memory_level === this.searchFilters.memoryLevel;
                        
                        const matchesType = !this.searchFilters.memoryType || 
                                          memory.memory_type === this.searchFilters.memoryType;
                        
                        return matchesQuery && matchesLevel && matchesType;
                    }).slice(0, 50).map(memory => ({
                        ...memory,
                        similarity: 0.7,
                        hybrid_score: memory.importance / 10
                    }));
                },

                async generateSearchClusters() {
                    if (this.searchResults.length < 3) return;

                    try {
                        // Simple clustering by memory type and level
                        const clusters = new Map();
                        
                        this.searchResults.forEach(result => {
                            const key = `${result.memory_level}-${result.memory_type}`;
                            if (!clusters.has(key)) {
                                clusters.set(key, {
                                    id: key,
                                    label: `${result.memory_level} ${result.memory_type}`,
                                    results: [],
                                    expanded: false
                                });
                            }
                            clusters.get(key).results.push(result);
                        });

                        // Only keep clusters with 2+ results
                        this.searchClusters = Array.from(clusters.values())
                            .filter(cluster => cluster.results.length >= 2)
                            .sort((a, b) => b.results.length - a.results.length);

                    } catch (error) {
                        console.error('Clustering error:', error);
                        this.searchClusters = [];
                    }
                },

                addToSearchHistory() {
                    const historyItem = {
                        id: Date.now(),
                        query: this.semanticQuery,
                        mode: this.searchMode,
                        filters: { ...this.searchFilters },
                        timestamp: Date.now()
                    };

                    // Remove duplicate queries
                    this.searchHistory = this.searchHistory.filter(item => item.query !== this.semanticQuery);
                    
                    // Add to beginning
                    this.searchHistory.unshift(historyItem);
                    
                    // Keep only last 20
                    this.searchHistory = this.searchHistory.slice(0, 20);
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem('ums-search-history', JSON.stringify(this.searchHistory));
                    } catch (e) {
                        console.warn('Failed to save search history:', e);
                    }
                },

                loadSearchFromHistory(historyItem) {
                    this.semanticQuery = historyItem.query;
                    this.searchMode = historyItem.mode;
                    this.searchFilters = { ...this.searchFilters, ...historyItem.filters };
                    this.performSemanticSearch();
                },

                saveCurrentSearch() {
                    if (!this.semanticQuery.trim()) {
                        this.showToast('Enter a search query first', 'warning');
                        return;
                    }

                    const name = prompt('Enter a name for this saved search:', this.semanticQuery.substring(0, 50));
                    if (!name) return;

                    const savedSearch = {
                        id: Date.now(),
                        name: name,
                        query: this.semanticQuery,
                        mode: this.searchMode,
                        filters: { ...this.searchFilters },
                        resultCount: this.searchResults.length,
                        createdAt: Date.now()
                    };

                    this.savedSearches.unshift(savedSearch);
                    this.savedSearches = this.savedSearches.slice(0, 10); // Keep only 10

                    try {
                        localStorage.setItem('ums-saved-searches', JSON.stringify(this.savedSearches));
                        this.showToast(`Search saved as "${name}"`, 'success');
                    } catch (e) {
                        console.warn('Failed to save search:', e);
                        this.showToast('Failed to save search', 'error');
                    }
                },

                loadSavedSearch(savedSearch) {
                    this.semanticQuery = savedSearch.query;
                    this.searchMode = savedSearch.mode;
                    this.searchFilters = { ...this.searchFilters, ...savedSearch.filters };
                    this.performSemanticSearch();
                },

                deleteSavedSearch(searchId) {
                    this.savedSearches = this.savedSearches.filter(s => s.id !== searchId);
                    try {
                        localStorage.setItem('ums-saved-searches', JSON.stringify(this.savedSearches));
                        this.showToast('Saved search deleted', 'info');
                    } catch (e) {
                        console.warn('Failed to update saved searches:', e);
                    }
                },

                clearSemanticSearch() {
                    this.semanticQuery = '';
                    this.searchResults = [];
                    this.searchClusters = [];
                    this.searchStats = {
                        totalTime: 0,
                        semanticMatches: 0,
                        keywordMatches: 0,
                        totalConsidered: 0
                    };
                    this.resultsView = 'list';
                    this.sortBy = 'similarity';
                },

                selectSearchResult(result) {
                    this.selectedMemory = result;
                    this.showMemoryModal = true;
                },

                sortSearchResults() {
                    // Results are sorted via the computed property
                },

                applyQuickFilter(filterType) {
                    switch (filterType) {
                        case 'high-importance':
                            this.searchFilters.minImportance = 8;
                            this.semanticQuery = 'high importance insights';
                            break;
                        case 'recent':
                            const weekAgo = Date.now() / 1000 - (7 * 24 * 60 * 60);
                            this.searchFilters.dateRange = weekAgo;
                            this.semanticQuery = 'recent memories';
                            break;
                        case 'insights':
                            this.searchFilters.memoryType = 'insight';
                            this.semanticQuery = 'insights and discoveries';
                            break;
                        case 'procedures':
                            this.searchFilters.memoryLevel = 'procedural';
                            this.semanticQuery = 'how to procedures';
                            break;
                    }
                    
                    this.performSemanticSearch();
                },

                getMemoryDistribution() {
                    const distribution = {};
                    this.searchResults.forEach(result => {
                        distribution[result.memory_level] = (distribution[result.memory_level] || 0) + 1;
                    });
                    return distribution;
                },

                getSearchInsights() {
                    const insights = [];
                    
                    if (this.searchResults.length === 0) return insights;

                    const avgImportance = this.searchResults.reduce((sum, r) => sum + r.importance, 0) / this.searchResults.length;
                    if (avgImportance > 7) {
                        insights.push({
                            type: 'high-importance',
                            icon: 'star',
                            message: `High average importance (${avgImportance.toFixed(1)}/10)`
                        });
                    }

                    const memoryTypes = new Set(this.searchResults.map(r => r.memory_type));
                    if (memoryTypes.size > 3) {
                        insights.push({
                            type: 'diverse',
                            icon: 'shuffle',
                            message: `Diverse results across ${memoryTypes.size} memory types`
                        });
                    }

                    const recentCount = this.searchResults.filter(r => {
                        const dayAgo = Date.now() / 1000 - (24 * 60 * 60);
                        return r.created_at > dayAgo;
                    }).length;
                    
                    if (recentCount > this.searchResults.length * 0.3) {
                        insights.push({
                            type: 'recent',
                            icon: 'clock',
                            message: `${recentCount} recent memories (last 24h)`
                        });
                    }

                    return insights;
                },

                // Load saved searches and history on init
                loadSemanticSearchState() {
                    try {
                        const savedHistory = localStorage.getItem('ums-search-history');
                        if (savedHistory) {
                            this.searchHistory = JSON.parse(savedHistory);
                        }

                        const savedSearches = localStorage.getItem('ums-saved-searches');
                        if (savedSearches) {
                            this.savedSearches = JSON.parse(savedSearches);
                        }
                    } catch (e) {
                        console.warn('Failed to load semantic search state:', e);
                    }
                },

                // =================== WORKING MEMORY METHODS ===================

                async initializeWorkingMemory() {
                    console.log(' Initializing Working Memory Dashboard...');
                    
                    try {
                        // Initialize working memory data
                        await this.loadWorkingMemoryData();
                        
                        // Start real-time updates
                        this.startWorkingMemoryUpdates();
                        
                        // Initialize charts
                        await this.$nextTick();
                        this.renderWorkingMemoryCharts();
                        
                        // Initialize memory pool
                        this.initializeMemoryPool();
                        
                        // Generate initial optimization suggestions
                        this.generateOptimizationSuggestions();
                        
                        console.log(' Working Memory Dashboard initialized successfully');
                        
                    } catch (error) {
                        console.error(' Error initializing working memory dashboard:', error);
                        this.showToast('Error initializing working memory dashboard', 'error');
                    }
                },

                async loadWorkingMemoryData() {
                    this.isRefreshingWorkingMemory = true;
                    
                    try {
                        // Simulate working memory by finding recent high-importance memories
                        const workingMemories = this.memories
                            .filter(m => m.memory_level === 'working' || m.importance >= 8)
                            .sort((a, b) => b.created_at - a.created_at)
                            .slice(0, this.workingMemoryStats.capacity)
                            .map(memory => ({
                                ...memory,
                                temperature: this.calculateMemoryTemperature(memory),
                                priority: this.calculateMemoryPriority(memory),
                                access_frequency: this.calculateAccessFrequency(memory),
                                retention_score: this.calculateRetentionScore(memory)
                            }));

                        this.activeWorkingMemories = workingMemories;
                        
                        // Update stats
                        this.updateWorkingMemoryStats();
                        
                        // Update heatmap data
                        this.updateMemoryHeatmapData();
                        
                        this.workingMemoryStatus.lastUpdate = Date.now();
                        this.workingMemoryStatus.connected = true;
                        
                    } catch (error) {
                        console.error('Error loading working memory data:', error);
                        this.workingMemoryStatus.connected = false;
                        throw error;
                    } finally {
                        this.isRefreshingWorkingMemory = false;
                    }
                },

                calculateMemoryTemperature(memory) {
                    // Calculate temperature based on recent access patterns
                    const now = Date.now() / 1000;
                    const timeSinceAccess = now - (memory.last_accessed_at || memory.created_at);
                    const accessCount = memory.access_count || 0;
                    
                    // Hot: recently accessed and frequently used
                    // Cold: old and rarely accessed
                    const recencyScore = Math.max(0, 100 - (timeSinceAccess / 3600) * 10); // Decreases over hours
                    const frequencyScore = Math.min(100, accessCount * 10);
                    
                    return Math.round((recencyScore * 0.7 + frequencyScore * 0.3));
                },

                calculateAccessFrequency(memory) {
                    const accessCount = memory.access_count || 0;
                    return Math.min(10, accessCount / 5); // Normalized to 0-10 scale
                },

                calculateRetentionScore(memory) {
                    const importance = memory.importance || 1;
                    const confidence = memory.confidence || 0.5;
                    const accessCount = memory.access_count || 0;
                    
                    return (importance * 0.4 + confidence * 100 * 0.3 + Math.min(accessCount * 10, 100) * 0.3) / 10;
                },

                updateWorkingMemoryStats() {
                    const active = this.activeWorkingMemories;
                    
                    this.workingMemoryStats = {
                        activeCount: active.length,
                        capacity: this.focusSettings.maxWorkingMemory || 7,
                        pressure: Math.round((active.length / (this.focusSettings.maxWorkingMemory || 7)) * 100),
                        temperature: active.length > 0 ? Math.round(active.reduce((sum, m) => sum + m.temperature, 0) / active.length) : 0,
                        focusScore: this.calculateFocusScore(),
                        efficiency: this.calculateEfficiency(),
                        avgRetentionTime: active.length > 0 ? Math.round(active.reduce((sum, m) => sum + m.retention_score, 0) / active.length) : 0,
                        totalAccesses: active.reduce((sum, m) => sum + (m.access_count || 0), 0)
                    };
                },

                calculateFocusScore() {
                    const active = this.activeWorkingMemories;
                    if (active.length === 0) return 100;
                    
                    // Focus is higher when memories are more related and coherent
                    const avgImportance = active.reduce((sum, m) => sum + m.importance, 0) / active.length;
                    const typeVariety = new Set(active.map(m => m.memory_type)).size;
                    const levelVariety = new Set(active.map(m => m.memory_level)).size;
                    
                    // Lower variety = higher focus
                    const varietyPenalty = (typeVariety + levelVariety) * 5;
                    const importanceBonus = avgImportance * 10;
                    
                    return Math.max(0, Math.min(100, importanceBonus - varietyPenalty + 20));
                },

                calculateEfficiency() {
                    const active = this.activeWorkingMemories;
                    if (active.length === 0) return 100;
                    
                    const avgTemperature = active.reduce((sum, m) => sum + m.temperature, 0) / active.length;
                    const utilizationRate = (active.length / this.workingMemoryStats.capacity) * 100;
                    
                    // Efficient when memories are hot (actively used) and utilization is optimal (not too full, not too empty)
                    const optimalUtilization = Math.abs(utilizationRate - 70) < 20 ? 100 : Math.max(0, 100 - Math.abs(utilizationRate - 70));
                    
                    return Math.round((avgTemperature * 0.6 + optimalUtilization * 0.4));
                },

                updateMemoryHeatmapData() {
                    // Generate heatmap data for memory activity
                    const timeframe = this.heatmapSettings.timeframe;
                    const now = Date.now() / 1000;
                    const intervals = [];
                    
                    let intervalSeconds, intervalCount;
                    switch (timeframe) {
                        case '1h':
                            intervalSeconds = 300; // 5 minutes
                            intervalCount = 12;
                            break;
                        case '6h':
                            intervalSeconds = 1800; // 30 minutes
                            intervalCount = 12;
                            break;
                        case '24h':
                            intervalSeconds = 3600; // 1 hour
                            intervalCount = 24;
                            break;
                        case '7d':
                            intervalSeconds = 86400; // 1 day
                            intervalCount = 7;
                            break;
                        default:
                            intervalSeconds = 3600;
                            intervalCount = 24;
                    }
                    
                    for (let i = 0; i < intervalCount; i++) {
                        const intervalStart = now - (intervalCount - i) * intervalSeconds;
                        const intervalEnd = intervalStart + intervalSeconds;
                        
                        // Count memory activities in this interval
                        const activityCount = this.memories.filter(m => 
                            m.created_at >= intervalStart && m.created_at <= intervalEnd
                        ).length;
                        
                        intervals.push({
                            time: intervalStart,
                            activity: activityCount,
                            intensity: Math.min(1, activityCount / 10) // Normalize to 0-1
                        });
                    }
                    
                    this.memoryHeatmapData = intervals;
                },

                startWorkingMemoryUpdates() {
                    if (this.workingMemoryInterval) {
                        clearInterval(this.workingMemoryInterval);
                    }
                    
                    if (this.workingMemorySettings.autoRefresh) {
                        this.workingMemoryInterval = setInterval(() => {
                            this.refreshWorkingMemory();
                        }, this.workingMemoryStatus.updateFrequency);
                    }
                },

                stopWorkingMemoryUpdates() {
                    if (this.workingMemoryInterval) {
                        clearInterval(this.workingMemoryInterval);
                        this.workingMemoryInterval = null;
                    }
                },

                async refreshWorkingMemory() {
                    if (this.isRefreshingWorkingMemory) return;
                    
                    try {
                        await this.loadWorkingMemoryData();
                        this.generateOptimizationSuggestions();
                        this.updateWorkingMemoryCharts();
                        this.updateHeatmap();
                    } catch (error) {
                        console.error('Error refreshing working memory:', error);
                    }
                },

                async optimizeWorkingMemory() {
                    if (this.isOptimizing) return;
                    
                    this.isOptimizing = true;
                    
                    try {
                        // Auto-apply low-risk optimizations
                        const autoOptimizations = this.optimizationSuggestions.filter(s => 
                            s.priority === 'medium' || s.priority === 'low'
                        );
                        
                        for (const suggestion of autoOptimizations) {
                            await this.applyOptimization(suggestion);
                        }
                        
                        await this.refreshWorkingMemory();
                        this.showToast('Working memory optimized successfully! ', 'success');
                        
                    } catch (error) {
                        console.error('Error optimizing working memory:', error);
                        this.showToast('Error during optimization', 'error');
                    } finally {
                        this.isOptimizing = false;
                    }
                },

                generateOptimizationSuggestions() {
                    const suggestions = [];
                    const stats = this.workingMemoryStats;
                    const active = this.activeWorkingMemories;
                    
                    // High pressure suggestion
                    if (stats.pressure > 80) {
                        suggestions.push({
                            id: 'reduce-pressure',
                            title: 'Reduce Memory Pressure',
                            description: 'Working memory is near capacity. Consider removing lower priority items.',
                            priority: 'high',
                            impact: 'High',
                            icon: 'alert-triangle',
                            action: 'Auto-Remove',
                            applying: false,
                            handler: () => this.removeLowPriorityMemories()
                        });
                    }
                    
                    // Low temperature (stale memories) suggestion
                    const coldMemories = active.filter(m => m.temperature < 30);
                    if (coldMemories.length > 0) {
                        suggestions.push({
                            id: 'remove-cold',
                            title: 'Remove Stale Memories',
                            description: `${coldMemories.length} memories haven't been accessed recently.`,
                            priority: 'medium',
                            impact: 'Medium',
                            icon: 'snowflake',
                            action: 'Clear Stale',
                            applying: false,
                            handler: () => this.removeColdMemories()
                        });
                    }
                    
                    // Low focus suggestion
                    if (stats.focusScore < 50) {
                        suggestions.push({
                            id: 'improve-focus',
                            title: 'Improve Focus',
                            description: 'Working memory contains diverse, unrelated items. Consider focusing on a single task.',
                            priority: 'medium',
                            impact: 'High',
                            icon: 'target',
                            action: 'Focus Mode',
                            applying: false,
                            handler: () => this.enterDeepFocus()
                        });
                    }
                    
                    // Empty slots suggestion
                    if (stats.activeCount < stats.capacity / 2) {
                        suggestions.push({
                            id: 'add-related',
                            title: 'Add Related Memories',
                            description: 'Working memory has capacity for more relevant items.',
                            priority: 'low',
                            impact: 'Medium',
                            icon: 'plus-circle',
                            action: 'Add Related',
                            applying: false,
                            handler: () => this.addRelatedMemories()
                        });
                    }
                    
                    this.optimizationSuggestions = suggestions;
                },

                async applyOptimization(suggestion) {
                    if (suggestion.applying) return;
                    
                    suggestion.applying = true;
                    
                    try {
                        await suggestion.handler();
                        this.showToast(`Applied: ${suggestion.title}`, 'success');
                        
                        // Remove the suggestion after applying
                        this.optimizationSuggestions = this.optimizationSuggestions.filter(s => s.id !== suggestion.id);
                        
                    } catch (error) {
                        console.error('Error applying optimization:', error);
                        this.showToast(`Error applying ${suggestion.title}`, 'error');
                    } finally {
                        suggestion.applying = false;
                    }
                },

                removeLowPriorityMemories() {
                    const toRemove = this.activeWorkingMemories
                        .filter(m => m.priority === 'low')
                        .slice(0, 2); // Remove up to 2 low priority items
                    
                    toRemove.forEach(memory => this.removeFromWorkingMemory(memory));
                },

                removeColdMemories() {
                    const toRemove = this.activeWorkingMemories
                        .filter(m => m.temperature < 30)
                        .slice(0, 3); // Remove up to 3 cold items
                    
                    toRemove.forEach(memory => this.removeFromWorkingMemory(memory));
                },

                addRelatedMemories() {
                    if (this.activeWorkingMemories.length === 0) return;
                    
                    // Find memories related to current working memory
                    const currentTypes = new Set(this.activeWorkingMemories.map(m => m.memory_type));
                    const currentWorkflowIds = new Set(this.activeWorkingMemories.map(m => m.workflow_id).filter(Boolean));
                    
                    const candidates = this.memories
                        .filter(m => !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id))
                        .filter(m => currentTypes.has(m.memory_type) || currentWorkflowIds.has(m.workflow_id))
                        .filter(m => m.importance >= 6)
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 2);
                    
                    candidates.forEach(memory => this.addToWorkingMemory(memory));
                },

                initializeMemoryPool() {
                    // Initialize with high-priority memories not in working memory
                    this.filteredMemoryPool = this.memories
                        .filter(m => !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id))
                        .filter(m => m.importance >= 5)
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 50)
                        .map(memory => ({
                            ...memory,
                            access_frequency: this.calculateAccessFrequency(memory)
                        }));
                },

                filterMemoryPool() {
                    let filtered = this.memories.filter(m => 
                        !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id)
                    );
                    
                    // Apply search filter
                    if (this.memoryPoolSearch) {
                        const search = this.memoryPoolSearch.toLowerCase();
                        filtered = filtered.filter(m => 
                            m.content?.toLowerCase().includes(search) ||
                            m.memory_type?.toLowerCase().includes(search)
                        );
                    }
                    
                    // Apply category filter
                    switch (this.memoryPoolFilter) {
                        case 'high':
                            filtered = filtered.filter(m => m.importance >= 8);
                            break;
                        case 'recent':
                            const dayAgo = Date.now() / 1000 - 86400;
                            filtered = filtered.filter(m => m.created_at > dayAgo);
                            break;
                        case 'related':
                            if (this.activeWorkingMemories.length > 0) {
                                const workflowIds = new Set(this.activeWorkingMemories.map(m => m.workflow_id).filter(Boolean));
                                const types = new Set(this.activeWorkingMemories.map(m => m.memory_type));
                                filtered = filtered.filter(m => 
                                    workflowIds.has(m.workflow_id) || types.has(m.memory_type)
                                );
                            }
                            break;
                    }
                    
                    this.filteredMemoryPool = filtered
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 50)
                        .map(memory => ({
                            ...memory,
                            access_frequency: this.calculateAccessFrequency(memory)
                        }));
                },

                // Memory management operations
                addToWorkingMemory(memory) {
                    if (this.activeWorkingMemories.length >= this.workingMemoryStats.capacity) {
                        this.showToast('Working memory is at capacity', 'warning');
                        return;
                    }
                    
                    if (this.activeWorkingMemories.find(m => m.memory_id === memory.memory_id)) {
                        this.showToast('Memory already in working memory', 'info');
                        return;
                    }
                    
                    const enhancedMemory = {
                        ...memory,
                        temperature: this.calculateMemoryTemperature(memory),
                        priority: this.calculateMemoryPriority(memory),
                        access_frequency: this.calculateAccessFrequency(memory),
                        retention_score: this.calculateRetentionScore(memory),
                        added_at: Date.now() / 1000
                    };
                    
                    this.activeWorkingMemories.push(enhancedMemory);
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Added to working memory: ${memory.memory_type}`, 'success');
                },

                removeFromWorkingMemory(memory) {
                    this.activeWorkingMemories = this.activeWorkingMemories.filter(m => m.memory_id !== memory.memory_id);
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Removed from working memory`, 'info');
                },

                clearWorkingMemory() {
                    if (!confirm('Clear all working memory? This will remove all active memories.')) {
                        return;
                    }
                    
                    this.activeWorkingMemories = [];
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast('Working memory cleared', 'info');
                },

                selectWorkingMemory(memory) {
                    this.selectedMemory = memory;
                    this.showMemoryModal = true;
                },

                // Drag and drop handlers
                handleMemoryDragStart(event, memory) {
                    this.draggedMemory = memory;
                    event.dataTransfer.setData('text/plain', memory.memory_id);
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleMemoryDrop(event) {
                    event.preventDefault();
                    if (this.draggedMemory && !this.activeWorkingMemories.find(m => m.memory_id === this.draggedMemory.memory_id)) {
                        this.addToWorkingMemory(this.draggedMemory);
                    }
                    this.draggedMemory = null;
                },

                handleMemoryDragOver(event) {
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'move';
                },

                handleEmptySlotDrop(event, slotIndex) {
                    event.preventDefault();
                    if (this.draggedMemory && !this.activeWorkingMemories.find(m => m.memory_id === this.draggedMemory.memory_id)) {
                        this.addToWorkingMemory(this.draggedMemory);
                    }
                    this.draggedMemory = null;
                },

                // Focus management
                applyFocusMode() {
                    const mode = this.focusSettings.mode;
                    
                    switch (mode) {
                        case 'deep':
                            this.focusSettings.maxWorkingMemory = 5;
                            this.focusSettings.retentionTime = 60;
                            break;
                        case 'creative':
                            this.focusSettings.maxWorkingMemory = 9;
                            this.focusSettings.retentionTime = 45;
                            break;
                        case 'analytical':
                            this.focusSettings.maxWorkingMemory = 6;
                            this.focusSettings.retentionTime = 90;
                            break;
                        case 'maintenance':
                            this.focusSettings.maxWorkingMemory = 3;
                            this.focusSettings.retentionTime = 20;
                            break;
                        default: // normal
                            this.focusSettings.maxWorkingMemory = 7;
                            this.focusSettings.retentionTime = 30;
                    }
                    
                    this.workingMemoryStats.capacity = this.focusSettings.maxWorkingMemory;
                    this.updateWorkingMemoryStats();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Applied ${mode} focus mode`, 'success');
                },

                enterDeepFocus() {
                    this.focusSettings.mode = 'deep';
                    this.applyFocusMode();
                    
                    // Keep only highest priority memories
                    const highPriority = this.activeWorkingMemories
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 5);
                    
                    this.activeWorkingMemories = highPriority;
                    this.updateWorkingMemoryStats();
                    
                    this.showToast('Entered deep focus mode ', 'success');
                },

                updateRetentionTime() {
                    // In a real implementation, this would update the backend retention policy
                    this.showToast(`Memory retention set to ${this.focusSettings.retentionTime} minutes`, 'info');
                },

                // Visualization and charts
                async renderWorkingMemoryCharts() {
                    if (!window.Chart) return;
                    
                    await this.$nextTick();
                    
                    try {
                        await this.renderMemoryPressureGauge();
                        await this.renderFocusScoreChart();
                        await this.renderMemoryHeatmap();
                    } catch (error) {
                        console.error('Error rendering working memory charts:', error);
                    }
                },

                async renderFocusScoreChart() {
                    const canvas = this.$refs.focusScoreChart;
                    if (!canvas || !canvas.getContext) {
                        console.warn('Focus score chart canvas not available or invalid');
                        return;
                    }
                    
                    // Verify canvas is still in DOM
                    if (!document.contains(canvas)) {
                        console.warn('Focus score chart canvas no longer in DOM');
                        return;
                    }
                    
                    // Clear any existing chart first
                    if (this.workingMemoryCharts.focusScore) {
                        try {
                            this.workingMemoryCharts.focusScore.destroy();
                        } catch (e) {
                            console.warn('Error destroying focus score chart:', e);
                        }
                        this.workingMemoryCharts.focusScore = null;
                    }
                    
                    // Reset canvas dimensions to prevent infinite growth
                    const canvasParent = canvas.parentElement;
                    const targetWidth = canvasParent ? canvasParent.clientWidth : 400;
                    const targetHeight = 128;
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    canvas.style.width = targetWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.style.maxHeight = targetHeight + 'px';
                    
                    // Calculate real focus history from memory access patterns
                    const focusHistory = [];
                    const now = Date.now() / 1000;
                    
                    for (let i = 9; i >= 0; i--) {
                        const intervalStart = now - ((i + 1) * 300); // 5 minutes intervals
                        const intervalEnd = now - (i * 300);
                        
                        // Calculate focus score for this time interval based on memory activity
                        const intervalMemories = this.memories.filter(m => 
                            m.created_at >= intervalStart && m.created_at <= intervalEnd
                        );
                        
                        // Focus is higher when fewer memory types are accessed (more focused activity)
                        const memoryTypes = new Set(intervalMemories.map(m => m.memory_type));
                        const typeVariety = memoryTypes.size;
                        const activityLevel = intervalMemories.length;
                        
                        // Calculate focus score (0-100)
                        let score = 50; // baseline
                        if (activityLevel > 0) {
                            score = Math.max(0, Math.min(100, 100 - (typeVariety * 15) + Math.min(activityLevel * 5, 30)));
                        }
                        
                        focusHistory.push({
                            time: new Date(intervalEnd * 1000),
                            score: Math.round(score)
                        });
                    }
                    
                    this.workingMemoryCharts.focusScore = new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: focusHistory.map(f => f.time.toLocaleTimeString('en-US', { 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            })),
                            datasets: [{
                                label: 'Focus Score',
                                data: focusHistory.map(f => Math.max(0, Math.min(100, f.score))),
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointRadius: 3,
                                pointHoverRadius: 6
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        color: '#9ca3af',
                                        callback: value => value + '%'
                                    },
                                    grid: { color: 'rgba(156, 163, 175, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#9ca3af' },
                                    grid: { display: false }
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                },

                async renderMemoryHeatmap() {
                    const container = this.$refs.memoryHeatmap;
                    if (!container || !window.d3) return;
                    
                    // Clear previous heatmap
                    d3.select(container).selectAll("*").remove();
                    
                    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
                    const width = Math.max(200, container.clientWidth - margin.left - margin.right);
                    const height = Math.max(100, container.clientHeight - margin.top - margin.bottom);
                    
                    const svg = d3.select(container)
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.bottom + margin.top)
                        .append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);
                    
                    // Create heatmap data
                    const data = this.memoryHeatmapData;
                    if (data.length === 0) return;
                    
                    const xScale = d3.scaleBand()
                        .domain(data.map((d, i) => i))
                        .range([0, width])
                        .padding(0.1);
                    
                    const colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
                        .domain([0, d3.max(data, d => d.intensity) || 1]);
                    
                    // Draw heatmap rectangles
                    svg.selectAll(".heatmap-rect")
                        .data(data)
                        .enter()
                        .append("rect")
                        .attr("class", "heatmap-rect")
                        .attr("x", (d, i) => xScale(i))
                        .attr("y", 10)
                        .attr("width", xScale.bandwidth())
                        .attr("height", Math.max(10, height - 50))
                        .attr("fill", d => colorScale(d.intensity))
                        .attr("rx", 4)
                        .on("mouseover", (event, d) => {
                            const tooltip = d3.select("body")
                                .append("div")
                                .attr("class", "heatmap-tooltip")
                                .style("position", "absolute")
                                .style("background", "rgba(0, 0, 0, 0.8)")
                                .style("color", "white")
                                .style("padding", "8px")
                                .style("border-radius", "4px")
                                .style("font-size", "12px")
                                .style("pointer-events", "none")
                                .style("z-index", "1000");
                            
                            tooltip.html(`Activity: ${d.activity}<br>Time: ${new Date(d.time * 1000).toLocaleString()}`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px");
                        })
                        .on("mouseout", () => {
                            d3.selectAll(".heatmap-tooltip").remove();
                        });
                    
                    // Add time labels
                    svg.selectAll(".time-label")
                        .data(data.filter((d, i) => i % Math.ceil(data.length / 6) === 0))
                        .enter()
                        .append("text")
                        .attr("class", "time-label")
                        .attr("x", (d, i) => xScale(i * Math.ceil(data.length / 6)) + xScale.bandwidth() / 2)
                        .attr("y", height - 10)
                        .attr("text-anchor", "middle")
                        .style("fill", "#9ca3af")
                        .style("font-size", "10px")
                        .text(d => {
                            const date = new Date(d.time * 1000);
                            return this.heatmapSettings.timeframe === '7d' 
                                ? date.toLocaleDateString('en-US', { weekday: 'short' })
                                : date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        });
                },

                updateHeatmap() {
                    this.updateMemoryHeatmapData();
                    this.renderMemoryHeatmap();
                },

                async renderMemoryPressureGauge() {
                    const canvas = this.$refs.memoryPressureGauge;
                    if (!canvas || !canvas.getContext) {
                        console.warn('Memory pressure gauge canvas not available or invalid');
                        return;
                    }
                    
                    // Verify canvas is still in DOM
                    if (!document.contains(canvas)) {
                        console.warn('Memory pressure gauge canvas no longer in DOM');
                        return;
                    }
                    
                    // Clear any existing chart first
                    if (this.workingMemoryCharts.memoryPressure) {
                        try {
                            this.workingMemoryCharts.memoryPressure.destroy();
                        } catch (e) {
                            console.warn('Error destroying memory pressure chart:', e);
                        }
                        this.workingMemoryCharts.memoryPressure = null;
                    }
                    
                    // Reset canvas dimensions to prevent infinite growth
                    const canvasParent = canvas.parentElement;
                    const targetWidth = canvasParent ? Math.min(canvasParent.clientWidth, 200) : 200;
                    const targetHeight = 200;
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    canvas.style.width = targetWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.style.maxHeight = targetHeight + 'px';
                    
                    // Calculate real memory pressure from database
                    const totalMemories = this.memories.length;
                    const recentMemories = this.executeQuery(`
                        SELECT COUNT(*) as count 
                        FROM memories 
                        WHERE created_at > ? 
                        AND memory_level = 'working'
                    `, [Date.now() / 1000 - 3600])[0]?.count || 0; // Last hour
                    
                    const workingMemoryCapacity = 7; // Standard working memory capacity
                    const pressure = Math.min(100, (recentMemories / workingMemoryCapacity) * 100);
                    
                    this.workingMemoryCharts.memoryPressure = new Chart(canvas, {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [pressure, 100 - pressure],
                                backgroundColor: [
                                    pressure > 80 ? '#ef4444' : pressure > 60 ? '#f59e0b' : '#10b981',
                                    '#374151'
                                ],
                                borderWidth: 0,
                                cutout: '70%'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            }
                        }
                    });
                    
                    // Update the real working memory stats
                    this.workingMemoryStats.memoryPressure = Math.round(pressure);
                },

                updateWorkingMemoryCharts() {
                    // Debounce chart updates to prevent excessive re-rendering
                    if (this.workingMemoryChartsUpdateTimer) {
                        clearTimeout(this.workingMemoryChartsUpdateTimer);
                    }
                    
                    this.workingMemoryChartsUpdateTimer = setTimeout(() => {
                        this.renderMemoryPressureGauge();
                        this.renderFocusScoreChart();
                    }, 250);
                },

                // Helper methods for styling
                getPressureColor(pressure) {
                    if (pressure > 80) return 'text-red-400';
                    if (pressure > 60) return 'text-yellow-400';
                    return 'text-green-400';
                },

                getPressureGradient(pressure) {
                    if (pressure > 80) return 'bg-red-400';
                    if (pressure > 60) return 'bg-yellow-400';
                    return 'bg-green-400';
                },

                getTemperatureColor(temperature) {
                    if (temperature > 70) return 'text-red-400';
                    if (temperature > 40) return 'text-yellow-400';
                    return 'text-blue-400';
                },

                getTemperatureGradient(temperature) {
                    if (temperature > 70) return 'bg-red-400';
                    if (temperature > 40) return 'bg-yellow-400';
                    return 'bg-blue-400';
                },

                getTemperatureIndicator(temperature) {
                    if (temperature > 70) return 'bg-red-400';
                    if (temperature > 40) return 'bg-yellow-400';
                    return 'bg-blue-400';
                },

                getPriorityColor(priority) {
                    const colors = {
                        critical: 'text-red-400',
                        high: 'text-orange-400',
                        medium: 'text-yellow-400',
                        low: 'text-gray-400'
                    };
                    return colors[priority] || 'text-gray-400';
                },

                getMemoryActivityClass(memory) {
                    if (memory.temperature > 70) return 'border-red-400/50 bg-red-400/5';
                    if (memory.temperature > 40) return 'border-yellow-400/50 bg-yellow-400/5';
                    return 'border-blue-400/50 bg-blue-400/5';
                },

                getMemoryTypeColor(memoryType) {
                    const colors = {
                        thought: 'text-blue-400',
                        goal: 'text-green-400',
                        plan: 'text-purple-400',
                        observation: 'text-yellow-400',
                        insight: 'text-pink-400',
                        decision: 'text-red-400'
                    };
                    return colors[memoryType] || 'text-gray-400';
                },

                getAccessFrequencyColor(accessCount) {
                    if (accessCount > 10) return 'bg-green-400';
                    if (accessCount > 5) return 'bg-yellow-400';
                    if (accessCount > 0) return 'bg-blue-400';
                    return 'bg-gray-400';
                },

                getSuggestionBorderClass(priority) {
                    const classes = {
                        high: 'border-red-400',
                        medium: 'border-yellow-400',
                        low: 'border-blue-400'
                    };
                    return classes[priority] || 'border-gray-400';
                },

                getSuggestionIconClass(priority) {
                    const classes = {
                        high: 'text-red-400',
                        medium: 'text-yellow-400',
                        low: 'text-blue-400'
                    };
                    return classes[priority] || 'text-gray-400';
                },

                getSuggestionPriorityClass(priority) {
                    const classes = {
                        high: 'bg-red-500/20 text-red-400',
                        medium: 'bg-yellow-500/20 text-yellow-400',
                        low: 'bg-blue-500/20 text-blue-400'
                    };
                    return classes[priority] || 'bg-gray-500/20 text-gray-400';
                },

                // =================== WORKFLOW DEPENDENCY GRAPH METHODS ===================

                async initializeWorkflowDependencies() {
                    console.log(' Initializing Workflow Dependency Graph...');
                    
                    try {
                        // Load workflow dependency data
                        await this.loadWorkflowDependencyData();
                        
                        // Initialize visualizations
                        await this.$nextTick();
                        this.renderWorkflowDependencyGraph();
                        
                        // Initialize Gantt chart
                        this.initializeGanttChart();
                        
                        console.log(' Workflow Dependency Graph initialized successfully');
                        
                    } catch (error) {
                        console.error(' Error initializing workflow dependencies:', error);
                        this.showToast('Error initializing workflow dependency graph', 'error');
                    }
                },

                async loadWorkflowDependencyData() {
                    try {
                        // Load workflows with enhanced timing and dependency information
                        this.dependencyWorkflows = this.workflows.map(workflow => {
                            const workflowActions = this.actions.filter(a => a.workflow_id === workflow.workflow_id);
                            
                            // Calculate workflow timeline
                            const startTime = workflowActions.length > 0 ? 
                                Math.min(...workflowActions.map(a => a.started_at || a.created_at)) : 
                                workflow.created_at;
                            const endTime = workflowActions.length > 0 ? 
                                Math.max(...workflowActions.map(a => a.completed_at || a.started_at || a.created_at)) : 
                                workflow.updated_at;
                            
                            return {
                                ...workflow,
                                start_time: startTime,
                                end_time: endTime,
                                duration: endTime - startTime,
                                actions: workflowActions,
                                dependencies: [],
                                dependents: [],
                                resources: this.extractWorkflowResources(workflow, workflowActions),
                                progress: this.calculateWorkflowProgress(workflowActions),
                                critical_path: false,
                                resource_conflicts: [],
                                x: 0,
                                y: 0
                            };
                        });

                        // Analyze workflow dependencies (mock implementation - in real app this would be from API)
                        this.analyzeWorkflowDependencies();
                        
                        // Calculate critical path
                        this.calculateCriticalPath();
                        
                        // Detect resource conflicts
                        this.detectResourceConflicts();
                        
                        // Load action dependencies within workflows
                        this.loadActionDependencies();
                        
                        console.log(`Loaded ${this.dependencyWorkflows.length} workflows with dependencies`);
                        
                    } catch (error) {
                        console.error('Error loading workflow dependency data:', error);
                        throw error;
                    }
                },

                extractWorkflowResources(workflow, actions) {
                    // Extract resources from workflow and actions
                    const resources = new Set();
                    
                    // Add workflow owner as resource
                    if (workflow.owner) resources.add(workflow.owner);
                    
                    // Extract from action tool usage
                    actions.forEach(action => {
                        if (action.tool_name) resources.add(`tool:${action.tool_name}`);
                        if (action.action_type) resources.add(`type:${action.action_type}`);
                    });
                    
                    return Array.from(resources);
                },

                calculateWorkflowProgress(actions) {
                    if (actions.length === 0) return 0;
                    
                    const completedActions = actions.filter(a => a.status === 'completed').length;
                    return Math.round((completedActions / actions.length) * 100);
                },

                analyzeWorkflowDependencies() {
                    // Mock dependency analysis - in real implementation this would use memory links, etc.
                    this.dependencyWorkflows.forEach((workflow, index) => {
                        // Create some sample dependencies based on creation order and shared resources
                        this.dependencyWorkflows.forEach((otherWorkflow, otherIndex) => {
                            if (index !== otherIndex) {
                                // Dependency if workflows share resources and one started after the other
                                const sharedResources = workflow.resources.filter(r => otherWorkflow.resources.includes(r));
                                const timeGap = workflow.start_time - otherWorkflow.start_time;
                                
                                if (sharedResources.length > 0 && timeGap > 0 && timeGap < 86400) { // Within 24 hours
                                    workflow.dependencies.push({
                                        workflow_id: otherWorkflow.workflow_id,
                                        type: 'resource_dependency',
                                        shared_resources: sharedResources,
                                        strength: sharedResources.length / Math.max(workflow.resources.length, 1)
                                    });
                                    
                                    otherWorkflow.dependents.push({
                                        workflow_id: workflow.workflow_id,
                                        type: 'resource_dependency',
                                        shared_resources: sharedResources,
                                        strength: sharedResources.length / Math.max(otherWorkflow.resources.length, 1)
                                    });
                                }
                            }
                        });
                    });
                },

                calculateCriticalPath() {
                    // Implementation of critical path method (CPM)
                    const workflows = [...this.dependencyWorkflows];
                    
                    // Reset critical path flags
                    workflows.forEach(w => {
                        w.critical_path = false;
                        w.earliest_start = 0;
                        w.latest_start = 0;
                        w.slack = 0;
                    });
                    
                    // Forward pass - calculate earliest start times
                    workflows.sort((a, b) => a.start_time - b.start_time);
                    
                    workflows.forEach(workflow => {
                        let maxEarliestFinish = 0;
                        
                        workflow.dependencies.forEach(dep => {
                            const depWorkflow = workflows.find(w => w.workflow_id === dep.workflow_id);
                            if (depWorkflow) {
                                const earliestFinish = depWorkflow.earliest_start + depWorkflow.duration;
                                maxEarliestFinish = Math.max(maxEarliestFinish, earliestFinish);
                            }
                        });
                        
                        workflow.earliest_start = maxEarliestFinish;
                    });
                    
                    // Backward pass - calculate latest start times
                    const projectEnd = Math.max(...workflows.map(w => w.earliest_start + w.duration));
                    
                    workflows.reverse().forEach(workflow => {
                        if (workflow.dependents.length === 0) {
                            workflow.latest_start = workflow.earliest_start;
                        } else {
                            let minLatestStart = projectEnd;
                            
                            workflow.dependents.forEach(dep => {
                                const depWorkflow = workflows.find(w => w.workflow_id === dep.workflow_id);
                                if (depWorkflow) {
                                    minLatestStart = Math.min(minLatestStart, depWorkflow.latest_start);
                                }
                            });
                            
                            workflow.latest_start = minLatestStart - workflow.duration;
                        }
                        
                        workflow.slack = workflow.latest_start - workflow.earliest_start;
                        workflow.critical_path = workflow.slack === 0;
                    });
                    
                    const criticalWorkflows = workflows.filter(w => w.critical_path);
                    this.criticalPathStats = {
                        totalWorkflows: criticalWorkflows.length,
                        totalDuration: projectEnd,
                        bottlenecks: criticalWorkflows.map(w => w.title || w.workflow_id)
                    };
                },

                detectResourceConflicts() {
                    const resourceSchedule = new Map();
                    
                    // Build resource usage timeline
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.resources.forEach(resource => {
                            if (!resourceSchedule.has(resource)) {
                                resourceSchedule.set(resource, []);
                            }
                            
                            resourceSchedule.get(resource).push({
                                workflow_id: workflow.workflow_id,
                                workflow_title: workflow.title,
                                start_time: workflow.start_time,
                                end_time: workflow.end_time,
                                resource: resource
                            });
                        });
                    });
                    
                    // Detect conflicts
                    this.resourceConflicts = [];
                    
                    resourceSchedule.forEach((usages, resource) => {
                        const sortedUsages = usages.sort((a, b) => a.start_time - b.start_time);
                        
                        for (let i = 0; i < sortedUsages.length - 1; i++) {
                            const current = sortedUsages[i];
                            const next = sortedUsages[i + 1];
                            
                            // Check for overlap
                            if (current.end_time > next.start_time) {
                                const conflict = {
                                    id: `conflict_${this.resourceConflicts.length}`,
                                    resource: resource,
                                    workflows: [
                                        { id: current.workflow_id, title: current.workflow_title },
                                        { id: next.workflow_id, title: next.workflow_title }
                                    ],
                                    overlap_start: next.start_time,
                                    overlap_end: Math.min(current.end_time, next.end_time),
                                    severity: this.calculateConflictSeverity(current, next),
                                    suggestions: this.generateConflictResolution(current, next)
                                };
                                
                                this.resourceConflicts.push(conflict);
                                
                                // Mark workflows with conflicts
                                const workflow1 = this.dependencyWorkflows.find(w => w.workflow_id === current.workflow_id);
                                const workflow2 = this.dependencyWorkflows.find(w => w.workflow_id === next.workflow_id);
                                
                                if (workflow1) workflow1.resource_conflicts.push(conflict.id);
                                if (workflow2) workflow2.resource_conflicts.push(conflict.id);
                            }
                        }
                    });
                },

                calculateConflictSeverity(usage1, usage2) {
                    const overlapDuration = Math.min(usage1.end_time, usage2.end_time) - usage2.start_time;
                    const totalDuration = Math.max(usage1.end_time - usage1.start_time, usage2.end_time - usage2.start_time);
                    const overlapPercentage = (overlapDuration / totalDuration) * 100;
                    
                    if (overlapPercentage > 75) return 'high';
                    if (overlapPercentage > 25) return 'medium';
                    return 'low';
                },

                generateConflictResolution(usage1, usage2) {
                    const suggestions = [];
                    
                    suggestions.push({
                        type: 'delay',
                        description: `Delay "${usage2.workflow_title}" until "${usage1.workflow_title}" completes`,
                        impact: 'schedule_delay'
                    });
                    
                    suggestions.push({
                        type: 'resource_split',
                        description: `Split ${usage1.resource} usage between workflows`,
                        impact: 'reduced_efficiency'
                    });
                    
                    suggestions.push({
                        type: 'parallel_resource',
                        description: `Assign additional ${usage1.resource} instances`,
                        impact: 'increased_cost'
                    });
                    
                    return suggestions;
                },

                loadActionDependencies() {
                    // Load action-level dependencies within workflows
                    this.dependencyWorkflows.forEach(workflow => {
                        const actions = workflow.actions.sort((a, b) => (a.started_at || a.created_at) - (b.started_at || b.created_at));
                        
                        // Create sequential dependencies between actions
                        actions.forEach((action, index) => {
                            action.dependencies = [];
                            action.dependents = [];
                            action.slack = 0;
                            action.critical_path = false;
                            
                            if (index > 0) {
                                action.dependencies.push({
                                    action_id: actions[index - 1].action_id,
                                    type: 'sequential',
                                    strength: 1.0
                                });
                                
                                actions[index - 1].dependents.push({
                                    action_id: action.action_id,
                                    type: 'sequential',
                                    strength: 1.0
                                });
                            }
                        });
                        
                        workflow.actions = actions;
                    });
                },

                renderWorkflowDependencyGraph() {
                    if (!window.d3 || !this.dependencyWorkflows.length) {
                        console.log('D3 not available or no workflow data');
                        return;
                    }
                    
                    try {
                        this.renderNetworkView();
                        this.renderGanttView();
                        
                        console.log('Workflow dependency graph rendered successfully');
                        
                    } catch (error) {
                        console.error('Error rendering workflow dependency graph:', error);
                    }
                },

                renderNetworkView() {
                    const svg = d3.select(this.$refs.dependencyNetworkSvg);
                    const container = this.$refs.dependencyNetworkSvg.parentElement;
                    const rect = container.getBoundingClientRect();
                    
                    const width = rect.width;
                    const height = rect.height;
                    
                    // Clear previous content
                    svg.selectAll("*").remove();
                    svg.attr("width", width).attr("height", height);
                    
                    // Create main group
                    const g = svg.append("g").attr("class", "network-content");
                    
                    // Add zoom behavior
                    const zoom = d3.zoom()
                        .scaleExtent([0.3, 3])
                        .on("zoom", (event) => {
                            g.attr("transform", event.transform);
                        });
                    
                    svg.call(zoom);
                    
                    // Prepare data for network visualization
                    const nodes = this.dependencyWorkflows.map(workflow => ({
                        id: workflow.workflow_id,
                        ...workflow,
                        fx: null,
                        fy: null
                    }));
                    
                    const links = [];
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.dependencies.forEach(dep => {
                            links.push({
                                source: dep.workflow_id,
                                target: workflow.workflow_id,
                                type: dep.type,
                                strength: dep.strength
                            });
                        });
                    });
                    
                    // Create force simulation
                    const simulation = d3.forceSimulation(nodes)
                        .force("link", d3.forceLink(links).id(d => d.id).distance(120))
                        .force("charge", d3.forceManyBody().strength(-300))
                        .force("center", d3.forceCenter(width / 2, height / 2))
                        .force("collision", d3.forceCollide().radius(40));
                    
                    // Draw links
                    const link = g.append("g")
                        .attr("class", "links")
                        .selectAll("line")
                        .data(links)
                        .enter().append("line")
                        .attr("stroke", d => this.getDependencyLinkColor(d.type))
                        .attr("stroke-width", d => Math.max(1, d.strength * 4))
                        .attr("stroke-opacity", 0.8)
                        .attr("marker-end", "url(#arrowhead)");
                    
                    // Add arrowhead marker
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 25)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#64748b");
                    
                    // Draw nodes
                    const node = g.append("g")
                        .attr("class", "nodes")
                        .selectAll("g")
                        .data(nodes)
                        .enter().append("g")
                        .attr("class", "workflow-node")
                        .style("cursor", "pointer")
                        .call(this.createWorkflowDrag(simulation));
                    
                    // Node backgrounds
                    node.append("rect")
                        .attr("x", -35)
                        .attr("y", -20)
                        .attr("width", 70)
                        .attr("height", 40)
                        .attr("rx", 8)
                        .attr("fill", d => this.getWorkflowNodeColor(d))
                        .attr("stroke", d => d.critical_path ? "#ef4444" : "#64748b")
                        .attr("stroke-width", d => d.critical_path ? 3 : 1)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
                    
                    // Node titles
                    node.append("text")
                        .attr("dy", "-5")
                        .attr("text-anchor", "middle")
                        .style("fill", "#ffffff")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .style("pointer-events", "none")
                        .text(d => this.truncateText(d.title || d.workflow_id, 12));
                    
                    // Progress indicators
                    node.append("text")
                        .attr("dy", "8")
                        .attr("text-anchor", "middle")
                        .style("fill", "#d1d5db")
                        .style("font-size", "8px")
                        .style("pointer-events", "none")
                        .text(d => `${d.progress}%`);
                    
                    // Conflict indicators
                    node.filter(d => d.resource_conflicts.length > 0)
                        .append("circle")
                        .attr("cx", 25)
                        .attr("cy", -15)
                        .attr("r", 6)
                        .attr("fill", "#ef4444")
                        .style("animation", "pulse 2s infinite");
                    
                    // Add interactions
                    node
                        .on("click", (event, d) => this.selectWorkflowNode(d))
                        .on("mouseover", (event, d) => this.showWorkflowTooltip(event, d))
                        .on("mouseout", () => this.hideWorkflowTooltip());
                    
                    // Update positions on simulation tick
                    simulation.on("tick", () => {
                        link
                            .attr("x1", d => d.source.x)
                            .attr("y1", d => d.source.y)
                            .attr("x2", d => d.target.x)
                            .attr("y2", d => d.target.y);
                        
                        node.attr("transform", d => `translate(${d.x}, ${d.y})`);
                    });
                    
                    this.dependencySimulation = simulation;
                },

                renderGanttView() {
                    const container = this.$refs.ganttContainer;
                    if (!container) return;
                    
                    // Clear previous content
                    d3.select(container).selectAll("*").remove();
                    
                    const margin = { top: 40, right: 40, bottom: 40, left: 200 };
                    const width = container.clientWidth - margin.left - margin.right;
                    const height = Math.max(400, this.dependencyWorkflows.length * 50 + 100);
                    
                    const svg = d3.select(container)
                        .append("svg")
                        .attr("width", container.clientWidth)
                        .attr("height", height + margin.top + margin.bottom);
                    
                    const g = svg.append("g")
                        .attr("transform", `translate(${margin.left}, ${margin.top})`);
                    
                    // Create scales
                    const timeExtent = d3.extent([
                        ...this.dependencyWorkflows.map(d => d.start_time),
                        ...this.dependencyWorkflows.map(d => d.end_time)
                    ]);
                    
                    const xScale = d3.scaleTime()
                        .domain(timeExtent.map(t => new Date(t * 1000)))
                        .range([0, width]);
                    
                    const yScale = d3.scaleBand()
                        .domain(this.dependencyWorkflows.map(d => d.workflow_id))
                        .range([0, this.dependencyWorkflows.length * 50])
                        .padding(0.2);
                    
                    // Add time axis
                    g.append("g")
                        .attr("class", "x-axis")
                        .call(d3.axisTop(xScale).tickFormat(d3.timeFormat("%m/%d %H:%M")))
                        .style("color", "#9ca3af");
                    
                    // Add grid lines
                    g.append("g")
                        .attr("class", "grid")
                        .call(d3.axisTop(xScale)
                            .tickSize(-this.dependencyWorkflows.length * 50)
                            .tickFormat("")
                        )
                        .style("stroke-dasharray", "3,3")
                        .style("opacity", 0.3);
                    
                    // Draw workflow bars
                    const workflows = g.append("g")
                        .attr("class", "workflows")
                        .selectAll(".workflow-bar")
                        .data(this.dependencyWorkflows)
                        .enter().append("g")
                        .attr("class", "workflow-bar")
                        .attr("transform", d => `translate(0, ${yScale(d.workflow_id)})`);
                    
                    // Workflow labels
                    workflows.append("text")
                        .attr("x", -10)
                        .attr("y", yScale.bandwidth() / 2)
                        .attr("dy", "0.35em")
                        .attr("text-anchor", "end")
                        .style("fill", "#e5e7eb")
                        .style("font-size", "12px")
                        .style("font-weight", "500")
                        .text(d => this.truncateText(d.title || d.workflow_id, 25));
                    
                    // Workflow bars
                    workflows.append("rect")
                        .attr("x", d => xScale(new Date(d.start_time * 1000)))
                        .attr("width", d => Math.max(2, xScale(new Date(d.end_time * 1000)) - xScale(new Date(d.start_time * 1000))))
                        .attr("height", yScale.bandwidth())
                        .attr("fill", d => this.getWorkflowBarColor(d))
                        .attr("stroke", d => d.critical_path ? "#ef4444" : "transparent")
                        .attr("stroke-width", 2)
                        .style("cursor", "ew-resize")
                        .call(this.createGanttDrag(xScale, yScale));
                    
                    // Progress bars
                    workflows.append("rect")
                        .attr("x", d => xScale(new Date(d.start_time * 1000)))
                        .attr("width", d => Math.max(0, (xScale(new Date(d.end_time * 1000)) - xScale(new Date(d.start_time * 1000))) * (d.progress / 100)))
                        .attr("height", yScale.bandwidth() / 3)
                        .attr("y", yScale.bandwidth() / 3)
                        .attr("fill", "#22c55e")
                        .style("pointer-events", "none");
                    
                    // Dependency arrows
                    const dependencies = [];
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.dependencies.forEach(dep => {
                            const sourceWorkflow = this.dependencyWorkflows.find(w => w.workflow_id === dep.workflow_id);
                            if (sourceWorkflow) {
                                dependencies.push({
                                    source: sourceWorkflow,
                                    target: workflow,
                                    ...dep
                                });
                            }
                        });
                    });
                    
                    g.append("g")
                        .attr("class", "dependencies")
                        .selectAll(".dependency-line")
                        .data(dependencies)
                        .enter().append("line")
                        .attr("class", "dependency-line")
                        .attr("x1", d => xScale(new Date(d.source.end_time * 1000)))
                        .attr("y1", d => yScale(d.source.workflow_id) + yScale.bandwidth() / 2)
                        .attr("x2", d => xScale(new Date(d.target.start_time * 1000)))
                        .attr("y2", d => yScale(d.target.workflow_id) + yScale.bandwidth() / 2)
                        .attr("stroke", "#64748b")
                        .attr("stroke-width", 2)
                        .attr("marker-end", "url(#gantt-arrowhead)");
                    
                    // Add arrowhead marker for Gantt
                    svg.append("defs").append("marker")
                        .attr("id", "gantt-arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 10)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#64748b");
                    
                    this.ganttSvg = svg;
                    this.ganttXScale = xScale;
                    this.ganttYScale = yScale;
                },

                createWorkflowDrag(simulation) {
                    return d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        });
                },

                createGanttDrag(xScale, yScale) {
                    return d3.drag()
                        .on("start", (event, d) => {
                            this.isDraggingWorkflow = true;
                            this.originalWorkflowTiming = {
                                workflow_id: d.workflow_id,
                                start_time: d.start_time,
                                end_time: d.end_time
                            };
                        })
                        .on("drag", (event, d) => {
                            const newStartTime = Math.round(xScale.invert(event.x).getTime() / 1000);
                            const duration = d.end_time - d.start_time;
                            
                            d.start_time = newStartTime;
                            d.end_time = newStartTime + duration;
                            
                            // Update the visual position
                            d3.select(event.sourceEvent.target)
                                .attr("x", xScale(new Date(d.start_time * 1000)));
                            
                            // Check for conflicts during drag
                            this.highlightScheduleConflicts(d);
                        })
                        .on("end", (event, d) => {
                            this.isDraggingWorkflow = false;
                            
                            // Validate the new schedule
                            const conflicts = this.validateScheduleChange(d);
                            
                            if (conflicts.length > 0 && !this.simulationMode) {
                                // Revert if conflicts exist and not in simulation mode
                                const original = this.originalWorkflowTiming;
                                d.start_time = original.start_time;
                                d.end_time = original.end_time;
                                
                                this.showToast(`Schedule conflict detected. Changes reverted.`, 'warning');
                                this.renderGanttView(); // Re-render to show original positions
                            } else {
                                // Apply the changes
                                this.applyScheduleChange(d);
                                
                                // Recalculate dependencies and conflicts
                                this.calculateCriticalPath();
                                this.detectResourceConflicts();
                                
                                if (conflicts.length > 0) {
                                    this.showToast(`Schedule updated with ${conflicts.length} conflicts`, 'warning');
                                } else {
                                    this.showToast('Schedule updated successfully', 'success');
                                }
                            }
                        });
                },

                highlightScheduleConflicts(workflow) {
                    // Temporarily highlight potential conflicts during drag
                    const conflicts = this.validateScheduleChange(workflow);
                    
                    if (this.ganttSvg) {
                        this.ganttSvg.selectAll(".workflow-bar rect")
                            .attr("stroke", d => {
                                if (d.workflow_id === workflow.workflow_id) return "#3b82f6";
                                return conflicts.some(c => c.workflows.includes(d.workflow_id)) ? "#ef4444" : "transparent";
                            })
                            .attr("stroke-width", d => {
                                if (d.workflow_id === workflow.workflow_id) return 3;
                                return conflicts.some(c => c.workflows.includes(d.workflow_id)) ? 2 : 1;
                            });
                    }
                },

                validateScheduleChange(workflow) {
                    const conflicts = [];
                    
                    // Check resource conflicts
                    this.dependencyWorkflows.forEach(otherWorkflow => {
                        if (otherWorkflow.workflow_id === workflow.workflow_id) return;
                        
                        const sharedResources = workflow.resources.filter(r => otherWorkflow.resources.includes(r));
                        if (sharedResources.length === 0) return;
                        
                        // Check for time overlap
                        const overlap = !(workflow.end_time <= otherWorkflow.start_time || workflow.start_time >= otherWorkflow.end_time);
                        
                        if (overlap) {
                            conflicts.push({
                                type: 'resource_conflict',
                                workflows: [workflow.workflow_id, otherWorkflow.workflow_id],
                                resources: sharedResources,
                                severity: this.calculateOverlapSeverity(workflow, otherWorkflow)
                            });
                        }
                    });
                    
                    // Check dependency violations
                    workflow.dependencies.forEach(dep => {
                        const depWorkflow = this.dependencyWorkflows.find(w => w.workflow_id === dep.workflow_id);
                        if (depWorkflow && workflow.start_time < depWorkflow.end_time) {
                            conflicts.push({
                                type: 'dependency_violation',
                                workflows: [workflow.workflow_id, depWorkflow.workflow_id],
                                violation: 'workflow_starts_before_dependency_completes'
                            });
                        }
                    });
                    
                    return conflicts;
                },

                calculateOverlapSeverity(workflow1, workflow2) {
                    const overlapStart = Math.max(workflow1.start_time, workflow2.start_time);
                    const overlapEnd = Math.min(workflow1.end_time, workflow2.end_time);
                    const overlapDuration = overlapEnd - overlapStart;
                    
                    const totalDuration = Math.min(workflow1.duration, workflow2.duration);
                    const overlapPercentage = (overlapDuration / totalDuration) * 100;
                    
                    if (overlapPercentage > 75) return 'high';
                    if (overlapPercentage > 25) return 'medium';
                    return 'low';
                },

                async applyScheduleChange(workflow) {
                    try {
                        // In a real implementation, this would call the backend API
                        const response = await fetch(`/api/workflows/${workflow.workflow_id}/schedule`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                start_time: workflow.start_time,
                                end_time: workflow.end_time,
                                simulation_mode: this.simulationMode
                            })
                        });
                        
                        if (!response.ok && !this.simulationMode) {
                            throw new Error('Failed to update workflow schedule');
                        }
                        
                        // Update local data
                        const workflowIndex = this.dependencyWorkflows.findIndex(w => w.workflow_id === workflow.workflow_id);
                        if (workflowIndex !== -1) {
                            this.dependencyWorkflows[workflowIndex] = workflow;
                        }
                        
                    } catch (error) {
                        console.error('Error applying schedule change:', error);
                        if (!this.simulationMode) {
                            throw error;
                        }
                    }
                },

                // Visual styling methods
                getWorkflowNodeColor(workflow) {
                    if (workflow.critical_path) return '#dc2626';
                    if (workflow.resource_conflicts.length > 0) return '#f59e0b';
                    
                    switch (workflow.status) {
                        case 'completed': return '#10b981';
                        case 'active': return '#3b82f6';
                        case 'paused': return '#6b7280';
                        case 'failed': return '#ef4444';
                        default: return '#8b5cf6';
                    }
                },

                getWorkflowBarColor(workflow) {
                    const baseColor = this.getWorkflowNodeColor(workflow);
                    return workflow.critical_path ? baseColor : d3.color(baseColor).opacity(0.8);
                },

                getDependencyLinkColor(type) {
                    const colors = {
                        'resource_dependency': '#f59e0b',
                        'sequential': '#3b82f6',
                        'conditional': '#8b5cf6',
                        'causal': '#10b981'
                    };
                    return colors[type] || '#64748b';
                },

                getConflictSeverityColor(severity) {
                    const colors = {
                        'high': '#ef4444',
                        'medium': '#f59e0b',
                        'low': '#3b82f6'
                    };
                    return colors[severity] || '#6b7280';
                },

                // Interaction methods
                selectWorkflowNode(workflow) {
                    this.selectedDependencyWorkflow = workflow;
                    
                    // Highlight connected workflows
                    if (this.dependencySimulation) {
                        const svg = d3.select(this.$refs.dependencyNetworkSvg);
                        
                        svg.selectAll(".workflow-node rect")
                            .attr("stroke-width", d => {
                                if (d.workflow_id === workflow.workflow_id) return 4;
                                if (workflow.dependencies.some(dep => dep.workflow_id === d.workflow_id) ||
                                    workflow.dependents.some(dep => dep.workflow_id === d.workflow_id)) return 2;
                                return 1;
                            })
                            .attr("stroke", d => {
                                if (d.workflow_id === workflow.workflow_id) return "#3b82f6";
                                if (workflow.dependencies.some(dep => dep.workflow_id === d.workflow_id)) return "#10b981";
                                if (workflow.dependents.some(dep => dep.workflow_id === d.workflow_id)) return "#f59e0b";
                                return d.critical_path ? "#ef4444" : "#64748b";
                            });
                    }
                },

                showWorkflowTooltip(event, workflow) {
                    const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "workflow-dependency-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0, 0, 0, 0.9)")
                        .style("color", "white")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000")
                        .style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)");
                    
                    const startDate = new Date(workflow.start_time * 1000);
                    const endDate = new Date(workflow.end_time * 1000);
                    
                    tooltip.html(`
                        <div class="font-semibold mb-2">${workflow.title || workflow.workflow_id}</div>
                        <div class="text-sm space-y-1">
                            <div>Status: <span class="text-blue-400">${workflow.status}</span></div>
                            <div>Progress: <span class="text-green-400">${workflow.progress}%</span></div>
                            <div>Start: ${startDate.toLocaleString()}</div>
                            <div>End: ${endDate.toLocaleString()}</div>
                            <div>Duration: ${this.formatDuration(workflow.start_time, workflow.end_time)}</div>
                            <div>Actions: ${workflow.actions.length}</div>
                            <div>Dependencies: ${workflow.dependencies.length}</div>
                            <div>Resources: ${workflow.resources.length}</div>
                            ${workflow.critical_path ? '<div class="text-red-400 font-semibold"> Critical Path</div>' : ''}
                            ${workflow.resource_conflicts.length > 0 ? '<div class="text-yellow-400 font-semibold"> Resource Conflicts</div>' : ''}
                        </div>
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                },

                hideWorkflowTooltip() {
                    d3.selectAll(".workflow-dependency-tooltip").remove();
                },

                // Simulation and optimization methods
                toggleSimulationMode() {
                    this.simulationMode = !this.simulationMode;
                    
                    if (this.simulationMode) {
                        this.createSimulationSnapshot();
                        this.showToast('Simulation mode enabled - changes are temporary', 'info');
                    } else {
                        this.showToast('Simulation mode disabled - changes will be permanent', 'warning');
                    }
                },

                createSimulationSnapshot() {
                    this.simulationSnapshot = {
                        workflows: JSON.parse(JSON.stringify(this.dependencyWorkflows)),
                        conflicts: JSON.parse(JSON.stringify(this.resourceConflicts)),
                        criticalPath: JSON.parse(JSON.stringify(this.criticalPathStats)),
                        timestamp: Date.now()
                    };
                },

                restoreFromSnapshot() {
                    if (!this.simulationSnapshot) {
                        this.showToast('No snapshot available to restore', 'warning');
                        return;
                    }
                    
                    this.dependencyWorkflows = this.simulationSnapshot.workflows;
                    this.resourceConflicts = this.simulationSnapshot.conflicts;
                    this.criticalPathStats = this.simulationSnapshot.criticalPath;
                    
                    this.renderWorkflowDependencyGraph();
                    this.showToast('Restored from simulation snapshot', 'success');
                },

                async optimizeSchedule() {
                    if (this.isOptimizingSchedule) return;
                    
                    this.isOptimizingSchedule = true;
                    
                    try {
                        // Implement schedule optimization algorithm
                        const optimizedSchedule = await this.runScheduleOptimization();
                        
                        if (optimizedSchedule) {
                            // Apply optimized schedule
                            this.dependencyWorkflows = optimizedSchedule.workflows;
                            this.resourceConflicts = optimizedSchedule.conflicts;
                            this.criticalPathStats = optimizedSchedule.criticalPath;
                            
                            this.renderWorkflowDependencyGraph();
                            this.showToast(`Schedule optimized! Reduced conflicts by ${optimizedSchedule.improvement}%`, 'success');
                        }
                        
                    } catch (error) {
                        console.error('Error optimizing schedule:', error);
                        this.showToast('Error during schedule optimization', 'error');
                    } finally {
                        this.isOptimizingSchedule = false;
                    }
                },

                async runScheduleOptimization() {
                    // Simple optimization algorithm - in practice this would be more sophisticated
                    const workflows = [...this.dependencyWorkflows];
                    let totalImprovements = 0;
                    
                    // Sort by critical path and dependencies
                    const sortedWorkflows = workflows.sort((a, b) => {
                        if (a.critical_path && !b.critical_path) return -1;
                        if (!a.critical_path && b.critical_path) return 1;
                        return a.dependencies.length - b.dependencies.length;
                    });
                    
                    // Try to resolve conflicts by shifting non-critical workflows
                    for (const workflow of sortedWorkflows) {
                        if (workflow.critical_path) continue;
                        
                        const originalConflicts = this.validateScheduleChange(workflow).length;
                        
                        // Try shifting later
                        const shiftAmount = 3600; // 1 hour
                        workflow.start_time += shiftAmount;
                        workflow.end_time += shiftAmount;
                        
                        const newConflicts = this.validateScheduleChange(workflow).length;
                        
                        if (newConflicts < originalConflicts) {
                            totalImprovements += originalConflicts - newConflicts;
                        } else {
                            // Revert if no improvement
                            workflow.start_time -= shiftAmount;
                            workflow.end_time -= shiftAmount;
                        }
                    }
                    
                    // Recalculate everything
                    this.dependencyWorkflows = workflows;
                    this.calculateCriticalPath();
                    this.detectResourceConflicts();
                    
                    return {
                        workflows: this.dependencyWorkflows,
                        conflicts: this.resourceConflicts,
                        criticalPath: this.criticalPathStats,
                        improvement: Math.round((totalImprovements / Math.max(1, workflows.length)) * 100)
                    };
                },

                exportSchedule() {
                    const exportData = {
                        workflows: this.dependencyWorkflows,
                        dependencies: this.dependencyWorkflows.flatMap(w => 
                            w.dependencies.map(d => ({
                                source: d.workflow_id,
                                target: w.workflow_id,
                                type: d.type,
                                strength: d.strength
                            }))
                        ),
                        conflicts: this.resourceConflicts,
                        criticalPath: this.criticalPathStats,
                        simulation: this.simulationMode,
                        exported_at: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `workflow-dependencies-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Schedule exported successfully! ', 'success');
                },

                resetDependencyView() {
                    this.selectedDependencyWorkflow = null;
                    this.dependencyViewMode = 'combined';
                    this.simulationMode = false;
                    this.simulationSnapshot = null;
                    this.dependencyFilter = '';
                    
                    if (this.dependencySimulation) {
                        this.dependencySimulation.restart();
                    }
                    
                    this.showToast('Dependency view reset', 'info');
                },

                initializeGanttChart() {
                    // This method is called during initialization to set up Gantt chart specific features
                    // Most of the Gantt functionality is handled in renderGanttView()
                    console.log('Gantt chart features initialized');
                },

                // =================== COGNITIVE STATE TIMELINE METHODS ===================

                async initializeCognitiveTimeline() {
                    console.log(' Initializing Cognitive State Timeline...');
                    
                    try {
                        // Load initial timeline data
                        await this.loadCognitiveTimeline();
                        
                        // Initialize timeline visualization
                        await this.$nextTick();
                        this.renderTimelineVisualization();
                        
                        console.log(' Cognitive State Timeline initialized successfully');
                        
                    } catch (error) {
                        console.error(' Error initializing cognitive timeline:', error);
                        this.showToast('Error initializing cognitive timeline', 'error');
                    }
                },

                async loadCognitiveTimeline() {
                    if (this.isLoadingTimeline) return;
                    
                    this.isLoadingTimeline = true;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/timeline?hours=${this.cognitiveTimelineSettings.timeRange}&granularity=${this.cognitiveTimelineSettings.granularity}`);
                        
                        if (!response.ok) {
                            if (response.status === 404) {
                                console.log(' Cognitive timeline API not available, using database fallback');
                            } else {
                                console.log(` Cognitive timeline API error (${response.status}), using database fallback`);
                            }
                            throw new Error(`API not available: ${response.status}`);
                        }
                        
                        // Check if response is JSON
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error('API returned non-JSON response');
                        }
                        
                        const data = await response.json();
                        
                        this.cognitiveTimelineData = data.timeline_data || [];
                        this.timelineStats = data.summary_stats || {};
                        
                        // Set initial position
                        if (this.cognitiveTimelineData.length > 0) {
                            this.currentTimelineIndex = this.cognitiveTimelineData.length - 1; // Start at latest
                            this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        }
                        
                        // Update visualization if already rendered
                        if (this.currentView === 'cognitive-timeline') {
                            await this.$nextTick();
                            this.renderTimelineVisualization();
                        }
                        
                        console.log(` Loaded ${this.cognitiveTimelineData.length} cognitive states from API`);
                        
                    } catch (error) {
                        // Silently fall back to database loading without showing error toast
                        console.log(' Loading cognitive timeline from database...');
                        
                        // Load real data from database
                        this.loadCognitiveTimelineFromDatabase();
                    } finally {
                        this.isLoadingTimeline = false;
                    }
                },

                loadCognitiveTimelineFromDatabase() {
                    try {
                        // Load real cognitive timeline data from memory analysis
                        const thoughts = this.executeQuery(`
                            SELECT 
                                memory_id,
                                memory_type,
                                content,
                                importance,
                                confidence,
                                created_at,
                                workflow_id
                            FROM memories 
                            WHERE memory_type IN ('thought', 'reasoning', 'analysis', 'plan', 'goal')
                            ORDER BY created_at DESC
                            LIMIT 50
                        `);
                        
                        this.cognitiveTimelineData = thoughts.map((thought, index) => ({
                            state_id: thought.memory_id,
                            state_type: thought.memory_type,
                            timestamp: thought.created_at,
                            complexity_score: (thought.importance || 5) * 10, // Convert 1-10 scale to 10-100
                            change_magnitude: Math.min(100, (thought.content?.length || 0) / 10), // Based on content length
                            sequence_number: index + 1,
                            description: thought.content || 'No description',
                            metadata: {
                                confidence: thought.confidence || 0.5,
                                workflow_id: thought.workflow_id
                            }
                        }));
                        
                        if (this.cognitiveTimelineData.length > 0) {
                            this.currentTimelineIndex = this.cognitiveTimelineData.length - 1;
                            this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        }
                        
                        // Calculate real stats
                        this.timelineStats = {
                            total_states: this.cognitiveTimelineData.length,
                            avg_complexity: this.cognitiveTimelineData.length > 0 ? 
                                this.cognitiveTimelineData.reduce((sum, s) => sum + s.complexity_score, 0) / this.cognitiveTimelineData.length : 0,
                            state_transitions: Math.max(0, this.cognitiveTimelineData.length - 1),
                            most_active_period: this.getMostActiveTimePeriod()
                        };
                        
                        console.log(` Loaded ${this.cognitiveTimelineData.length} cognitive states from database`);
                        
                        // Update visualization if already rendered
                        if (this.currentView === 'cognitive-timeline') {
                            this.$nextTick(() => {
                                this.renderTimelineVisualization();
                            });
                        }
                        
                    } catch (error) {
                        console.error('Error loading cognitive timeline from database:', error);
                        this.cognitiveTimelineData = [];
                        this.timelineStats = {
                            total_states: 0,
                            avg_complexity: 0,
                            state_transitions: 0,
                            most_active_period: 'No data'
                        };
                    }
                },
                
                getMostActiveTimePeriod() {
                    if (this.cognitiveTimelineData.length === 0) return 'No data';
                    
                    const now = Date.now() / 1000;
                    const last6h = this.cognitiveTimelineData.filter(s => s.timestamp > now - 21600).length;
                    const last24h = this.cognitiveTimelineData.filter(s => s.timestamp > now - 86400).length;
                    const last7d = this.cognitiveTimelineData.filter(s => s.timestamp > now - 604800).length;
                    
                    if (last6h > 5) return 'Last 6 hours';
                    if (last24h > 10) return 'Last 24 hours';
                    if (last7d > 20) return 'Last 7 days';
                    return 'Historical';
                },

                async refreshCognitiveTimeline() {
                    await this.loadCognitiveTimeline();
                    if (this.timelineViewMode === 'timeline') {
                        this.renderTimelineVisualization();
                    } else if (this.timelineViewMode === 'heatmap') {
                        this.renderTimelineHeatmap();
                    } else if (this.timelineViewMode === 'network') {
                        this.renderTimelineNetwork();
                    }
                },

                async analyzePatterns() {
                    if (this.isAnalyzingPatterns) return;
                    
                    this.isAnalyzingPatterns = true;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/patterns?lookback_hours=${this.cognitiveTimelineSettings.timeRange}`);
                        
                        if (response.ok) {
                            this.patternAnalysis = await response.json();
                            this.showToast(`Found ${this.patternAnalysis.summary.pattern_count} patterns`, 'success');
                        } else {
                            throw new Error('Failed to analyze patterns');
                        }
                        
                    } catch (error) {
                        console.error('Error analyzing patterns:', error);
                        this.showToast('Error analyzing patterns', 'error');
                    } finally {
                        this.isAnalyzingPatterns = false;
                    }
                },

                renderTimelineVisualization() {
                    if (!window.d3 || !this.cognitiveTimelineData.length) {
                        console.log('D3 not available or no timeline data');
                        return;
                    }
                    
                    try {
                        const svg = d3.select(this.$refs.cognitiveTimelineSvg);
                        const container = this.$refs.cognitiveTimelineSvg.parentElement;
                        const rect = container.getBoundingClientRect();
                        
                        const margin = { top: 40, right: 40, bottom: 80, left: 80 };
                        const width = rect.width - margin.left - margin.right;
                        const height = rect.height - margin.top - margin.bottom;
                        
                        // Clear previous content
                        svg.selectAll("*").remove();
                        
                        // Set dimensions
                        svg.attr("width", rect.width).attr("height", rect.height);
                        
                        // Create main group
                        const g = svg.append("g")
                            .attr("transform", `translate(${margin.left}, ${margin.top})`);
                        
                        // Create scales
                        const xScale = d3.scaleTime()
                            .domain(d3.extent(this.cognitiveTimelineData, d => new Date(d.timestamp * 1000)))
                            .range([0, width]);
                        
                        const yScale = d3.scaleLinear()
                            .domain([0, 100])
                            .range([height, 0]);
                        
                        const radiusScale = d3.scaleSqrt()
                            .domain([0, d3.max(this.cognitiveTimelineData, d => d.change_magnitude)])
                            .range([3, 15]);
                        
                        // Color scale for state types
                        const colorScale = d3.scaleOrdinal()
                            .domain([...new Set(this.cognitiveTimelineData.map(d => d.state_type))])
                            .range(['#10b981', '#3b82f6', '#8b5cf6', '#f59e0b', '#ef4444', '#06b6d4']);
                        
                        // Add grid lines
                        g.append("g")
                            .attr("class", "grid")
                            .attr("transform", `translate(0, ${height})`)
                            .call(d3.axisBottom(xScale)
                                .tickSize(-height)
                                .tickFormat("")
                            )
                            .style("stroke-dasharray", "3,3")
                            .style("opacity", 0.3);
                        
                        g.append("g")
                            .attr("class", "grid")
                            .call(d3.axisLeft(yScale)
                                .tickSize(-width)
                                .tickFormat("")
                            )
                            .style("stroke-dasharray", "3,3")
                            .style("opacity", 0.3);
                        
                        // Add complexity line
                        const line = d3.line()
                            .x(d => xScale(new Date(d.timestamp * 1000)))
                            .y(d => yScale(d.complexity_score))
                            .curve(d3.curveMonotoneX);
                        
                        g.append("path")
                            .datum(this.cognitiveTimelineData)
                            .attr("fill", "none")
                            .attr("stroke", "#3b82f6")
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.7)
                            .attr("d", line);
                        
                        // Add state points
                        const statePoints = g.selectAll(".state-point")
                            .data(this.cognitiveTimelineData)
                            .enter().append("circle")
                            .attr("class", "state-point")
                            .attr("cx", d => xScale(new Date(d.timestamp * 1000)))
                            .attr("cy", d => yScale(d.complexity_score))
                            .attr("r", d => radiusScale(d.change_magnitude))
                            .attr("fill", d => colorScale(d.state_type))
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 2)
                            .style("cursor", "pointer")
                            .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                            .on("mouseover", (event, d) => this.showTimelineTooltip(event, d))
                            .on("mouseout", () => this.hideTimelineTooltip())
                            .on("click", (event, d) => this.selectTimelineState(d));
                        
                        // Add axes
                        g.append("g")
                            .attr("transform", `translate(0, ${height})`)
                            .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")))
                            .style("color", "#9ca3af");
                        
                        g.append("g")
                            .call(d3.axisLeft(yScale))
                            .style("color", "#9ca3af");
                        
                        // Add axis labels
                        g.append("text")
                            .attr("transform", "rotate(-90)")
                            .attr("y", 0 - margin.left)
                            .attr("x", 0 - (height / 2))
                            .attr("dy", "1em")
                            .style("text-anchor", "middle")
                            .style("fill", "#9ca3af")
                            .style("font-size", "12px")
                            .text("Complexity Score");
                        
                        g.append("text")
                            .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 10})`)
                            .style("text-anchor", "middle")
                            .style("fill", "#9ca3af")
                            .style("font-size", "12px")
                            .text("Timeline");
                        
                        // Add legend
                        const legend = g.append("g")
                            .attr("class", "legend")
                            .attr("transform", `translate(${width - 120}, 20)`);
                        
                        const stateTypes = [...new Set(this.cognitiveTimelineData.map(d => d.state_type))];
                        
                        legend.selectAll(".legend-item")
                            .data(stateTypes)
                            .enter().append("g")
                            .attr("class", "legend-item")
                            .attr("transform", (d, i) => `translate(0, ${i * 20})`)
                            .each(function(d) {
                                const item = d3.select(this);
                                item.append("circle")
                                    .attr("r", 6)
                                    .attr("fill", colorScale(d));
                                item.append("text")
                                    .attr("x", 12)
                                    .attr("y", 4)
                                    .style("font-size", "11px")
                                    .style("fill", "#e5e7eb")
                                    .text(d);
                            });
                        
                        // Highlight current state
                        this.updateTimelineHighlight();
                        
                        console.log('Timeline visualization rendered successfully');
                        
                    } catch (error) {
                        console.error('Error rendering timeline visualization:', error);
                    }
                },

                showTimelineTooltip(event, state) {
                    // Create tooltip content
                    const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "timeline-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0, 0, 0, 0.9)")
                        .style("color", "white")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000")
                        .style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)");
                    
                    tooltip.html(`
                        <div class="font-semibold mb-1">${state.state_type}</div>
                        <div class="text-gray-300 mb-2">#${state.sequence_number}</div>
                        <div class="text-sm">
                            <div>Complexity: ${state.complexity_score.toFixed(1)}</div>
                            <div>Change: ${state.change_magnitude.toFixed(1)}%</div>
                            <div>Time: ${new Date(state.timestamp * 1000).toLocaleTimeString()}</div>
                        </div>
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                },

                hideTimelineTooltip() {
                    d3.selectAll(".timeline-tooltip").remove();
                },

                selectTimelineState(state) {
                    this.selectedTimelineState = state;
                    this.currentTimelineIndex = this.cognitiveTimelineData.findIndex(s => s.state_id === state.state_id);
                    this.updateTimelineHighlight();
                },

                updateTimelineHighlight() {
                    if (!this.$refs.cognitiveTimelineSvg) return;
                    
                    const svg = d3.select(this.$refs.cognitiveTimelineSvg);
                    
                    // Reset all points
                    svg.selectAll(".state-point")
                        .attr("stroke-width", 2)
                        .style("opacity", 0.7);
                    
                    // Highlight current state
                    if (this.selectedTimelineState) {
                        svg.selectAll(".state-point")
                            .filter(d => d.state_id === this.selectedTimelineState.state_id)
                            .attr("stroke-width", 4)
                            .style("opacity", 1);
                    }
                },

                // Timeline animation controls
                playTimelineAnimation() {
                    if (this.isTimelineAnimating) {
                        this.stopTimelineAnimation();
                    } else {
                        this.startTimelineAnimation();
                    }
                },

                startTimelineAnimation() {
                    if (!this.cognitiveTimelineData.length) return;
                    
                    this.isTimelineAnimating = true;
                    const interval = 1000 / this.timelineAnimationSpeed;
                    
                    this.timelineInterval = setInterval(() => {
                        if (this.currentTimelineIndex < this.cognitiveTimelineData.length - 1) {
                            this.stepTimelineForward();
                        } else {
                            this.stopTimelineAnimation();
                        }
                    }, interval);
                },

                stopTimelineAnimation() {
                    this.isTimelineAnimating = false;
                    if (this.timelineInterval) {
                        clearInterval(this.timelineInterval);
                        this.timelineInterval = null;
                    }
                },

                toggleTimelinePlayback() {
                    if (this.isTimelineAnimating) {
                        this.stopTimelineAnimation();
                    } else {
                        this.startTimelineAnimation();
                    }
                },

                stepTimelineForward() {
                    if (this.currentTimelineIndex < this.cognitiveTimelineData.length - 1) {
                        this.currentTimelineIndex++;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                stepTimelineBackward() {
                    if (this.currentTimelineIndex > 0) {
                        this.currentTimelineIndex--;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                seekToTimelinePosition(index) {
                    const targetIndex = parseInt(index);
                    if (targetIndex >= 0 && targetIndex < this.cognitiveTimelineData.length) {
                        this.currentTimelineIndex = targetIndex;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                resetTimelineView() {
                    this.stopTimelineAnimation();
                    this.currentTimelineIndex = 0;
                    this.selectedTimelineState = this.cognitiveTimelineData[0];
                    this.updateTimelineHighlight();
                },

                // State comparison and restoration
                canCompareWithPrevious() {
                    return this.currentTimelineIndex > 0;
                },

                async compareWithPreviousState() {
                    if (!this.canCompareWithPrevious()) return;
                    
                    const currentState = this.cognitiveTimelineData[this.currentTimelineIndex];
                    const previousState = this.cognitiveTimelineData[this.currentTimelineIndex - 1];
                    
                    try {
                        const response = await fetch('/api/cognitive-states/compare', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                state_id_1: previousState.state_id,
                                state_id_2: currentState.state_id
                            })
                        });
                        
                        if (response.ok) {
                            this.stateComparison = await response.json();
                            this.showComparisonModal = true;
                        } else {
                            throw new Error('Failed to compare states');
                        }
                        
                    } catch (error) {
                        console.error('Error comparing states:', error);
                        this.showToast('Error comparing states', 'error');
                    }
                },

                async restoreToState(state) {
                    if (!state) return;
                    
                    const confirmed = confirm(`Are you sure you want to restore to state "${state.state_type}" from ${new Date(state.timestamp * 1000).toLocaleString()}?\n\nThis will create a backup of the current state.`);
                    
                    if (!confirmed) return;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/${state.state_id}/restore`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ confirm: true })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            this.showToast(`State restored successfully! Backup: ${result.backup_state_id}`, 'success');
                            
                            // Refresh timeline to show new backup state
                            await this.loadCognitiveTimeline();
                        } else {
                            const error = await response.json();
                            throw new Error(error.detail || 'Failed to restore state');
                        }
                        
                    } catch (error) {
                        console.error('Error restoring state:', error);
                        this.showToast(`Error restoring state: ${error.message}`, 'error');
                    }
                },

                jumpToTimelineState(stateId) {
                    const index = this.cognitiveTimelineData.findIndex(s => s.state_id === stateId);
                    if (index !== -1) {
                        this.seekToTimelinePosition(index);
                    }
                },

                // Heatmap and network visualization placeholders
                renderTimelineHeatmap() {
                    if (!this.$refs.cognitiveHeatmap) return;
                    
                    const container = this.$refs.cognitiveHeatmap;
                    container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><div><i data-lucide="calendar" class="w-12 h-12 mx-auto mb-4 opacity-50"></i><p>Heatmap visualization coming soon</p></div></div>';
                    
                    // Re-initialize icons for the new content
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                },

                renderTimelineNetwork() {
                    if (!this.$refs.cognitiveNetworkSvg) return;
                    
                    const svg = d3.select(this.$refs.cognitiveNetworkSvg);
                    svg.selectAll("*").remove();
                    
                    const width = this.$refs.cognitiveNetworkSvg.clientWidth;
                    const height = this.$refs.cognitiveNetworkSvg.clientHeight;
                    
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", "#9ca3af")
                        .style("font-size", "16px")
                        .text("Network visualization coming soon");
                },

                // =================== ACTION MONITOR METHODS ===================

                async initializeActionMonitor() {
                    console.log(' Initializing Action Execution Monitor...');
                    
                    try {
                        // Initialize action monitor data
                        await this.loadActionMonitorData();
                        
                        // Initialize performance charts
                        await this.$nextTick();
                        this.renderActionPerformanceCharts();
                        
                        // Start real-time monitoring if enabled
                        if (this.actionMonitorSettings.autoRefresh) {
                            this.startActionMonitoring();
                        }
                        
                        // Initialize WebSocket connection for real-time updates
                        this.initializeActionWebSocket();
                        
                        console.log(' Action Execution Monitor initialized successfully');
                        
                    } catch (error) {
                        console.error(' Error initializing action monitor:', error);
                        this.showToast('Error initializing action monitor', 'error');
                    }
                },

                async loadActionMonitorData() {
                    try {
                        // Load real action data from database
                        this.loadRealActionMonitorData();
                        
                        // Calculate real-time metrics
                        this.updateActionMetrics();
                        
                        // Update tool usage statistics
                        this.calculateToolUsageStats();
                        
                        // Update status
                        this.actionMonitorStatus.lastUpdate = Date.now();
                        this.actionMonitorStatus.connected = true;
                        
                    } catch (error) {
                        console.error('Error loading action monitor data:', error);
                        this.actionMonitorStatus.connected = false;
                        throw error;
                    }
                },

                loadRealActionMonitorData() {
                    const now = Date.now() / 1000;
                    
                    // Get real running actions from database
                    this.actionMonitorData.realTimeActions = this.executeQuery(`
                        SELECT * FROM actions 
                        WHERE status = 'in_progress' 
                        OR (status IS NULL AND started_at > ?)
                        ORDER BY started_at DESC
                        LIMIT 10
                    `, [now - 3600]); // Actions from last hour
                    
                    // Get real queued actions (actions that haven't started yet)
                    this.actionMonitorData.queuedActions = this.executeQuery(`
                        SELECT * FROM actions 
                        WHERE status = 'pending' 
                        OR (started_at IS NULL AND created_at > ?)
                        ORDER BY created_at ASC
                        LIMIT 20
                    `, [now - 86400]); // Created in last 24 hours
                    
                    // Get real completed actions
                    this.actionMonitorData.completedActions = this.executeQuery(`
                        SELECT 
                            *,
                            (completed_at - started_at) * 1000 as execution_time
                        FROM actions 
                        WHERE status = 'completed' 
                        AND completed_at IS NOT NULL
                        ORDER BY completed_at DESC
                        LIMIT 50
                    `);
                    
                    // Get real failed actions as error log
                    this.actionMonitorData.errorLog = this.executeQuery(`
                        SELECT 
                            action_id as id,
                            title,
                            error_message as message,
                            action_type,
                            tool_name,
                            created_at as timestamp,
                            'error' as type,
                            'medium' as severity
                        FROM actions 
                        WHERE status = 'failed' 
                        OR error_message IS NOT NULL
                        ORDER BY created_at DESC
                        LIMIT 20
                    `);
                    
                    // Get real batch operations (if any workflow has multiple actions)
                    const batchWorkflows = this.executeQuery(`
                        SELECT 
                            w.workflow_id as batch_id,
                            w.title as name,
                            COUNT(a.action_id) as total,
                            SUM(CASE WHEN a.status = 'completed' THEN 1 ELSE 0 END) as completed,
                            MIN(a.started_at) as started_at
                        FROM workflows w
                        LEFT JOIN actions a ON w.workflow_id = a.workflow_id
                        WHERE a.action_id IS NOT NULL
                        GROUP BY w.workflow_id
                        HAVING COUNT(a.action_id) > 3
                        ORDER BY MIN(a.started_at) DESC
                        LIMIT 5
                    `);
                    
                    this.actionMonitorData.batchOperations = batchWorkflows.map(batch => ({
                        ...batch,
                        estimated_completion: batch.completed < batch.total ? 
                            Math.ceil((batch.total - batch.completed) * 2) + ' min' : 'Completed'
                    }));
                },

                updateActionMetrics() {
                    const now = Date.now() / 1000;
                    const hourAgo = now - 3600;
                    
                    // Calculate actions per second from real data
                    const recentActions = this.actionMonitorData.completedActions.filter(a => 
                        a.completed_at && a.completed_at > hourAgo
                    );
                    this.realtimeMetrics.actionsPerSecond = Math.round((recentActions.length / 3600) * 100) / 100;
                    
                    // Calculate average response time from real execution times
                    if (recentActions.length > 0) {
                        this.realtimeMetrics.avgResponseTime = Math.round(
                            recentActions.reduce((sum, a) => sum + (a.execution_time || 0), 0) / recentActions.length
                        );
                    } else {
                        this.realtimeMetrics.avgResponseTime = 0;
                    }
                    
                    // Calculate real success rate
                    const totalActions = this.executeQuery(`
                        SELECT COUNT(*) as count FROM actions 
                        WHERE created_at > ?
                    `, [hourAgo])[0]?.count || 0;
                    
                    const completedActions = this.executeQuery(`
                        SELECT COUNT(*) as count FROM actions 
                        WHERE status = 'completed' AND created_at > ?
                    `, [hourAgo])[0]?.count || 0;
                    
                    if (totalActions > 0) {
                        this.actionMonitorStatus.successRate = Math.round((completedActions / totalActions) * 100);
                    } else {
                        this.actionMonitorStatus.successRate = 100; // No recent actions
                    }
                    
                    // Update error count from real data
                    this.realtimeMetrics.errorCount = this.actionMonitorData.errorLog.length;
                    
                    // Update total actions from database
                    this.actionMonitorStatus.totalActions = this.executeQuery(`
                        SELECT COUNT(*) as count FROM actions
                    `)[0]?.count || 0;
                    
                    // Calculate real average execution time
                    const avgExecTime = this.executeQuery(`
                        SELECT AVG((completed_at - started_at) * 1000) as avg_time 
                        FROM actions 
                        WHERE completed_at IS NOT NULL AND started_at IS NOT NULL
                        AND created_at > ?
                    `, [hourAgo])[0]?.avg_time;
                    
                    this.actionMonitorStatus.avgExecutionTime = avgExecTime ? Math.round(avgExecTime) : 0;
                },

                calculateToolUsageStats() {
                    const stats = {};
                    
                    // Process all actions to build tool usage statistics
                    [...this.actionMonitorData.realTimeActions, ...this.actionMonitorData.completedActions, ...this.actionMonitorData.queuedActions]
                        .forEach(action => {
                            const tool = action.tool_name || action.action_type || 'Unknown';
                            
                            if (!stats[tool]) {
                                stats[tool] = {
                                    count: 0,
                                    total_time: 0,
                                    successes: 0,
                                    failures: 0
                                };
                            }
                            
                            stats[tool].count++;
                            
                            if (action.status === 'completed' || action.status === 'running') {
                                stats[tool].successes++;
                                stats[tool].total_time += action.execution_time || 500;
                            }
                            
                            if (action.status === 'failed') {
                                stats[tool].failures++;
                            }
                        });
                    
                    // Calculate derived statistics
                    Object.keys(stats).forEach(tool => {
                        const toolStats = stats[tool];
                        toolStats.avg_time = toolStats.total_time > 0 ? Math.round(toolStats.total_time / Math.max(1, toolStats.successes)) : 0;
                        toolStats.success_rate = Math.round((toolStats.successes / Math.max(1, toolStats.count)) * 100);
                    });
                    
                    this.actionMonitorData.toolUsageStats = stats;
                },

                // Real-time monitoring controls
                startActionMonitoring() {
                    if (this.actionMonitorInterval) {
                        clearInterval(this.actionMonitorInterval);
                    }
                    
                    this.isMonitoringActions = true;
                    this.actionMonitorInterval = setInterval(() => {
                        this.refreshActionMonitor();
                    }, this.actionMonitorSettings.refreshInterval);
                    
                    this.showToast('Action monitoring started ', 'success');
                },

                stopActionMonitoring() {
                    if (this.actionMonitorInterval) {
                        clearInterval(this.actionMonitorInterval);
                        this.actionMonitorInterval = null;
                    }
                    
                    this.isMonitoringActions = false;
                    this.showToast('Action monitoring stopped', 'info');
                },

                toggleActionMonitoring() {
                    if (this.isMonitoringActions) {
                        this.stopActionMonitoring();
                    } else {
                        this.startActionMonitoring();
                    }
                },

                async refreshActionMonitor() {
                    try {
                        await this.loadActionMonitorData();
                        
                        // Update performance metrics
                        this.updateActionMetrics();
                        
                        // Update charts if visible
                        if (this.currentView === 'action-monitor') {
                            this.updatePerformanceCharts();
                        }
                        
                        // Check for alerts
                        this.checkActionAlerts();
                        
                    } catch (error) {
                        console.error('Error refreshing action monitor:', error);
                    }
                },

                checkActionAlerts() {
                    // Check for high error rate
                    if (this.actionMonitorStatus.successRate < 70) {
                        if (this.actionMonitorSettings.enableNotifications) {
                            this.showToast(`Warning: Success rate dropped to ${this.actionMonitorStatus.successRate}%`, 'warning');
                        }
                        if (this.actionMonitorSettings.soundAlerts) {
                            this.playAlertSound('warning');
                        }
                    }
                    
                    // Check for queue backup
                    if (this.actionMonitorData.queuedActions.length > 10) {
                        if (this.actionMonitorSettings.enableNotifications) {
                            this.showToast(`Queue backup: ${this.actionMonitorData.queuedActions.length} actions queued`, 'warning');
                        }
                    }
                    
                    // Check for long-running actions
                    const now = Date.now() / 1000;
                    this.actionMonitorData.realTimeActions.forEach(action => {
                        const runtime = now - action.started_at;
                        if (runtime > 300 && this.actionMonitorSettings.enableNotifications) { // 5 minutes
                            this.showToast(`Long-running action: ${action.title || action.tool_name} (${Math.round(runtime/60)}m)`, 'info');
                        }
                    });
                },

                playAlertSound(type) {
                    // Simple beep using Web Audio API
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = type === 'warning' ? 800 : 400;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    } catch (error) {
                        console.warn('Could not play alert sound:', error);
                    }
                },

                // WebSocket connection for real-time updates
                initializeActionWebSocket() {
                    // In a real implementation, this would connect to the FastAPI WebSocket endpoint
                    try {
                        // Simulate WebSocket connection
                        console.log('Action Monitor WebSocket connection simulated');
                        this.actionMonitorStatus.connected = true;
                    } catch (error) {
                        console.error('Error initializing action WebSocket:', error);
                        this.actionMonitorStatus.connected = false;
                    }
                },

                // Filtering and search
                filterActionMonitor() {
                    // The filtering is handled in the getFilteredActions method
                    // This method can trigger additional processing if needed
                },

                getFilteredActions(status) {
                    let actions = [];
                    
                    switch (status) {
                        case 'running':
                            actions = this.actionMonitorData.realTimeActions;
                            break;
                        case 'queued':
                            actions = this.actionMonitorData.queuedActions;
                            break;
                        case 'completed':
                            actions = this.actionMonitorData.completedActions;
                            break;
                        case 'failed':
                            actions = this.actionMonitorData.errorLog.map(error => ({
                                action_id: error.id,
                                title: `Failed: ${error.type}`,
                                tool_name: error.action_type,
                                error_message: error.message,
                                failed_at: error.timestamp,
                                status: 'failed'
                            }));
                            break;
                        default:
                            actions = [
                                ...this.actionMonitorData.realTimeActions,
                                ...this.actionMonitorData.queuedActions,
                                ...this.actionMonitorData.completedActions
                            ];
                    }
                    
                    // Apply filters
                    if (this.actionFilterType !== 'all' && this.actionFilterType !== status && status === 'all') {
                        return this.getFilteredActions(this.actionFilterType);
                    }
                    
                    if (this.actionFilterTool) {
                        actions = actions.filter(action => 
                            action.tool_name === this.actionFilterTool || action.action_type === this.actionFilterTool
                        );
                    }
                    
                    if (this.actionSearchQuery) {
                        const query = this.actionSearchQuery.toLowerCase();
                        actions = actions.filter(action =>
                            action.title?.toLowerCase().includes(query) ||
                            action.tool_name?.toLowerCase().includes(query) ||
                            action.action_type?.toLowerCase().includes(query) ||
                            action.description?.toLowerCase().includes(query) ||
                            action.reasoning?.toLowerCase().includes(query)
                        );
                    }
                    
                    return actions;
                },

                getUniqueTools() {
                    const tools = new Set();
                    
                    [...this.actionMonitorData.realTimeActions, ...this.actionMonitorData.queuedActions, ...this.actionMonitorData.completedActions]
                        .forEach(action => {
                            if (action.tool_name) tools.add(action.tool_name);
                            if (action.action_type) tools.add(action.action_type);
                        });
                    
                    return Array.from(tools).sort();
                },

                // Action interaction methods
                selectActionForDetails(action) {
                    this.selectedActionDetail = action;
                    this.showActionDetailModal = true;
                },

                async retryAction(action) {
                    try {
                        this.showToast(`Retrying action: ${action.title || action.tool_name}`, 'info');
                        
                        // In a real implementation, this would call the retry API
                        // For now, we'll simulate by moving the action back to queued
                        const newAction = {
                            ...action,
                            action_id: `retry_${action.action_id}`,
                            status: 'queued',
                            queue_position: this.actionMonitorData.queuedActions.length + 1,
                            created_at: Date.now() / 1000
                        };
                        
                        this.actionMonitorData.queuedActions.push(newAction);
                        
                        // Remove from error log
                        this.actionMonitorData.errorLog = this.actionMonitorData.errorLog.filter(e => e.id !== action.action_id);
                        
                        this.showToast('Action queued for retry', 'success');
                        
                    } catch (error) {
                        console.error('Error retrying action:', error);
                        this.showToast('Error retrying action', 'error');
                    }
                },

                async cancelQueuedAction(action) {
                    try {
                        // Remove from queue
                        this.actionMonitorData.queuedActions = this.actionMonitorData.queuedActions.filter(a => a.action_id !== action.action_id);
                        
                        // Update queue positions
                        this.actionMonitorData.queuedActions.forEach((a, index) => {
                            a.queue_position = index + 1;
                        });
                        
                        this.showToast(`Cancelled: ${action.title || action.tool_name}`, 'info');
                        
                    } catch (error) {
                        console.error('Error cancelling action:', error);
                        this.showToast('Error cancelling action', 'error');
                    }
                },

                // Error handling
                showErrorDetails(error) {
                    alert(`Error Details:\n\nType: ${error.type}\nMessage: ${error.message}\nTime: ${new Date(error.timestamp * 1000).toLocaleString()}\nSeverity: ${error.severity}`);
                },

                clearErrorLog() {
                    this.actionMonitorData.errorLog = [];
                    this.showToast('Error log cleared', 'info');
                },

                // Performance charts
                async renderActionPerformanceCharts() {
                    if (!window.Chart) return;
                    
                    await this.$nextTick();
                    
                    try {
                        await this.renderExecutionTimeChart();
                        await this.renderThroughputChart();
                    } catch (error) {
                        console.error('Error rendering action performance charts:', error);
                    }
                },

                async renderThroughputChart() {
                    const canvas = this.$refs.throughputChart;
                    if (!canvas || !canvas.getContext) {
                        console.warn('Throughput chart canvas not available or invalid');
                        return;
                    }
                    
                    // Verify canvas is still in DOM
                    if (!document.contains(canvas)) {
                        console.warn('Throughput chart canvas no longer in DOM');
                        return;
                    }
                    
                    // Clear any existing chart first
                    if (this.actionPerformanceCharts.throughput) {
                        try {
                            this.actionPerformanceCharts.throughput.destroy();
                        } catch (e) {
                            console.warn('Error destroying throughput chart:', e);
                        }
                        this.actionPerformanceCharts.throughput = null;
                    }
                    
                    // Reset canvas dimensions to prevent infinite growth
                    const canvasParent = canvas.parentElement;
                    const targetWidth = canvasParent ? canvasParent.clientWidth : 400;
                    const targetHeight = 192;
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    canvas.style.width = targetWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.style.maxHeight = targetHeight + 'px';
                    
                    // Get real action throughput data
                    const actions = this.executeQuery(`
                        SELECT started_at
                        FROM actions 
                        WHERE started_at IS NOT NULL
                        ORDER BY started_at DESC
                        LIMIT 500
                    `);
                    
                    // Group actions by 5-minute intervals
                    const timeSlots = {};
                    const now = Date.now() / 1000;
                    
                    // Initialize time slots for last hour (12 x 5-minute intervals)
                    for (let i = 11; i >= 0; i--) {
                        const slotTime = now - (i * 300); // 5 minute intervals
                        const slotKey = Math.floor(slotTime / 300) * 300;
                        timeSlots[slotKey] = 0;
                    }
                    
                    // Count actions in each time slot
                    actions.forEach(action => {
                        const slotKey = Math.floor(action.started_at / 300) * 300;
                        if (timeSlots.hasOwnProperty(slotKey)) {
                            timeSlots[slotKey]++;
                        }
                    });
                    
                    // Convert to chart data
                    const throughputData = Object.keys(timeSlots)
                        .sort((a, b) => a - b)
                        .map(slotKey => ({
                            time: new Date(parseInt(slotKey) * 1000),
                            actionsPerInterval: timeSlots[slotKey]
                        }));
                    
                    this.actionPerformanceCharts.throughput = new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: throughputData.map(d => d.time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })),
                            datasets: [{
                                label: 'Actions per 5min',
                                data: throughputData.map(d => d.actionsPerInterval),
                                backgroundColor: '#3b82f6',
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#9ca3af',
                                        stepSize: 1
                                    },
                                    grid: { color: 'rgba(156, 163, 175, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#9ca3af' },
                                    grid: { display: false }
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                },

                async renderExecutionTimeChart() {
                    const canvas = this.$refs.executionTimeChart;
                    if (!canvas || !canvas.getContext) {
                        console.warn('Execution time chart canvas not available or invalid');
                        return;
                    }
                    
                    // Verify canvas is still in DOM
                    if (!document.contains(canvas)) {
                        console.warn('Execution time chart canvas no longer in DOM');
                        return;
                    }
                    
                    // Clear any existing chart first
                    if (this.actionPerformanceCharts.executionTime) {
                        try {
                            this.actionPerformanceCharts.executionTime.destroy();
                        } catch (e) {
                            console.warn('Error destroying execution time chart:', e);
                        }
                        this.actionPerformanceCharts.executionTime = null;
                    }
                    
                    // Reset canvas dimensions to prevent infinite growth
                    const canvasParent = canvas.parentElement;
                    const targetWidth = canvasParent ? canvasParent.clientWidth : 400;
                    const targetHeight = 192;
                    
                    canvas.width = targetWidth;
                    canvas.height = targetHeight;
                    canvas.style.width = targetWidth + 'px';
                    canvas.style.height = targetHeight + 'px';
                    canvas.style.maxHeight = targetHeight + 'px';
                    
                    // Get real execution time data from actions table
                    const actions = this.executeQuery(`
                        SELECT 
                            started_at,
                            completed_at,
                            action_type,
                            tool_name
                        FROM actions 
                        WHERE started_at IS NOT NULL 
                        AND completed_at IS NOT NULL
                        ORDER BY started_at DESC
                        LIMIT 100
                    `);
                    
                    // Group actions by time intervals and calculate average execution time
                    const timeIntervals = {};
                    const now = Date.now() / 1000;
                    
                    // Initialize 12 time slots (5-minute intervals)
                    for (let i = 11; i >= 0; i--) {
                        const slotTime = now - (i * 300); // 5 minute intervals
                        const slotKey = Math.floor(slotTime / 300) * 300;
                        timeIntervals[slotKey] = { executions: [], avgTime: 0 };
                    }
                    
                    // Group real actions by time slots
                    actions.forEach(action => {
                        const executionTime = (action.completed_at - action.started_at) * 1000; // Convert to milliseconds
                        const slotKey = Math.floor(action.started_at / 300) * 300;
                        
                        if (timeIntervals[slotKey]) {
                            timeIntervals[slotKey].executions.push(executionTime);
                        }
                    });
                    
                    // Calculate averages for each time slot
                    const executionData = Object.keys(timeIntervals)
                        .sort((a, b) => a - b)
                        .map(slotKey => {
                            const slot = timeIntervals[slotKey];
                            const avgTime = slot.executions.length > 0 
                                ? slot.executions.reduce((sum, time) => sum + time, 0) / slot.executions.length
                                : 0;
                            
                            return {
                                time: new Date(parseInt(slotKey) * 1000),
                                avgTime: avgTime
                            };
                        });
                    
                    this.actionPerformanceCharts.executionTime = new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: executionData.map(d => d.time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })),
                            datasets: [{
                                label: 'Avg Execution Time (ms)',
                                data: executionData.map(d => d.avgTime),
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointRadius: 3,
                                pointHoverRadius: 6
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#9ca3af',
                                        callback: value => Math.round(value) + 'ms'
                                    },
                                    grid: { color: 'rgba(156, 163, 175, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#9ca3af' },
                                    grid: { display: false }
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                },

                updatePerformanceCharts() {
                    // Debounce chart updates to prevent excessive re-rendering
                    if (this.performanceChartsUpdateTimer) {
                        clearTimeout(this.performanceChartsUpdateTimer);
                    }
                    
                    this.performanceChartsUpdateTimer = setTimeout(() => {
                        this.renderExecutionTimeChart();
                        this.renderThroughputChart();
                    }, 250);
                },

                // Settings and export
                updateMonitorSettings() {
                    // Update monitoring interval if auto-refresh is enabled
                    if (this.actionMonitorSettings.autoRefresh && this.isMonitoringActions) {
                        this.stopActionMonitoring();
                        this.startActionMonitoring();
                    }
                    
                    // Save settings to localStorage
                    try {
                        localStorage.setItem('ums-action-monitor-settings', JSON.stringify(this.actionMonitorSettings));
                    } catch (e) {
                        console.warn('Failed to save action monitor settings:', e);
                    }
                },

                exportActionReport() {
                    const report = {
                        generated_at: new Date().toISOString(),
                        summary: {
                            total_actions: this.actionMonitorStatus.totalActions,
                            success_rate: this.actionMonitorStatus.successRate,
                            avg_execution_time: this.actionMonitorStatus.avgExecutionTime,
                            errors_24h: this.realtimeMetrics.errorCount
                        },
                        real_time_actions: this.actionMonitorData.realTimeActions,
                        queued_actions: this.actionMonitorData.queuedActions,
                        completed_actions: this.actionMonitorData.completedActions.slice(0, 50),
                        batch_operations: this.actionMonitorData.batchOperations,
                        tool_usage_stats: this.actionMonitorData.toolUsageStats,
                        error_log: this.actionMonitorData.errorLog,
                        realtime_metrics: this.realtimeMetrics,
                        performance_metrics: this.actionMonitorData.performanceMetrics
                    };
                    
                    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `action-monitor-report-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Action monitoring report exported! ', 'success');
                },

                // Utility methods
                formatElapsedTime(timestamp) {
                    if (!timestamp) return 'Unknown';
                    
                    const now = Date.now() / 1000;
                    const elapsed = now - timestamp;
                    
                    if (elapsed < 60) return `${Math.floor(elapsed)}s ago`;
                    if (elapsed < 3600) return `${Math.floor(elapsed / 60)}m ago`;
                    return `${Math.floor(elapsed / 3600)}h ago`;
                },

                getActionPriorityColor(priority) {
                    const colors = {
                        high: 'bg-red-400',
                        normal: 'bg-yellow-400',
                        low: 'bg-blue-400'
                    };
                    return colors[priority] || 'bg-gray-400';
                },

                // Memory Quality Inspector Methods
                async initializeMemoryQuality() {
                    console.log(' Initializing Memory Quality Inspector...');
                    
                    try {
                        // Load quality stats on initialization
                        await this.loadQualityStats();
                        
                        // Load any existing analysis results
                        if (this.lastQualityAnalysis) {
                            this.qualityAnalysisResults = this.lastQualityAnalysis;
                            this.qualityIssues = this.lastQualityAnalysis.issues || [];
                            this.autoFixAvailable = this.qualityIssues.filter(i => i.auto_fixable);
                        }
                        
                        console.log(' Memory Quality Inspector initialized');
                    } catch (error) {
                        console.error(' Failed to initialize Memory Quality Inspector:', error);
                        this.showToast('Failed to initialize Quality Inspector', 'error');
                    }
                },

                async loadQualityStats() {
                    try {
                        const response = await fetch('/api/memory-quality/stats');
                        
                        if (!response.ok) {
                            throw new Error(`Failed to load quality stats: ${response.statusText}`);
                        }
                        
                        // Check if response is JSON
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            throw new Error('API returned non-JSON response');
                        }
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.qualityStats = data.stats;
                        }
                    } catch (error) {
                        console.error('Error loading quality stats:', error);
                        this.showToast('Memory quality API unavailable', 'warning');
                        
                        // Provide fallback stats
                        this.qualityStats = {
                            overall_score: 75,
                            total_memories: this.memories.length,
                            duplicate_clusters: 0,
                            orphaned_memories: 0,
                            stale_memories: 0,
                            quality_issues: 0
                        };
                    }
                },

                async runQuickQualityScan() {
                    this.isAnalyzing = true;
                    
                    try {
                        this.showToast('Running quick quality scan...', 'info');
                        
                        const response = await fetch('/api/memory-quality/quick-scan');
                        const data = await response.json();
                        
                        if (data.success) {
                            const metrics = data.quick_metrics;
                            
                            // Update quality stats with quick metrics
                            this.qualityStats = {
                                ...this.qualityStats,
                                overall_score: metrics.overall_score,
                                total_memories: metrics.total_memories
                            };
                            
                            // Load detailed data
                            await this.loadDuplicates();
                            await this.loadOrphanedMemories();
                            
                            this.showToast(`Quick scan complete! Score: ${metrics.overall_score}/100`, 'success');
                        } else {
                            throw new Error('Quick scan failed');
                        }
                    } catch (error) {
                        console.error('Error running quick scan:', error);
                        this.showToast('Quick scan failed', 'error');
                    } finally {
                        this.isAnalyzing = false;
                    }
                },

                async runFullQualityAnalysis() {
                    this.isAnalyzing = true;
                    
                    try {
                        this.showToast('Running comprehensive quality analysis...', 'info');
                        
                        const response = await fetch('/api/memory-quality/analyze', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(this.qualityAnalysisSettings)
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.qualityAnalysisResults = data.analysis;
                            this.qualityIssues = data.analysis.issues || [];
                            this.autoFixAvailable = this.qualityIssues.filter(i => i.auto_fixable);
                            this.lastQualityAnalysis = data.analysis;
                            
                            // Update stats
                            this.qualityStats = {
                                ...this.qualityStats,
                                overall_score: data.analysis.overall_score,
                                total_memories: data.analysis.total_memories
                            };
                            
                            // Load detailed data
                            await this.loadDuplicates();
                            await this.loadOrphanedMemories();
                            
                            this.showToast(`Analysis complete! Found ${data.analysis.issues_found} issues`, 'success');
                        } else {
                            throw new Error('Analysis failed');
                        }
                    } catch (error) {
                        console.error('Error running analysis:', error);
                        this.showToast('Quality analysis failed', 'error');
                    } finally {
                        this.isAnalyzing = false;
                        this.showQualityAnalysisModal = false;
                    }
                },

                async loadDuplicates() {
                    try {
                        const response = await fetch('/api/memory-quality/duplicates');
                        const data = await response.json();
                        
                        if (data.success) {
                            this.duplicateClusters = data.clusters || [];
                        }
                    } catch (error) {
                        console.error('Error loading duplicates:', error);
                    }
                },

                async loadOrphanedMemories() {
                    try {
                        const response = await fetch('/api/memory-quality/orphaned');
                        const data = await response.json();
                        
                        if (data.success) {
                            this.orphanedMemories = data.orphaned_memories || [];
                        }
                    } catch (error) {
                        console.error('Error loading orphaned memories:', error);
                    }
                },

                get filteredQualityIssues() {
                    let filtered = this.qualityIssues;
                    
                    if (this.qualityFilterType !== 'all') {
                        filtered = filtered.filter(issue => issue.severity === this.qualityFilterType);
                    }
                    
                    if (this.qualitySearchQuery) {
                        const query = this.qualitySearchQuery.toLowerCase();
                        filtered = filtered.filter(issue =>
                            issue.title.toLowerCase().includes(query) ||
                            issue.description.toLowerCase().includes(query) ||
                            issue.recommendation.toLowerCase().includes(query)
                        );
                    }
                    
                    return filtered;
                },

                getIssueSeverityClass(severity) {
                    const classes = {
                        critical: 'bg-red-500/20 text-red-300',
                        high: 'bg-orange-500/20 text-orange-300',
                        medium: 'bg-yellow-500/20 text-yellow-300',
                        low: 'bg-blue-500/20 text-blue-300'
                    };
                    return classes[severity] || 'bg-gray-500/20 text-gray-300';
                },

                toggleIssueSelection(issue) {
                    if (!this.selectedQualityIssues) {
                        this.selectedQualityIssues = new Set();
                    }
                    
                    if (this.selectedQualityIssues.has(issue.issue_id)) {
                        this.selectedQualityIssues.delete(issue.issue_id);
                    } else {
                        this.selectedQualityIssues.add(issue.issue_id);
                    }
                },

                selectAllIssues() {
                    this.selectedQualityIssues = new Set(this.filteredQualityIssues.map(i => i.issue_id));
                },

                async fixIssue(issue) {
                    try {
                        this.showToast(`Fixing issue: ${issue.title}`, 'info');
                        
                        if (issue.issue_type === 'duplicate') {
                            // Handle duplicate merging
                            await this.mergeDuplicatesByIssue(issue);
                        } else if (issue.issue_type === 'stale') {
                            // Handle stale memory archiving
                            await this.archiveStaleMemories(issue);
                        } else {
                            // Generic auto-fix
                            await this.applyGenericFix(issue);
                        }
                        
                        // Remove from issues list
                        this.qualityIssues = this.qualityIssues.filter(i => i.issue_id !== issue.issue_id);
                        this.autoFixAvailable = this.qualityIssues.filter(i => i.auto_fixable);
                        
                        this.showToast('Issue fixed successfully!', 'success');
                    } catch (error) {
                        console.error('Error fixing issue:', error);
                        this.showToast('Failed to fix issue', 'error');
                    }
                },

                async mergeDuplicatesByIssue(issue) {
                    const memoryIds = issue.memory_ids;
                    const primaryId = memoryIds[0]; // Use first as primary
                    
                    const response = await fetch('/api/memory-quality/bulk-execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            operation_type: 'merge',
                            memory_ids: memoryIds,
                            target_memory_id: primaryId
                        })
                    });
                    
                    const data = await response.json();
                    if (!data.success) {
                        throw new Error('Merge operation failed');
                    }
                },

                async archiveStaleMemories(issue) {
                    const response = await fetch('/api/memory-quality/bulk-execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            operation_type: 'archive',
                            memory_ids: issue.memory_ids
                        })
                    });
                    
                    const data = await response.json();
                    if (!data.success) {
                        throw new Error('Archive operation failed');
                    }
                },

                async applyGenericFix(issue) {
                    // For other types of issues, implement specific fixes
                    console.log('Applying generic fix for:', issue);
                },

                async bulkFixIssues() {
                    const selectedIssues = this.qualityIssues.filter(i => this.selectedQualityIssues.has(i.issue_id));
                    
                    try {
                        this.showToast(`Fixing ${selectedIssues.length} issues...`, 'info');
                        
                        for (const issue of selectedIssues) {
                            if (issue.auto_fixable) {
                                await this.fixIssue(issue);
                            }
                        }
                        
                        this.selectedQualityIssues.clear();
                        this.showToast('Bulk fix completed!', 'success');
                    } catch (error) {
                        console.error('Error in bulk fix:', error);
                        this.showToast('Bulk fix failed', 'error');
                    }
                },

                bulkIgnoreIssues() {
                    const selectedIssues = Array.from(this.selectedQualityIssues);
                    this.qualityIssues = this.qualityIssues.filter(i => !selectedIssues.includes(i.issue_id));
                    this.selectedQualityIssues.clear();
                    this.showToast(`Ignored ${selectedIssues.length} issues`, 'info');
                },

                viewIssueDetails(issue) {
                    this.selectedQualityIssue = issue;
                    this.showQualityIssueModal = true;
                },

                viewDuplicateCluster(cluster) {
                    // Show detailed view of duplicate cluster
                    console.log('Viewing duplicate cluster:', cluster);
                },

                async mergeDuplicates(cluster) {
                    try {
                        this.showToast(`Merging ${cluster.duplicate_count} duplicates...`, 'info');
                        
                        const response = await fetch('/api/memory-quality/bulk-execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                operation_type: 'merge',
                                memory_ids: cluster.memory_ids,
                                target_memory_id: cluster.primary_memory_id
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            // Remove cluster from list
                            this.duplicateClusters = this.duplicateClusters.filter(c => c.cluster_id !== cluster.cluster_id);
                            this.showToast('Duplicates merged successfully!', 'success');
                        } else {
                            throw new Error('Merge failed');
                        }
                    } catch (error) {
                        console.error('Error merging duplicates:', error);
                        this.showToast('Failed to merge duplicates', 'error');
                    }
                },

                viewMemoryDetails(memory) {
                    this.selectedMemory = memory;
                    this.showMemoryModal = true;
                },

                async connectOrphanedMemory(memory) {
                    // Show dialog to connect memory to workflow
                    this.showToast('Connect memory feature coming soon', 'info');
                },

                async archiveOrphanedMemory(memory) {
                    try {
                        const response = await fetch('/api/memory-quality/bulk-execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                operation_type: 'archive',
                                memory_ids: [memory.memory_id]
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.orphanedMemories = this.orphanedMemories.filter(m => m.memory_id !== memory.memory_id);
                            this.showToast('Memory archived successfully!', 'success');
                        } else {
                            throw new Error('Archive failed');
                        }
                    } catch (error) {
                        console.error('Error archiving memory:', error);
                        this.showToast('Failed to archive memory', 'error');
                    }
                },

                async previewBulkOperation() {
                    try {
                        const memoryIds = Array.from(this.selectedMemoriesForBulk);
                        
                        const response = await fetch('/api/memory-quality/bulk-preview', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                operation_type: this.bulkOperationType,
                                memory_ids: memoryIds
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.bulkOperationPreview = data.operation;
                        } else {
                            throw new Error('Preview failed');
                        }
                    } catch (error) {
                        console.error('Error previewing bulk operation:', error);
                        this.showToast('Failed to preview operation', 'error');
                    }
                },

                async executeBulkOperation() {
                    try {
                        this.showToast('Executing bulk operation...', 'info');
                        
                        const response = await fetch('/api/memory-quality/bulk-execute', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                operation_type: this.bulkOperationPreview.operation_type,
                                memory_ids: this.bulkOperationPreview.memory_ids
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.success) {
                            this.showToast(data.message, 'success');
                            this.bulkOperationPreview = null;
                            this.selectedMemoriesForBulk.clear();
                            
                            // Refresh data
                            await this.loadQualityStats();
                            await this.loadDuplicates();
                            await this.loadOrphanedMemories();
                        } else {
                            throw new Error('Bulk operation failed');
                        }
                    } catch (error) {
                        console.error('Error executing bulk operation:', error);
                        this.showToast('Bulk operation failed', 'error');
                    }
                },

                clearBulkSelection() {
                    this.selectedMemoriesForBulk.clear();
                    this.bulkOperationPreview = null;
                },

                async runAutoFix() {
                    try {
                        this.showToast(`Applying ${this.autoFixAvailable.length} auto-fixes...`, 'info');
                        
                        for (const issue of this.autoFixAvailable) {
                            await this.fixIssue(issue);
                        }
                        
                        this.showToast('Auto-fix completed!', 'success');
                    } catch (error) {
                        console.error('Error in auto-fix:', error);
                        this.showToast('Auto-fix failed', 'error');
                    }
                }
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Load theme
            const savedTheme = localStorage.getItem('ums-explorer-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
        });

        // Initialize icons when Alpine is ready
        document.addEventListener('alpine:initialized', () => {
            if (window.lucide) {
                lucide.createIcons();
            }
            
            // Initialize Tippy.js tooltips after a short delay to ensure DOM is ready
            setTimeout(initializeTooltips, 500);
        });

        // Initialize Tippy.js tooltips
        function initializeTooltips() {
            if (typeof tippy !== 'undefined') {
                tippy('.dashboard-tooltip', {
                    theme: 'custom',
                    animation: 'scale',
                    duration: [300, 200],
                    delay: [500, 0],
                    interactive: false,
                    hideOnClick: true,
                    placement: 'top',
                    maxWidth: 350,
                    offset: [0, 10],
                    allowHTML: true,
                    onShow(instance) {
                        return true;
                    },
                    onHidden(instance) {
                        // Clean up any lingering tooltips
                    }
                });
                console.log(' Tippy.js tooltips initialized successfully');
            } else {
                console.warn(' Tippy.js not found, retrying in 100ms...');
                setTimeout(initializeTooltips, 100);
            }
        }
    </script>
</body>
</html>